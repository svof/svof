<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage />
	<TimerPackage />
	<AliasPackage />
	<ActionPackage />
	<ScriptPackage>
		<Script isActive="yes" isFolder="no">
			<name>Create Svof namespace</name>
			<packageName></packageName>
			<script>svo = svo or {
  autopause_on_def = function() end,
  balanceless = {},
  disable_seek = function() end,
	loader = {}
}
svo.modules_version = svo.modules_version or {}
svo.modules_version["svo (install me in module manager)"] = 1

ndb = ndb or {}

createBuffer('svo_prompt')</script>
			<eventHandlerList />
		</Script>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>3rdparty</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>notify</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>double_queue</name>
					<packageName></packageName>
					<script>---------------------------------------------------------------------------------
-- Copyright (C) 2010 Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
-- Copyright (C) 2010 Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- 
-- author Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- author Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;

-- This file is part of LuaNotify.

-- LuaNotify is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.

-- LuaNotify is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.

-- You should have received a copy of the GNU Lesser General Public License
-- along with LuaNotify.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
---------------------------------------------------------------------------------

---
-- @class module
-- @name ordered_set
-- @description DoubleQueue Class.
-- @author &lt;a href="mailto:tiagokatcipis@gmail.com"&gt;Tiago Katcipis&lt;/a&gt;
-- @author &lt;a href="mailto:paulo.pizarro@gmail.com"&gt;Paulo Pizarro&lt;/a&gt;
-- @copyright 2010 Tiago Katcipis, Paulo Pizarro.

local setmetatable = setmetatable
local pairs = pairs
local display = display

module("notify.double_queue")

-----------------------------------------------------
-- Class attributes and methods goes on this table --
-----------------------------------------------------
local DoubleQueue = {}

------------------------------------
-- Metamethods goes on this table --
------------------------------------
local DoubleQueue_mt = { __index = DoubleQueue }


--------------------------
-- Constructor function --
--------------------------

function new ()
    local object = {}
    -- set the metatable of the new object as the DoubleQueue_mt table (inherits DoubleQueue).
    setmetatable(object, DoubleQueue_mt)

    -- create all the instance state data.
    object.data          = {}
    object.data_position = {}
    object.first         = 1 
    object.last          = 0
    return object
end

---------------------------
-- Class private methods --
---------------------------
local function refresh_first(self)
    while(self.first &lt;= self.last) do
        if(self.data[self.first]) then
            return true
        end
        self.first = self.first + 1
    end
end


--------------------------
-- Class public methods --
--------------------------
function DoubleQueue:is_empty()
    return self.first &gt; self.last
end

function DoubleQueue:push_front(data)
    if(self.data_position[data]) then
        return
    end
    self.first = self.first - 1
    self.data[self.first]    = data
    self.data_position[data] = self.first
end

function DoubleQueue:push_back(data)
    if(self.data_position[data]) then
        return
    end
    self.last = self.last + 1
    self.data[self.last]     = data
    self.data_position[data] = self.last
end

function DoubleQueue:get_iterator()
    local first = self.first
    local function iterator()
        while(first &lt;= self.last) do
            local data = self.data[first]
            first = first + 1
            if(data) then
                return data
            end
        end    
    end 
    return iterator
end

function DoubleQueue:contains(data)
	return self.data_position[data] and true or false
end

function DoubleQueue:remove(data)
    if(not self.data_position[data]) then
        return 
    end
    self.data[self.data_position[data]] = nil
    self.data_position[data]            = nil
    refresh_first(self)
end

local function removeByValue(tbl, valueToRemove)
	for key, value in pairs(tbl) do
			if value == valueToRemove then
			  tbl[key] = nil
				return tbl
			end
	end
	
	return tbl
end

function DoubleQueue:removeIndex(position)
		if not self.data[position] then
			return
		end
		
    self.data[position] = nil		
    self.data_position  = removeByValue(self.data_position, position)
    refresh_first(self)
end

function DoubleQueue:position(data)
	return self.data_position[data]
end
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>signal</name>
					<packageName></packageName>
					<script>---------------------------------------------------------------------------------
-- Copyright (C) 2010 Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
-- Copyright (C) 2010 Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- 
-- author Paulo Pizarro  &lt;paulo.pizarro@gmail.com&gt;
-- author Tiago Katcipis &lt;tiagokatcipis@gmail.com&gt;
 
-- This file is part of LuaNotify.
 
-- LuaNotify is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
 
-- LuaNotify is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Lesser General Public License for more details.
 
-- You should have received a copy of the GNU Lesser General Public License
-- along with LuaNotify.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
---------------------------------------------------------------------------------

---
-- @class module
-- @name signal
-- @description Signal Class.
-- @author &lt;a href="mailto:tiagokatcipis@gmail.com"&gt;Tiago Katcipis&lt;/a&gt;
-- @author &lt;a href="mailto:paulo.pizarro@gmail.com"&gt;Paulo Pizarro&lt;/a&gt;
-- @copyright 2010 Tiago Katcipis, Paulo Pizarro.

local require = require
local setmetatable = setmetatable
local display = display

module("notify.signal")

local queue = require "notify.double_queue"

-----------------------------------------------------
-- Class attributes and methods goes on this table --
-----------------------------------------------------
local Signal = {} 


------------------------------------
-- Metamethods goes on this table --
------------------------------------
local Signal_mt = { __index = Signal }


--------------------------
-- Constructor function --
--------------------------
function new ()
    local object = {}      
    -- set the metatable of the new object as the Signal_mt table (inherits Signal).
    setmetatable(object, Signal_mt)

    -- create all the instance state data.
    object.handlers_block  = {}
    object.handlers        = queue.new()
    object.handler_names   = queue.new()
    object.pre_emit_funcs  = queue.new()
    object.pre_emit_names  = queue.new()
    object.post_emit_funcs = queue.new()
    object.post_emit_names = queue.new()
    object.signal_stopped = false
    return object
end


----------------------------------
-- Class definition and methods --
----------------------------------


---
-- Disconnects a handler function from this signal, the function will no longer be called.
-- @param handler_function – The function that will be disconnected.
function Signal:disconnect(handler_function)
    self.handlers:remove(handler_function)
    self.handlers_block[handler_function] = nil
end


---
-- Connects a handler function on this signal, all handlers connected will be called 
-- when the signal is emitted with a FIFO  behaviour (The first connected will be the first called).
-- @param handler_function – The function that will be called when this signal is emitted.
function Signal:connect(handler_function, handler_name)
    if(not self.handlers_block[handler_function]) then
        self.handlers_block[handler_function] = 0
				
				local position = self.handler_names:position(handler_name)
    		if position then
					self.handlers:removeIndex(position)
					self.handler_names:remove(handler_name)
					-- handlers_block table will keep growing as there's no way to find out what key to
					-- remove, but that is OK and should not affect anything
				end
		
        self.handlers:push_back(handler_function)
        self.handler_names:push_back(handler_name or "")
    end
end


---
-- Does not execute the given handler function when the signal is emitted until it is unblocked. 
-- It can be called several times for the same handler function.
-- @param handler_function – The handler function that will be blocked.
function Signal:block(handler_function)
    if(self.handlers_block[handler_function]) then
        self.handlers_block[handler_function] = self.handlers_block[handler_function] + 1
    end
end


---
-- Unblocks the given handler function, this handler function will be executed on 
-- the order it was previously connected, and it will only be unblocked when 
-- the calls to unblock are equal to the calls to block.
-- @param handler_function – The handler function that will be unblocked.
function Signal:unblock(handler_function)
    if(self.handlers_block[handler_function]) then
        if(self.handlers_block[handler_function] &gt; 0) then
            self.handlers_block[handler_function] = self.handlers_block[handler_function] - 1
        end
    end
end


---
-- Emits a signal calling the handler functions connected to this signal passing the given args.
-- @param … – A optional list of parameters, they will be repassed to the handler functions connected to this signal.
function Signal:emit(...)
    self.signal_stopped = false;

    for set_up in self.pre_emit_funcs:get_iterator() do set_up() end

    for handler in self.handlers:get_iterator() do 
        if(self.signal_stopped) then break end
        if(self.handlers_block[handler] == 0) then
            handler(...)
        end
    end

    for tear_down in self.post_emit_funcs:get_iterator() do tear_down() end
end


---
-- Typical signal emission discards handler return values completely. 
-- This is most often what you need: just inform the world about something. 
-- However, sometimes you need a way to get feedback. For instance, 
-- you may want to ask: “is this value acceptable, eh?”
-- This is what accumulators are for. Accumulators are specified to signals at emission time. 
-- They can combine, alter or discard handler return values, post-process them or even stop emission. 
-- Since a handler can return multiple values, accumulators can receive multiple args too, following 
-- Lua flexible style we give the user the freedom to do whatever he wants with accumulators.
-- @param accumulator – Function that will accumulate handlers results.
-- @param … – A optional list of parameters, they will be repassed to the handler functions connected to this signal.
function Signal:emit_with_accumulator(accumulator, ...)
    self.signal_stopped = false;

    for set_up in self.pre_emit_funcs:get_iterator() do set_up() end

    for handler in self.handlers:get_iterator() do 
        if(self.signal_stopped) then break end
        if(self.handlers_block[handler] == 0) then
            accumulator(handler(...))
        end
    end

    for tear_down in self.post_emit_funcs:get_iterator() do tear_down() end
end


---
-- Adds a pre_emit func, pre_emit functions cant be blocked, only added or removed, 
-- they cannot have their return collected by accumulators, will not receive any data passed 
-- on the emission and they are always called before ANY handler is called. 
-- This is useful when you want to perform some global task before handling an event, 
-- like opening a socket that the handlers might need to use or a database, pre_emit functions 
-- can make sure everything is ok before handling an event, reducing the need to do this check_ups 
-- inside the handler function. They are called on a queue (FIFO) policy based on the order they added.
-- @param pre_emit_func – The pre_emit function.
function Signal:add_pre_emit(pre_emit_func, pre_emit_name)

				local position = self.pre_emit_names:position(pre_emit_name)
    		if position then
					self.pre_emit_funcs:removeIndex(position)
					self.pre_emit_names:remove(pre_emit_name)
				end
    self.pre_emit_names:push_front(pre_emit_name or '')
    self.pre_emit_funcs:push_front(pre_emit_func)
		
end


---
-- Removes the pre_emit function
-- @param pre_emit_func – The pre_emit function.
function Signal:remove_pre_emit(pre_emit_func)
    self.pre_emit_funcs:remove(pre_emit_func)
end


---
-- Adds a post_emit function, post_emit functions cant be blocked, only added or removed, 
-- they cannot have their return collected by accumulators, they will not receive any data 
-- passed on the emission and they are always called after ALL handlers where called. 
-- This is useful when you want to perform some global task after handling an event, 
-- like closing a socket that the handlers might need to use or a database or do some cleanup. 
-- post_emit functions can make sure everything is released after handling an event, 
-- reducing the need to do this check_ups inside some handler function, since some resources 
-- can be shared by multiple handlers. They are called on a stack (LIFO) policy based on the order they added.
-- @param post_emit_func – The post_emit function.
function Signal:add_post_emit(post_emit_func, post_emit_name)
				local position = self.post_emit_names:position(post_emit_name)
    		if position then
					self.post_emit_funcs:removeIndex(position)
					self.post_emit_names:remove(post_emit_name)
				end
    self.post_emit_names:push_front(post_emit_name or '')
    self.post_emit_funcs:push_front(post_emit_func)
end


---
-- Removes the post_emit function
-- @param post_emit_func – The post_emit function.
function Signal:remove_post_emit(post_emit_func)
    self.post_emit_funcs:remove(post_emit_func)
end


---
-- Stops the current emission, if there is any handler left to be called by the signal it wont be called.
function Signal:stop()
    self.signal_stopped = true
end

</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Penlight</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>utils</name>
					<packageName></packageName>
					<script>--- Generally useful routines.
-- See  @{01-introduction.md.Generally_useful_functions|the Guide}.
-- @module pl.utils
local format,gsub,byte = string.format,string.gsub,string.byte
local clock = os.clock
local stdout = io.stdout
local append = table.insert

local collisions = {}

local utils = {}

utils._VERSION = "1.1.0"

local lua51 = rawget(_G,'setfenv')

utils.lua51 = lua51
if not lua51 then -- Lua 5.2 compatibility
    unpack = table.unpack
    loadstring = load
end

utils.dir_separator = _G.package.config:sub(1,1)

--- end this program gracefully.
-- @param code The exit code or a message to be printed
-- @param ... extra arguments for message's format'
-- @see utils.fprintf
function utils.quit(code,...)
    if type(code) == 'string' then
        utils.fprintf(io.stderr,code,...)
        code = -1
    else
        utils.fprintf(io.stderr,...)
    end
    io.stderr:write('\n')
    os.exit(code)
end

--- print an arbitrary number of arguments using a format.
-- @param fmt The format (see string.format)
-- @param ... Extra arguments for format
function utils.printf(fmt,...)
    utils.assert_string(1,fmt)
    utils.fprintf(stdout,fmt,...)
end

--- write an arbitrary number of arguments to a file using a format.
-- @param f File handle to write to.
-- @param fmt The format (see string.format).
-- @param ... Extra arguments for format
function utils.fprintf(f,fmt,...)
    utils.assert_string(2,fmt)
    f:write(format(fmt,...))
end

local function import_symbol(T,k,v,libname)
    local key = rawget(T,k)
    -- warn about collisions!
    if key and k ~= '_M' and k ~= '_NAME' and k ~= '_PACKAGE' and k ~= '_VERSION' then
        utils.printf("warning: '%s.%s' overrides existing symbol\n",libname,k)
    end
    rawset(T,k,v)
end

local function lookup_lib(T,t)
    for k,v in pairs(T) do
        if v == t then return k end
    end
    return '?'
end

local already_imported = {}

--- take a table and 'inject' it into the local namespace.
-- @param t The Table
-- @param T An optional destination table (defaults to callers environment)
function utils.import(t,T)
    T = T or _G
    t = t or utils
    if type(t) == 'string' then
        t = require (t)
    end
    local libname = lookup_lib(T,t)
    if already_imported[t] then return end
    already_imported[t] = libname
    for k,v in pairs(t) do
        import_symbol(T,k,v,libname)
    end
end

utils.patterns = {
    FLOAT = '[%+%-%d]%d*%.?%d*[eE]?[%+%-]?%d*',
    INTEGER = '[+%-%d]%d*',
    IDEN = '[%a_][%w_]*',
    FILE = '[%a%.\\][:%][%w%._%-\\]*'
}

--- escape any 'magic' characters in a string
-- @param s The input string
function utils.escape(s)
    utils.assert_string(1,s)
    return (s:gsub('[%-%.%+%[%]%(%)%$%^%%%?%*]','%%%1'))
end

--- return either of two values, depending on a condition.
-- @param cond A condition
-- @param value1 Value returned if cond is true
-- @param value2 Value returned if cond is false (can be optional)
function utils.choose(cond,value1,value2)
    if cond then return value1
    else return value2
    end
end

local raise

--- return the contents of a file as a string
-- @param filename The file path
-- @param is_bin open in binary mode
-- @return file contents
function utils.readfile(filename,is_bin)
    local mode = is_bin and 'b' or ''
    utils.assert_string(1,filename)
    local f,err = io.open(filename,'r'..mode)
    if not f then return utils.raise (err) end
    local res,err = f:read('*a')
    f:close()
    if not res then return raise (err) end
    return res
end

--- write a string to a file
-- @param filename The file path
-- @param str The string
-- @return true or nil
-- @return error message
-- @raise error if filename or str aren't strings
function utils.writefile(filename,str)
    utils.assert_string(1,filename)
    utils.assert_string(2,str)
    local f,err = io.open(filename,'w')
    if not f then return raise(err) end
    f:write(str)
    f:close()
    return true
end

--- return the contents of a file as a list of lines
-- @param filename The file path
-- @return file contents as a table
-- @raise errror if filename is not a string
function utils.readlines(filename)
    utils.assert_string(1,filename)
    local f,err = io.open(filename,'r')
    if not f then return raise(err) end
    local res = {}
    for line in f:lines() do
        append(res,line)
    end
    f:close()
    return res
end

--- split a string into a list of strings separated by a delimiter.
-- @param s The input string
-- @param re A Lua string pattern; defaults to '%s+'
-- @param plain don't use Lua patterns
-- @param n optional maximum number of splits
-- @return a list-like table
-- @raise error if s is not a string
function utils.split(s,re,plain,n)
    utils.assert_string(1,s)
    local find,sub,append = string.find, string.sub, table.insert
    local i1,ls = 1,{}
    if not re then re = '%s+' end
    if re == '' then return {s} end
    while true do
        local i2,i3 = find(s,re,i1,plain)
        if not i2 then
            local last = sub(s,i1)
            if last ~= '' then append(ls,last) end
            if #ls == 1 and ls[1] == '' then
                return {}
            else
                return ls
            end
        end
        append(ls,sub(s,i1,i2-1))
        if n and #ls == n then
            ls[#ls] = sub(s,i1)
            return ls
        end
        i1 = i3+1
    end
end

--- split a string into a number of values.
-- @param s the string
-- @param re the delimiter, default space
-- @return n values
-- @usage first,next = splitv('jane:doe',':')
-- @see split
function utils.splitv (s,re)
    return unpack(utils.split(s,re))
end

--- convert an array of values to strings.
-- @param t a list-like table
-- @param temp buffer to use, otherwise allocate
-- @param tostr custom tostring function, called with (value,index).
-- Otherwise use `tostring`
-- @return the converted buffer
function utils.array_tostring (t,temp,tostr)
    temp, tostr = temp or {}, tostr or tostring
    for i = 1,#t do
        temp[i] = tostr(t[i],i)
    end
    return temp
end

local lua51_load = load

if utils.lua51 then -- define Lua 5.2 style load()
    function utils.load(str,src,mode,env)
        local chunk,err
        if type(str) == 'string' then
            chunk,err = loadstring(str,src)
        else
            chunk,err = lua51_load(str,src)
        end
        if chunk and env then setfenv(chunk,env) end
        return chunk,err
    end
else
    utils.load = load
    -- setfenv/getfenv replacements for Lua 5.2
    -- by Sergey Rozhenko
    -- http://lua-users.org/lists/lua-l/2010-06/msg00313.html
    -- Roberto Ierusalimschy notes that it is possible for getfenv to return nil
    -- in the case of a function with no globals:
    -- http://lua-users.org/lists/lua-l/2010-06/msg00315.html
    function setfenv(f, t)
        f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
        local name
        local up = 0
        repeat
            up = up + 1
            name = debug.getupvalue(f, up)
        until name == '_ENV' or name == nil
        if name then
            debug.upvaluejoin(f, up, function() return name end, 1) -- use unique upvalue
            debug.setupvalue(f, up, t)
        end
        if f ~= 0 then return f end
    end

    function getfenv(f)
        local f = f or 0
        f = (type(f) == 'function' and f or debug.getinfo(f + 1, 'f').func)
        local name, val
        local up = 0
        repeat
            up = up + 1
            name, val = debug.getupvalue(f, up)
        until name == '_ENV' or name == nil
        return val
    end
end


--- execute a shell command.
-- This is a compatibility function that returns the same for Lua 5.1 and Lua 5.2
-- @param cmd a shell command
-- @return true if successful
-- @return actual return code
function utils.execute (cmd)
    local res1,res2,res2 = os.execute(cmd)
    if lua51 then
        return res1==0,res1
    else
        return res1,res2
    end
end

if lua51 then
    function table.pack (...)
        local n = select('#',...)
        return {n=n; ...}
    end
    local sep = package.config:sub(1,1)
    function package.searchpath (mod,path)
        mod = mod:gsub('%.',sep)
        for m in path:gmatch('[^;]+') do
            local nm = m:gsub('?',mod)
            local f = io.open(nm,'r')
            if f then f:close(); return nm end
        end
    end
end

if not table.pack then table.pack = _G.pack end
if not rawget(_G,"pack") then _G.pack = table.pack end

--- take an arbitrary set of arguments and make into a table.
-- This returns the table and the size; works fine for nil arguments
-- @param ... arguments
-- @return table
-- @return table size
-- @usage local t,n = utils.args(...)

--- 'memoize' a function (cache returned value for next call).
-- This is useful if you have a function which is relatively expensive,
-- but you don't know in advance what values will be required, so
-- building a table upfront is wasteful/impossible.
-- @param func a function of at least one argument
-- @return a function with at least one argument, which is used as the key.
function utils.memoize(func)
    return setmetatable({}, {
        __index = function(self, k, ...)
            local v = func(k,...)
            self[k] = v
            return v
        end,
        __call = function(self, k) return self[k] end
    })
end

--- is the object either a function or a callable object?.
-- @param obj Object to check.
function utils.is_callable (obj)
    return type(obj) == 'function' or getmetatable(obj) and getmetatable(obj).__call
end

--- is the object of the specified type?.
-- If the type is a string, then use type, otherwise compare with metatable
-- @param obj An object to check
-- @param tp String of what type it should be
function utils.is_type (obj,tp)
    if type(tp) == 'string' then return type(obj) == tp end
    local mt = getmetatable(obj)
    return tp == mt
end

local fileMT = getmetatable(io.stdout)

--- a string representation of a type.
-- For tables with metatables, we assume that the metatable has a `_name`
-- field. Knows about Lua file objects.
-- @param obj an object
-- @return a string like 'number', 'table' or 'List'
function utils.type (obj)
    local t = type(obj)
    if t == 'table' or t == 'userdata' then
        local mt = getmetatable(obj)
        if mt == fileMT then
            return 'file'
        else
            return mt._name or "unknown "..t
        end
    else
        return t
    end
end

--- is this number an integer?
-- @param x a number
-- @raise error if x is not a number
function utils.is_integer (x)
    return math.ceil(x)==x
end

utils.stdmt = {
    List = {_name='List'}, Map = {_name='Map'},
    Set = {_name='Set'}, MultiMap = {_name='MultiMap'}
}

local _function_factories = {}

--- associate a function factory with a type.
-- A function factory takes an object of the given type and
-- returns a function for evaluating it
-- @param mt metatable
-- @param fun a callable that returns a function
function utils.add_function_factory (mt,fun)
    _function_factories[mt] = fun
end

local function _string_lambda(f)
    local raise = utils.raise
    if f:find '^|' or f:find '_' then
        local args,body = f:match '|([^|]*)|(.+)'
        if f:find '_' then
            args = '_'
            body = f
        else
            if not args then return raise 'bad string lambda' end
        end
        local fstr = 'return function('..args..') return '..body..' end'
        local fn,err = loadstring(fstr)
        if not fn then return raise(err) end
        fn = fn()
        return fn
    else return raise 'not a string lambda'
    end
end

--- an anonymous function as a string. This string is either of the form
-- '|args| expression' or is a function of one argument, '_'
-- @param lf function as a string
-- @return a function
-- @usage string_lambda '|x|x+1' (2) == 3
-- @usage string_lambda '_+1 (2) == 3
-- @function utils.string_lambda
utils.string_lambda = utils.memoize(_string_lambda)

local ops

--- process a function argument.
-- This is used throughout Penlight and defines what is meant by a function:
-- Something that is callable, or an operator string as defined by &lt;code&gt;pl.operator&lt;/code&gt;,
-- such as '&gt;' or '#'. If a function factory has been registered for the type, it will
-- be called to get the function.
-- @param idx argument index
-- @param f a function, operator string, or callable object
-- @param msg optional error message
-- @return a callable
-- @raise if idx is not a number or if f is not callable
-- @see utils.is_callable
function utils.function_arg (idx,f,msg)
    utils.assert_arg(1,idx,'number')
    local tp = type(f)
    if tp == 'function' then return f end  -- no worries!
    -- ok, a string can correspond to an operator (like '==')
    if tp == 'string' then
        if not ops then ops = require 'pl.operator'.optable end
        local fn = ops[f]
        if fn then return fn end
        local fn, err = utils.string_lambda(f)
        if not fn then error(err..': '..f) end
        return fn
    elseif tp == 'table' or tp == 'userdata' then
        local mt = getmetatable(f)
        if not mt then error('not a callable object',2) end
        local ff = _function_factories[mt]
        if not ff then
            if not mt.__call then error('not a callable object',2) end
            return f
        else
            return ff(f) -- we have a function factory for this type!
        end
    end
    if not msg then msg = " must be callable" end
    if idx &gt; 0 then
        error("argument "..idx..": "..msg,2)
    else
        error(msg,2)
    end
end

--- bind the first argument of the function to a value.
-- @param fn a function of at least two values (may be an operator string)
-- @param p a value
-- @return a function such that f(x) is fn(p,x)
-- @raise same as @{function_arg}
-- @see pl.func.curry
function utils.bind1 (fn,p)
    fn = utils.function_arg(1,fn)
    return function(...) return fn(p,...) end
end

--- bind the second argument of the function to a value.
-- @param fn a function of at least two values (may be an operator string)
-- @param p a value
-- @return a function such that f(x) is fn(x,p)
-- @raise same as @{function_arg}
function utils.bind2 (fn,p)
    fn = utils.function_arg(1,fn)
    return function(x,...) return fn(x,p,...) end
end


--- assert that the given argument is in fact of the correct type.
-- @param n argument index
-- @param val the value
-- @param tp the type
-- @param verify an optional verfication function
-- @param msg an optional custom message
-- @param lev optional stack position for trace, default 2
-- @raise if the argument n is not the correct type
-- @usage assert_arg(1,t,'table')
-- @usage assert_arg(n,val,'string',path.isdir,'not a directory')
function utils.assert_arg (n,val,tp,verify,msg,lev)
    if type(val) ~= tp then
        error(("argument %d expected a '%s', got a '%s'"):format(n,tp,type(val)),lev or 2)
    end
    if verify and not verify(val) then
        error(("argument %d: '%s' %s"):format(n,val,msg),lev or 2)
    end
end

--- assert the common case that the argument is a string.
-- @param n argument index
-- @param val a value that must be a string
-- @raise val must be a string
function utils.assert_string (n,val)
    utils.assert_arg(n,val,'string',nil,nil,3)
end

local err_mode = 'default'

--- control the error strategy used by Penlight.
-- Controls how &lt;code&gt;utils.raise&lt;/code&gt; works; the default is for it
-- to return nil and the error string, but if the mode is 'error' then
-- it will throw an error. If mode is 'quit' it will immediately terminate
-- the program.
-- @param mode - either 'default', 'quit'  or 'error'
-- @see utils.raise
function utils.on_error (mode)
    if ({['default'] = 1, ['quit'] = 2, ['error'] = 3})[mode] then
      err_mode = mode
    else
      -- fail loudly
      if err_mode == 'default' then err_mode = 'error' end
      utils.raise("Bad argument expected string; 'default', 'quit', or 'error'. Got '"..tostring(mode).."'")
    end
end

--- used by Penlight functions to return errors.  Its global behaviour is controlled
-- by &lt;code&gt;utils.on_error&lt;/code&gt;
-- @param err the error string.
-- @see utils.on_error
function utils.raise (err)
    if err_mode == 'default' then return nil,err
    elseif err_mode == 'quit' then utils.quit(err)
    else error(err,2)
    end
end

raise = utils.raise

--- load a code string or bytecode chunk.
-- @param code Lua code as a string or bytecode
-- @param name for source errors
-- @param mode kind of chunk, 't' for text, 'b' for bytecode, 'bt' for all (default)
-- @param env  the environment for the new chunk (default nil)
-- @return compiled chunk
-- @return error message (chunk is nil)
-- @function utils.load


--- Lua 5.2 Compatible Functions
-- @section lua52

--- pack an argument list into a table.
-- @param ... any arguments
-- @return a table with field n set to the length
-- @return the length
-- @function table.pack

------
-- return the full path where a Lua module name would be matched.
-- @param mod module name, possibly dotted
-- @param path a path in the same form as package.path or package.cpath
-- @see path.package_path
-- @function package.searchpath

package.loaded['pl.utils'] = utils


</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>tablex</name>
					<packageName></packageName>
					<script>--- Extended operations on Lua tables.
--
-- See @{02-arrays.md.Useful_Operations_on_Tables|the Guide}
--
-- Dependencies: `pl.utils`
-- @module pl.tablex
local utils = require ('pl.utils')
local getmetatable,setmetatable,require = getmetatable,setmetatable,require
local append,remove = table.insert,table.remove
local min,max = math.min,math.max
local pairs,type,unpack,next,select,tostring = pairs,type,unpack,next,select,tostring
local function_arg = utils.function_arg
local Set = utils.stdmt.Set
local List = utils.stdmt.List
local Map = utils.stdmt.Map
local assert_arg = utils.assert_arg

local tablex = {}

-- generally, functions that make copies of tables try to preserve the metatable.
-- However, when the source has no obvious type, then we attach appropriate metatables
-- like List, Map, etc to the result.
local function setmeta (res,tbl,def)
    local mt = getmetatable(tbl) or def
    return setmetatable(res, mt)
end

local function makelist (res)
    return setmetatable(res,List)
end

local function check_meta (val)
    if type(val) == 'table' then return true end
    return getmetatable(val)
end

local function complain (idx,msg)
    error(('argument %d is not %s'):format(idx,msg),3)
end

local function assert_arg_indexable (idx,val)
    local mt = check_meta(val)
    if mt == true then return end
    if not(mt and mt.__len and mt.__index) then
        complain(idx,"indexable")
    end
end

local function assert_arg_iterable (idx,val)
    local mt = check_meta(val)
    if mt == true then return end
    if not(mt and mt.__pairs) then
        complain(idx,"iterable")
    end
end

local function assert_arg_writeable (idx,val)
    local mt = check_meta(val)
    if mt == true then return end
    if not(mt and mt.__newindex) then
        complain(idx,"writeable")
    end
end


--- copy a table into another, in-place.
-- @param t1 destination table
-- @param t2 source (any iterable object)
-- @return first table
function tablex.update (t1,t2)
    assert_arg_writeable(1,t1)
    assert_arg_iterable(2,t2)
    for k,v in pairs(t2) do
        t1[k] = v
    end
    return t1
end

--- total number of elements in this table.
-- Note that this is distinct from `#t`, which is the number
-- of values in the array part; this value will always
-- be greater or equal. The difference gives the size of
-- the hash part, for practical purposes. Works for any
-- object with a __pairs metamethod.
-- @param t a table
-- @return the size
function tablex.size (t)
    assert_arg_iterable(1,t)
    local i = 0
    for k in pairs(t) do i = i + 1 end
    return i
end

--- make a shallow copy of a table
-- @param t an iterable source
-- @return new table
function tablex.copy (t)
    assert_arg_iterable(1,t)
    local res = {}
    for k,v in pairs(t) do
        res[k] = v
    end
    return res
end

--- make a deep copy of a table, recursively copying all the keys and fields.
-- This will also set the copied table's metatable to that of the original.
--  @param t A table
-- @return new table
function tablex.deepcopy(t)
    if type(t) ~= 'table' then return t end
    assert_arg_iterable(1,t)
    local mt = getmetatable(t)
    local res = {}
    for k,v in pairs(t) do
        if type(v) == 'table' then
            v = tablex.deepcopy(v)
        end
        res[k] = v
    end
    setmetatable(res,mt)
    return res
end

local abs, deepcompare = math.abs

--- compare two values.
-- if they are tables, then compare their keys and fields recursively.
-- @param t1 A value
-- @param t2 A value
-- @param ignore_mt if true, ignore __eq metamethod (default false)
-- @param eps if defined, then used for any number comparisons
-- @return true or false
function tablex.deepcompare(t1,t2,ignore_mt,eps)
    local ty1 = type(t1)
    local ty2 = type(t2)
    if ty1 ~= ty2 then return false end
    -- non-table types can be directly compared
    if ty1 ~= 'table' then
        if ty1 == 'number' and eps then return abs(t1-t2) &lt; eps end
        return t1 == t2
    end
    -- as well as tables which have the metamethod __eq
    local mt = getmetatable(t1)
    if not ignore_mt and mt and mt.__eq then return t1 == t2 end
    for k1 in pairs(t1) do
        if t2[k1]==nil then return false end
    end
    for k2 in pairs(t2) do
        if t1[k2]==nil then return false end
    end
    for k1,v1 in pairs(t1) do
        local v2 = t2[k1]
        if not deepcompare(v1,v2,ignore_mt,eps) then return false end
    end

    return true
end

deepcompare = tablex.deepcompare

--- compare two arrays using a predicate.
-- @param t1 an array
-- @param t2 an array
-- @param cmp A comparison function
function tablex.compare (t1,t2,cmp)
    assert_arg_indexable(1,t1)
    assert_arg_indexable(2,t2)
    if #t1 ~= #t2 then return false end
    cmp = function_arg(3,cmp)
    for k = 1,#t1 do
        if not cmp(t1[k],t2[k]) then return false end
    end
    return true
end

--- compare two list-like tables using an optional predicate, without regard for element order.
-- @param t1 a list-like table
-- @param t2 a list-like table
-- @param cmp A comparison function (may be nil)
function tablex.compare_no_order (t1,t2,cmp)
    assert_arg_indexable(1,t1)
    assert_arg_indexable(2,t2)
    if cmp then cmp = function_arg(3,cmp) end
    if #t1 ~= #t2 then return false end
    local visited = {}
    for i = 1,#t1 do
        local val = t1[i]
        local gotcha
        for j = 1,#t2 do if not visited[j] then
            local match
            if cmp then match = cmp(val,t2[j]) else match = val == t2[j] end
            if match then
                gotcha = j
                break
            end
        end end
        if not gotcha then return false end
        visited[gotcha] = true
    end
    return true
end


--- return the index of a value in a list.
-- Like string.find, there is an optional index to start searching,
-- which can be negative.
-- @param t A list-like table (i.e. with numerical indices)
-- @param val A value
-- @param idx index to start; -1 means last element,etc (default 1)
-- @return index of value or nil if not found
-- @usage find({10,20,30},20) == 2
-- @usage find({'a','b','a','c'},'a',2) == 3
function tablex.find(t,val,idx)
    assert_arg_indexable(1,t)
    idx = idx or 1
    if idx &lt; 0 then idx = #t + idx + 1 end
    for i = idx,#t do
        if t[i] == val then return i end
    end
    return nil
end

--- return the index of a value in a list, searching from the end.
-- Like string.find, there is an optional index to start searching,
-- which can be negative.
-- @param t A list-like table (i.e. with numerical indices)
-- @param val A value
-- @param idx index to start; -1 means last element,etc (default 1)
-- @return index of value or nil if not found
-- @usage rfind({10,10,10},10) == 3
function tablex.rfind(t,val,idx)
    assert_arg_indexable(1,t)
    idx = idx or #t
    if idx &lt; 0 then idx = #t + idx + 1 end
    for i = idx,1,-1 do
        if t[i] == val then return i end
    end
    return nil
end


--- return the index (or key) of a value in a table using a comparison function.
-- @param t A table
-- @param cmp A comparison function
-- @param arg an optional second argument to the function
-- @return index of value, or nil if not found
-- @return value returned by comparison function
function tablex.find_if(t,cmp,arg)
    assert_arg_iterable(1,t)
    cmp = function_arg(2,cmp)
    for k,v in pairs(t) do
        local c = cmp(v,arg)
        if c then return k,c end
    end
    return nil
end

--- return a list of all values in a table indexed by another list.
-- @param tbl a table
-- @param idx an index table (a list of keys)
-- @return a list-like table
-- @usage index_by({10,20,30,40},{2,4}) == {20,40}
-- @usage index_by({one=1,two=2,three=3},{'one','three'}) == {1,3}
function tablex.index_by(tbl,idx)
    assert_arg_indexable(1,tbl)
    assert_arg_indexable(2,idx)
    local res = {}
    for i = 1,#idx do
        res[i] = tbl[idx[i]]
    end
    return setmeta(res,tbl,List)
end

--- apply a function to all values of a table.
-- This returns a table of the results.
-- Any extra arguments are passed to the function.
-- @param fun A function that takes at least one argument
-- @param t A table
-- @param ... optional arguments
-- @usage map(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900,fred=4}
function tablex.map(fun,t,...)
    assert_arg_iterable(1,t)
    fun = function_arg(1,fun)
    local res = {}
    for k,v in pairs(t) do
        res[k] = fun(v,...)
    end
    return setmeta(res,t)
end

--- apply a function to all values of a list.
-- This returns a table of the results.
-- Any extra arguments are passed to the function.
-- @param fun A function that takes at least one argument
-- @param t a table (applies to array part)
-- @param ... optional arguments
-- @return a list-like table
-- @usage imap(function(v) return v*v end, {10,20,30,fred=2}) is {100,400,900}
function tablex.imap(fun,t,...)
    assert_arg_indexable(1,t)
    fun = function_arg(1,fun)
    local res = {}
    for i = 1,#t do
        res[i] = fun(t[i],...) or false
    end
    return setmeta(res,t,List)
end

--- apply a named method to values from a table.
-- @param name the method name
-- @param t a list-like table
-- @param ... any extra arguments to the method
function tablex.map_named_method (name,t,...)
    utils.assert_string(1,name)
    assert_arg_indexable(2,t)
    local res = {}
    for i = 1,#t do
        local val = t[i]
        local fun = val[name]
        res[i] = fun(val,...)
    end
    return setmeta(res,t,List)
end


--- apply a function to all values of a table, in-place.
-- Any extra arguments are passed to the function.
-- @param fun A function that takes at least one argument
-- @param t a table
-- @param ... extra arguments
function tablex.transform (fun,t,...)
    assert_arg_iterable(1,t)
    fun = function_arg(1,fun)
    for k,v in pairs(t) do
        t[v] = fun(v,...)
    end
end

--- generate a table of all numbers in a range
-- @param start  number
-- @param finish number
-- @param step optional increment (default 1 for increasing, -1 for decreasing)
function tablex.range (start,finish,step)
    if start == finish then return {start}
    elseif start &gt; finish then return {}
    end
    local res = {}
    local k = 1
    if not step then
        if finish &gt; start then step = finish &gt; start and 1 or -1 end
    end
    for i=start,finish,step do res[k]=i; k=k+1 end
    return res
end

--- apply a function to values from two tables.
-- @param fun a function of at least two arguments
-- @param t1 a table
-- @param t2 a table
-- @param ... extra arguments
-- @return a table
-- @usage map2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23,m=44}
function tablex.map2 (fun,t1,t2,...)
    assert_arg_iterable(1,t1)
    assert_arg_iterable(2,t2)
    fun = function_arg(1,fun)
    local res = {}
    for k,v in pairs(t1) do
        res[k] = fun(v,t2[k],...)
    end
    return setmeta(res,t1,List)
end

--- apply a function to values from two arrays.
-- The result will be the length of the shortest array.
-- @param fun a function of at least two arguments
-- @param t1 a list-like table
-- @param t2 a list-like table
-- @param ... extra arguments
-- @usage imap2('+',{1,2,3,m=4},{10,20,30,m=40}) is {11,22,23}
function tablex.imap2 (fun,t1,t2,...)
    assert_arg_indexable(2,t1)
    assert_arg_indexable(3,t2)
    fun = function_arg(1,fun)
    local res,n = {},math.min(#t1,#t2)
    for i = 1,n do
        res[i] = fun(t1[i],t2[i],...)
    end
    return res
end

--- 'reduce' a list using a binary function.
-- @param fun a function of two arguments
-- @param t a list-like table
-- @return the result of the function
-- @usage reduce('+',{1,2,3,4}) == 10
function tablex.reduce (fun,t)
    assert_arg_indexable(2,t)
    fun = function_arg(1,fun)
    local n = #t
    local res = t[1]
    for i = 2,n do
        res = fun(res,t[i])
    end
    return res
end

--- apply a function to all elements of a table.
-- The arguments to the function will be the value,
-- the key and &lt;i&gt;finally&lt;/i&gt; any extra arguments passed to this function.
-- Note that the Lua 5.0 function table.foreach passed the &lt;i&gt;key&lt;/i&gt; first.
-- @param t a table
-- @param fun a function with at least one argument
-- @param ... extra arguments
function tablex.foreach(t,fun,...)
    assert_arg_iterable(1,t)
    fun = function_arg(2,fun)
    for k,v in pairs(t) do
        fun(v,k,...)
    end
end

--- apply a function to all elements of a list-like table in order.
-- The arguments to the function will be the value,
-- the index and &lt;i&gt;finally&lt;/i&gt; any extra arguments passed to this function
-- @param t a table
-- @param fun a function with at least one argument
-- @param ... optional arguments
function tablex.foreachi(t,fun,...)
    assert_arg_indexable(1,t)
    fun = function_arg(2,fun)
    for i = 1,#t do
        fun(t[i],i,...)
    end
end


--- Apply a function to a number of tables.
-- A more general version of map
-- The result is a table containing the result of applying that function to the
-- ith value of each table. Length of output list is the minimum length of all the lists
-- @param fun a function of n arguments
-- @param ... n tables
-- @usage mapn(function(x,y,z) return x+y+z end, {1,2,3},{10,20,30},{100,200,300}) is {111,222,333}
-- @usage mapn(math.max, {1,20,300},{10,2,3},{100,200,100}) is	{100,200,300}
-- @param fun A function that takes as many arguments as there are tables
function tablex.mapn(fun,...)
    fun = function_arg(1,fun)
    local res = {}
    local lists = {...}
    local minn = 1e40
    for i = 1,#lists do
        minn = min(minn,#(lists[i]))
    end
    for i = 1,minn do
        local args,k = {},1
        for j = 1,#lists do
            args[k] = lists[j][i]
            k = k + 1
        end
        res[#res+1] = fun(unpack(args))
    end
    return res
end

--- call the function with the key and value pairs from a table.
-- The function can return a value and a key (note the order!). If both
-- are not nil, then this pair is inserted into the result. If only value is not nil, then
-- it is appended to the result.
-- @param fun A function which will be passed each key and value as arguments, plus any extra arguments to pairmap.
-- @param t A table
-- @param ... optional arguments
-- @usage pairmap(function(k,v) return v end,{fred=10,bonzo=20}) is {10,20} _or_ {20,10}
-- @usage pairmap(function(k,v) return {k,v},k end,{one=1,two=2}) is {one={'one',1},two={'two',2}}
function tablex.pairmap(fun,t,...)
    assert_arg_iterable(1,t)
    fun = function_arg(1,fun)
    local res = {}
    for k,v in pairs(t) do
        local rv,rk = fun(k,v,...)
        if rk then
            res[rk] = rv
        else
            res[#res+1] = rv
        end
    end
    return res
end

local function keys_op(i,v) return i end

--- return all the keys of a table in arbitrary order.
--  @param t A table
function tablex.keys(t)
    assert_arg_iterable(1,t)
    return makelist(tablex.pairmap(keys_op,t))
end

local function values_op(i,v) return v end

--- return all the values of the table in arbitrary order
--  @param t A table
function tablex.values(t)
    assert_arg_iterable(1,t)
    return makelist(tablex.pairmap(values_op,t))
end

local function index_map_op (i,v) return i,v end

--- create an index map from a list-like table. The original values become keys,
-- and the associated values are the indices into the original list.
-- @param t a list-like table
-- @return a map-like table
function tablex.index_map (t)
    assert_arg_indexable(1,t)
    return setmetatable(tablex.pairmap(index_map_op,t),Map)
end

local function set_op(i,v) return true,v end

--- create a set from a list-like table. A set is a table where the original values
-- become keys, and the associated values are all true.
-- @param t a list-like table
-- @return a set (a map-like table)
function tablex.makeset (t)
    assert_arg_indexable(1,t)
    return setmetatable(tablex.pairmap(set_op,t),Set)
end


--- combine two tables, either as union or intersection. Corresponds to
-- set operations for sets () but more general. Not particularly
-- useful for list-like tables.
-- @param t1 a table
-- @param t2 a table
-- @param dup true for a union, false for an intersection.
-- @usage merge({alice=23,fred=34},{bob=25,fred=34}) is {fred=34}
-- @usage merge({alice=23,fred=34},{bob=25,fred=34},true) is {bob=25,fred=34,alice=23}
-- @see tablex.index_map
function tablex.merge (t1,t2,dup)
    assert_arg_iterable(1,t1)
    assert_arg_iterable(2,t2)
    local res = {}
    for k,v in pairs(t1) do
        if dup or t2[k] then res[k] = v end
    end
    if dup then
      for k,v in pairs(t2) do
        res[k] = v
      end
    end
    return setmeta(res,t1,Map)
end

--- a new table which is the difference of two tables.
-- With sets (where the values are all true) this is set difference and
-- symmetric difference depending on the third parameter.
-- @param s1 a map-like table or set
-- @param s2 a map-like table or set
-- @param symm symmetric difference (default false)
-- @return a map-like table or set
function tablex.difference (s1,s2,symm)
    assert_arg_iterable(1,s1)
    assert_arg_iterable(2,s2)
    local res = {}
    for k,v in pairs(s1) do
        if not s2[k] then res[k] = v end
    end
    if symm then
        for k,v in pairs(s2) do
            if not s1[k] then res[k] = v end
        end
    end
    return setmeta(res,s1,Map)
end

--- A table where the key/values are the values and value counts of the table.
-- @param t a list-like table
-- @param cmp a function that defines equality (otherwise uses ==)
-- @return a map-like table
-- @see seq.count_map
function tablex.count_map (t,cmp)
    assert_arg_indexable(1,t)
    local res,mask = {},{}
    cmp = function_arg(2,cmp)
    local n = #t
    for i = 1,#t do
        local v = t[i]
        if not mask[v] then
            mask[v] = true
            -- check this value against all other values
            res[v] = 1  -- there's at least one instance
            for j = i+1,n do
                local w = t[j]
                if cmp and cmp(v,w) or v == w then
                    res[v] = res[v] + 1
                    mask[w] = true
                end
            end
        end
    end
    return setmetatable(res,Map)
end

--- filter a table's values using a predicate function
-- @param t a list-like table
-- @param pred a boolean function
-- @param arg optional argument to be passed as second argument of the predicate
function tablex.filter (t,pred,arg)
    assert_arg_indexable(1,t)
    pred = function_arg(2,pred)
    local res,k = {},1
    for i = 1,#t do
        local v = t[i]
        if pred(v,arg) then
            res[k] = v
            k = k + 1
        end
    end
    return setmeta(res,t,List)
end

--- return a table where each element is a table of the ith values of an arbitrary
-- number of tables. It is equivalent to a matrix transpose.
-- @usage zip({10,20,30},{100,200,300}) is {{10,100},{20,200},{30,300}}
function tablex.zip(...)
    return tablex.mapn(function(...) return {...} end,...)
end

local _copy
function _copy (dest,src,idest,isrc,nsrc,clean_tail)
    idest = idest or 1
    isrc = isrc or 1
    local iend
    if not nsrc then
        nsrc = #src
        iend = #src
    else
        iend = isrc + min(nsrc-1,#src-isrc)
    end
    if dest == src then -- special case
        if idest &gt; isrc and iend &gt;= idest then -- overlapping ranges
            src = tablex.sub(src,isrc,nsrc)
            isrc = 1; iend = #src
        end
    end
    for i = isrc,iend do
        dest[idest] = src[i]
        idest = idest + 1
    end
    if clean_tail then
        tablex.clear(dest,idest)
    end
    return dest
end

--- copy an array into another one, resizing the destination if necessary. &lt;br&gt;
-- @param dest a list-like table
-- @param src a list-like table
-- @param idest where to start copying values from source (default 1)
-- @param isrc where to start copying values into destination (default 1)
-- @param nsrc number of elements to copy from source (default source size)
function tablex.icopy (dest,src,idest,isrc,nsrc)
    assert_arg_indexable(1,dest)
    assert_arg_indexable(2,src)
    return _copy(dest,src,idest,isrc,nsrc,true)
end

--- copy an array into another one. &lt;br&gt;
-- @param dest a list-like table
-- @param src a list-like table
-- @param idest where to start copying values from source (default 1)
-- @param isrc where to start copying values into destination (default 1)
-- @param nsrc number of elements to copy from source (default source size)
function tablex.move (dest,src,idest,isrc,nsrc)
    assert_arg_indexable(1,dest)
    assert_arg_indexable(2,src)
    return _copy(dest,src,idest,isrc,nsrc,false)
end

function tablex._normalize_slice(self,first,last)
  local sz = #self
  if not first then first=1 end
  if first&lt;0 then first=sz+first+1 end
  -- make the range _inclusive_!
  if not last then last=sz end
  if last &lt; 0 then last=sz+1+last end
  return first,last
end

--- Extract a range from a table, like  'string.sub'.
-- If first or last are negative then they are relative to the end of the list
-- eg. sub(t,-2) gives last 2 entries in a list, and
-- sub(t,-4,-2) gives from -4th to -2nd
-- @param t a list-like table
-- @param first An index
-- @param last An index
-- @return a new List
function tablex.sub(t,first,last)
    assert_arg_indexable(1,t)
    first,last = tablex._normalize_slice(t,first,last)
    local res={}
    for i=first,last do append(res,t[i]) end
    return setmeta(res,t,List)
end

--- set an array range to a value. If it's a function we use the result
-- of applying it to the indices.
-- @param t a list-like table
-- @param val a value
-- @param i1 start range (default 1)
-- @param i2 end range (default table size)
function tablex.set (t,val,i1,i2)
    assert_arg_indexable(1,t)
    i1,i2 = i1 or 1,i2 or #t
    if utils.is_callable(val) then
        for i = i1,i2 do
            t[i] = val(i)
        end
    else
        for i = i1,i2 do
            t[i] = val
        end
    end
end

--- create a new array of specified size with initial value.
-- @param n size
-- @param val initial value (can be nil, but don't expect # to work!)
-- @return the table
function tablex.new (n,val)
    local res = {}
    tablex.set(res,val,1,n)
    return res
end

--- clear out the contents of a table.
-- @param t a table
-- @param istart optional start position
function tablex.clear(t,istart)
    istart = istart or 1
    for i = istart,#t do remove(t) end
end

--- insert values into a table. &lt;br&gt;
-- insertvalues(t, [pos,] values) &lt;br&gt;
-- similar to table.insert but inserts values from given table "values",
-- not the object itself, into table "t" at position "pos".
function tablex.insertvalues(t, ...)
    assert_arg(1,t,'table')
    local pos, values
    if select('#', ...) == 1 then
        pos,values = #t+1, ...
    else
        pos,values = ...
    end
    if #values &gt; 0 then
        for i=#t,pos,-1 do
            t[i+#values] = t[i]
        end
        local offset = 1 - pos
        for i=pos,pos+#values-1 do
            t[i] = values[i + offset]
        end
    end
    return t
end

--- remove a range of values from a table.
-- @param t a list-like table
-- @param i1 start index
-- @param i2 end index
-- @return the table
function tablex.removevalues (t,i1,i2)
    assert_arg(1,t,'table')
    i1,i2 = tablex._normalize_slice(t,i1,i2)
    for i = i1,i2 do
        remove(t,i1)
    end
    return t
end

local _find
_find = function (t,value,tables)
    for k,v in pairs(t) do
        if v == value then return k end
    end
    for k,v in pairs(t) do
        if not tables[v] and type(v) == 'table' then
            tables[v] = true
            local res = _find(v,value,tables)
            if res then
                res = tostring(res)
                if type(k) ~= 'string' then
                    return '['..k..']'..res
                else
                    return k..'.'..res
                end
            end
        end
    end
end

--- find a value in a table by recursive search.
-- @param t the table
-- @param value the value
-- @param exclude any tables to avoid searching
-- @usage search(_G,math.sin,{package.path}) == 'math.sin'
-- @return a fieldspec, e.g. 'a.b' or 'math.sin'
function tablex.search (t,value,exclude)
    assert_arg_iterable(1,t)
    local tables = {[t]=true}
    if exclude then
        for _,v in pairs(exclude) do tables[v] = true end
    end
    return _find(t,value,tables)
end

package.loaded['pl.tablex'] = tablex
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>stringx</name>
					<packageName></packageName>
					<script>--- Python-style extended string library.
--
-- see 3.6.1 of the Python reference.
-- If you want to make these available as string methods, then say
-- `stringx.import()` to bring them into the standard `string` table.
--
-- See @{03-strings.md|the Guide}
--
-- Dependencies: `pl.utils`
-- @module pl.stringx
local utils = require 'pl.utils'
local string = string
local find = string.find
local type,setmetatable,getmetatable,ipairs,unpack = type,setmetatable,getmetatable,ipairs,unpack
local error,tostring = error,tostring
local gsub = string.gsub
local rep = string.rep
local sub = string.sub
local concat = table.concat
local escape = utils.escape
local ceil = math.ceil
local _G = _G
local assert_arg,usplit,list_MT = utils.assert_arg,utils.split,utils.stdmt.List
local lstrip

local function assert_string (n,s)
    assert_arg(n,s,'string')
end

local function non_empty(s)
    return #s &gt; 0
end

local function assert_nonempty_string(n,s)
    assert_arg(n,s,'string',non_empty,'must be a non-empty string')
end

local stringx = {}

--- does s only contain alphabetic characters?.
-- @param s a string
function stringx.isalpha(s)
    assert_string(1,s)
    return find(s,'^%a+$') == 1
end

--- does s only contain digits?.
-- @param s a string
function stringx.isdigit(s)
    assert_string(1,s)
    return find(s,'^%d+$') == 1
end

--- does s only contain alphanumeric characters?.
-- @param s a string
function stringx.isalnum(s)
    assert_string(1,s)
    return find(s,'^%w+$') == 1
end

--- does s only contain spaces?.
-- @param s a string
function stringx.isspace(s)
    assert_string(1,s)
    return find(s,'^%s+$') == 1
end

--- does s only contain lower case characters?.
-- @param s a string
function stringx.islower(s)
    assert_string(1,s)
    return find(s,'^[%l%s]+$') == 1
end

--- does s only contain upper case characters?.
-- @param s a string
function stringx.isupper(s)
    assert_string(1,s)
    return find(s,'^[%u%s]+$') == 1
end

--- concatenate the strings using this string as a delimiter.
-- @param self the string
-- @param seq a table of strings or numbers
-- @usage (' '):join {1,2,3} == '1 2 3'
function stringx.join (self,seq)
    assert_string(1,self)
    return concat(seq,self)
end

--- does string start with the substring?.
-- @param self the string
-- @param s2 a string
function stringx.startswith(self,s2)
    assert_string(1,self)
    assert_string(2,s2)
    return find(self,s2,1,true) == 1
end

local function _find_all(s,sub,first,last)
    if sub == '' then return #s+1,#s end
    local i1,i2 = find(s,sub,first,true)
    local res
    local k = 0
    while i1 do
        res = i1
        k = k + 1
        i1,i2 = find(s,sub,i2+1,true)
        if last and i1 &gt; last then break end
    end
    return res,k
end

--- does string end with the given substring?.
-- @param s a string
-- @param send a substring or a table of suffixes
function stringx.endswith(s,send)
    assert_string(1,s)
    if type(send) == 'string' then
        return #s &gt;= #send and s:find(send, #s-#send+1, true) and true or false
    elseif type(send) == 'table' then
        local endswith = stringx.endswith
        for _,suffix in ipairs(send) do
            if endswith(s,suffix) then return true end
        end
        return false
    else
        error('argument #2: either a substring or a table of suffixes expected')
    end
end

-- break string into a list of lines
-- @param self the string
-- @param keepends (currently not used)
function stringx.splitlines (self,keepends)
    assert_string(1,self)
    local res = usplit(self,'[\r\n]')
    -- we are currently hacking around a problem with utils.split (see stringx.split)
    if #res == 0 then res = {''} end
    return setmetatable(res,list_MT)
end

local function tab_expand (self,n)
    return (gsub(self,'([^\t]*)\t', function(s)
            return s..(' '):rep(n - #s % n)
    end))
end

--- replace all tabs in s with n spaces. If not specified, n defaults to 8.
-- with 0.9.5 this now correctly expands to the next tab stop (if you really
-- want to just replace tabs, use :gsub('\t','  ') etc)
-- @param self the string
-- @param n number of spaces to expand each tab, (default 8)
function stringx.expandtabs(self,n)
    assert_string(1,self)
    n = n or 8
    if not self:find '\n' then return tab_expand(self,n) end
    local res,i = {},1
    for line in stringx.lines(self) do
        res[i] = tab_expand(line,n)
        i = i + 1
    end
    return table.concat(res,'\n')
end

--- find index of first instance of sub in s from the left.
-- @param self the string
-- @param sub substring
-- @param  i1 start index
function stringx.lfind(self,sub,i1)
    assert_string(1,self)
    assert_string(2,sub)
    local idx = find(self,sub,i1,true)
    if idx then return idx else return nil end
end

--- find index of first instance of sub in s from the right.
-- @param self the string
-- @param sub substring
-- @param first first index
-- @param last last index
function stringx.rfind(self,sub,first,last)
    assert_string(1,self)
    assert_string(2,sub)
    local idx = _find_all(self,sub,first,last)
    if idx then return idx else return nil end
end

--- replace up to n instances of old by new in the string s.
-- if n is not present, replace all instances.
-- @param s the string
-- @param old the target substring
-- @param new the substitution
-- @param n optional maximum number of substitutions
-- @return result string
-- @return the number of substitutions
function stringx.replace(s,old,new,n)
    assert_string(1,s)
    assert_string(1,old)
    return (gsub(s,escape(old),new:gsub('%%','%%%%'),n))
end

--- split a string into a list of strings using a delimiter.
-- @class function
-- @name split
-- @param self the string
-- @param re a delimiter (defaults to whitespace)
-- @param n maximum number of results
-- @usage #(('one two'):split()) == 2
-- @usage ('one,two,three'):split(',') == List{'one','two','three'}
-- @usage ('one,two,three'):split(',',2) == List{'one','two,three'}
function stringx.split(self,re,n)
    local s = self
    local plain = true
    if not re then -- default spaces
        s = lstrip(s)
        plain = false
    end
    local res = usplit(s,re,plain,n)
    if re and re ~= '' and find(s,re,-#re,true) then
        res[#res+1] = ""
    end
	return setmetatable(res,list_MT)
end

--- split a string using a pattern. Note that at least one value will be returned!
-- @param self the string
-- @param re a Lua string pattern (defaults to whitespace)
-- @return the parts of the string
-- @usage  a,b = line:splitv('=')
function stringx.splitv (self,re)
    assert_string(1,self)
    return utils.splitv(self,re)
end

local function copy(self)
    return self..''
end

--- count all instances of substring in string.
-- @param self the string
-- @param sub substring
function stringx.count(self,sub)
    assert_string(1,self)
    local i,k = _find_all(self,sub,1)
    return k
end

local function _just(s,w,ch,left,right)
    local n = #s
    if w &gt; n then
        if not ch then ch = ' ' end
        local f1,f2
        if left and right then
            local ln = ceil((w-n)/2)
            local rn = w - n - ln
            f1 = rep(ch,ln)
            f2 = rep(ch,rn)
        elseif right then
            f1 = rep(ch,w-n)
            f2 = ''
        else
            f2 = rep(ch,w-n)
            f1 = ''
        end
        return f1..s..f2
    else
        return copy(s)
    end
end

--- left-justify s with width w.
-- @param self the string
-- @param w width of justification
-- @param ch padding character, default ' '
function stringx.ljust(self,w,ch)
    assert_string(1,self)
    assert_arg(2,w,'number')
    return _just(self,w,ch,true,false)
end

--- right-justify s with width w.
-- @param s the string
-- @param w width of justification
-- @param ch padding character, default ' '
function stringx.rjust(s,w,ch)
    assert_string(1,s)
    assert_arg(2,w,'number')
    return _just(s,w,ch,false,true)
end

--- center-justify s with width w.
-- @param s the string
-- @param w width of justification
-- @param ch padding character, default ' '
function stringx.center(s,w,ch)
    assert_string(1,s)
    assert_arg(2,w,'number')
    return _just(s,w,ch,true,true)
end

local function _strip(s,left,right,chrs)
    if not chrs then
        chrs = '%s'
    else
        chrs = '['..escape(chrs)..']'
    end
    if left then
        local i1,i2 = find(s,'^'..chrs..'*')
        if i2 &gt;= i1 then
            s = sub(s,i2+1)
        end
    end
    if right then
        local i1,i2 = find(s,chrs..'*$')
        if i2 &gt;= i1 then
            s = sub(s,1,i1-1)
        end
    end
    return s
end

--- trim any whitespace on the left of s.
-- @param self the string
-- @param chrs default space, can be a string of characters to be trimmed
function stringx.lstrip(self,chrs)
    assert_string(1,self)
    return _strip(self,true,false,chrs)
end
lstrip = stringx.lstrip

--- trim any whitespace on the right of s.
-- @param s the string
-- @param chrs default space, can be a string of characters to be trimmed
function stringx.rstrip(s,chrs)
    assert_string(1,s)
    return _strip(s,false,true,chrs)
end

--- trim any whitespace on both left and right of s.
-- @param self the string
-- @param chrs default space, can be a string of characters to be trimmed
function stringx.strip(self,chrs)
    assert_string(1,self)
    return _strip(self,true,true,chrs)
end

-- The partition functions split a string  using a delimiter into three parts:
-- the part before, the delimiter itself, and the part afterwards
local function _partition(p,delim,fn)
    local i1,i2 = fn(p,delim)
    if not i1 or i1 == -1 then
        return p,'',''
    else
        if not i2 then i2 = i1 end
        return sub(p,1,i1-1),sub(p,i1,i2),sub(p,i2+1)
    end
end

--- partition the string using first occurance of a delimiter
-- @param self the string
-- @param ch delimiter
-- @return part before ch
-- @return ch
-- @return part after ch
function stringx.partition(self,ch)
    assert_string(1,self)
    assert_nonempty_string(2,ch)
    return _partition(self,ch,stringx.lfind)
end

--- partition the string p using last occurance of a delimiter
-- @param self the string
-- @param ch delimiter
-- @return part before ch
-- @return ch
-- @return part after ch
function stringx.rpartition(self,ch)
    assert_string(1,self)
    assert_nonempty_string(2,ch)
    return _partition(self,ch,stringx.rfind)
end

--- return the 'character' at the index.
-- @param self the string
-- @param idx an index (can be negative)
-- @return a substring of length 1 if successful, empty string otherwise.
function stringx.at(self,idx)
    assert_string(1,self)
    assert_arg(2,idx,'number')
    return sub(self,idx,idx)
end

--- return an interator over all lines in a string
-- @param self the string
-- @return an iterator
function stringx.lines (self)
    assert_string(1,self)
    local s = self
    if not s:find '\n$' then s = s..'\n' end
    return s:gmatch('([^\n]*)\n')
end

--- iniital word letters uppercase ('title case').
-- Here 'words' mean chunks of non-space characters.
-- @param self the string
-- @return a string with each word's first letter uppercase
function stringx.title(self)
    return (self:gsub('(%S)(%S*)',function(f,r)
        return f:upper()..r:lower()
    end))
end

stringx.capitalize = stringx.title

local elipsis = '...'
local n_elipsis = #elipsis

--- return a shorted version of a string.
-- @param self the string
-- @param sz the maxinum size allowed
-- @param tail true if we want to show the end of the string (head otherwise)
function stringx.shorten(self,sz,tail)
    if #self &gt; sz then
        if sz &lt; n_elipsis then return elipsis:sub(1,sz) end
        if tail then
            local i = #self - sz + 1 + n_elipsis
            return elipsis .. self:sub(i)
        else
            return self:sub(1,sz-n_elipsis) .. elipsis
        end
    end
    return self
end

function stringx.import(dont_overload)
    utils.import(stringx,string)
end

package.loaded['pl.stringx'] = stringx
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>lexer</name>
					<packageName></packageName>
					<script>--- Lexical scanner for creating a sequence of tokens from text.
-- `lexer.scan(s)` returns an iterator over all tokens found in the
-- string `s`. This iterator returns two values, a token type string
-- (such as 'string' for quoted string, 'iden' for identifier) and the value of the
-- token.
--
-- Versions specialized for Lua and C are available; these also handle block comments
-- and classify keywords as 'keyword' tokens. For example:
--
--    &gt; s = 'for i=1,n do'
--    &gt; for t,v in lexer.lua(s)  do print(t,v) end
--    keyword for
--    iden    i
--    =       =
--    number  1
--    ,       ,
--    iden    n
--    keyword do
--
-- See the Guide for further @{06-data.md.Lexical_Scanning|discussion}
-- @module pl.lexer

local yield,wrap = coroutine.yield,coroutine.wrap
local strfind = string.find
local strsub = string.sub
local append = table.insert

local function assert_arg(idx,val,tp)
    if type(val) ~= tp then
        error("argument "..idx.." must be "..tp, 2)
    end
end

local lexer = {}

local NUMBER1 = '^[%+%-]?%d+%.?%d*[eE][%+%-]?%d+'
local NUMBER2 = '^[%+%-]?%d+%.?%d*'
local NUMBER3 = '^0x[%da-fA-F]+'
local NUMBER4 = '^%d+%.?%d*[eE][%+%-]?%d+'
local NUMBER5 = '^%d+%.?%d*'
local IDEN = '^[%a_][%w_]*'
local WSPACE = '^%s+'
local STRING0 = [[^(['\"]).-\\%1]]
local STRING1 = [[^(['\"]).-[^\]%1]]
local STRING3 = "^((['\"])%2)" -- empty string
local PREPRO = '^#.-[^\\]\n'

local plain_matches,lua_matches,cpp_matches,lua_keyword,cpp_keyword

local function tdump(tok)
    return yield(tok,tok)
end

local function ndump(tok,options)
    if options and options.number then
        tok = tonumber(tok)
    end
    return yield("number",tok)
end

-- regular strings, single or double quotes; usually we want them
-- without the quotes
local function sdump(tok,options)
    if options and options.string then
        tok = tok:sub(2,-2)
    end
    return yield("string",tok)
end

-- long Lua strings need extra work to get rid of the quotes
local function sdump_l(tok,options)
    if options and options.string then
        tok = tok:sub(3,-3)
    end
    return yield("string",tok)
end

local function chdump(tok,options)
    if options and options.string then
        tok = tok:sub(2,-2)
    end
    return yield("char",tok)
end

local function cdump(tok)
    return yield('comment',tok)
end

local function wsdump (tok)
    return yield("space",tok)
end

local function pdump (tok)
    return yield('prepro',tok)
end

local function plain_vdump(tok)
    return yield("iden",tok)
end

local function lua_vdump(tok)
    if lua_keyword[tok] then
        return yield("keyword",tok)
    else
        return yield("iden",tok)
    end
end

local function cpp_vdump(tok)
    if cpp_keyword[tok] then
        return yield("keyword",tok)
    else
        return yield("iden",tok)
    end
end

--- create a plain token iterator from a string or file-like object.
-- @param s the string
-- @param matches an optional match table (set of pattern-action pairs)
-- @param filter a table of token types to exclude, by default {space=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.scan (s,matches,filter,options)
    --assert_arg(1,s,'string')
    local file = type(s) ~= 'string' and s
    filter = filter or {space=true}
    options = options or {number=true,string=true}
    if filter then
        if filter.space then filter[wsdump] = true end
        if filter.comments then
            filter[cdump] = true
        end
    end
    if not matches then
        if not plain_matches then
            plain_matches = {
                {WSPACE,wsdump},
                {NUMBER3,ndump},
                {IDEN,plain_vdump},
                {NUMBER1,ndump},
                {NUMBER2,ndump},
                {STRING3,sdump},
                {STRING0,sdump},
                {STRING1,sdump},
                {'^.',tdump}
            }
        end
        matches = plain_matches
    end
    local function lex ()
        local i1,i2,idx,res1,res2,tok,pat,fun,capt
        local line = 1
        if file then s = file:read()..'\n' end
        local sz = #s
        local idx = 1
        --print('sz',sz)
        while true do
            for _,m in ipairs(matches) do
                pat = m[1]
                fun = m[2]
                i1,i2 = strfind(s,pat,idx)
                if i1 then
                    tok = strsub(s,i1,i2)
                    idx = i2 + 1
                    if not (filter and filter[fun]) then
                        lexer.finished = idx &gt; sz
                        res1,res2 = fun(tok,options)
                    end
                    if res1 then
                        local tp = type(res1)
                        -- insert a token list
                        if tp=='table' then
                            yield('','')
                            for _,t in ipairs(res1) do
                                yield(t[1],t[2])
                            end
                        elseif tp == 'string' then -- or search up to some special pattern
                            i1,i2 = strfind(s,res1,idx)
                            if i1 then
                                tok = strsub(s,i1,i2)
                                idx = i2 + 1
                                yield('',tok)
                            else
                                yield('','')
                                idx = sz + 1
                            end
                            --if idx &gt; sz then return end
                        else
                            yield(line,idx)
                        end
                    end
                    if idx &gt; sz then
                        if file then
                            --repeat -- next non-empty line
                                line = line + 1
                                s = file:read()
                                if not s then return end
                            --until not s:match '^%s*$'
                            s = s .. '\n'
                            idx ,sz = 1,#s
                            break
                        else
                            return
                        end
                    else break end
                end
            end
        end
    end
    return wrap(lex)
end

local function isstring (s)
    return type(s) == 'string'
end

--- insert tokens into a stream.
-- @param tok a token stream
-- @param a1 a string is the type, a table is a token list and
-- a function is assumed to be a token-like iterator (returns type &amp; value)
-- @param a2 a string is the value
function lexer.insert (tok,a1,a2)
    if not a1 then return end
    local ts
    if isstring(a1) and isstring(a2) then
        ts = {{a1,a2}}
    elseif type(a1) == 'function' then
        ts = {}
        for t,v in a1() do
            append(ts,{t,v})
        end
    else
        ts = a1
    end
    tok(ts)
end

--- get everything in a stream upto a newline.
-- @param tok a token stream
-- @return a string
function lexer.getline (tok)
    local t,v = tok('.-\n')
    return v
end

--- get current line number. &lt;br&gt;
-- Only available if the input source is a file-like object.
-- @param tok a token stream
-- @return the line number and current column
function lexer.lineno (tok)
    return tok(0)
end

--- get the rest of the stream.
-- @param tok a token stream
-- @return a string
function lexer.getrest (tok)
    local t,v = tok('.+')
    return v
end

--- get the Lua keywords as a set-like table.
-- So &lt;code&gt;res["and"]&lt;/code&gt; etc would be &lt;code&gt;true&lt;/code&gt;.
-- @return a table
function lexer.get_keywords ()
    if not lua_keyword then
        lua_keyword = {
            ["and"] = true, ["break"] = true,  ["do"] = true,
            ["else"] = true, ["elseif"] = true, ["end"] = true,
            ["false"] = true, ["for"] = true, ["function"] = true,
            ["if"] = true, ["in"] = true,  ["local"] = true, ["nil"] = true,
            ["not"] = true, ["or"] = true, ["repeat"] = true,
            ["return"] = true, ["then"] = true, ["true"] = true,
            ["until"] = true,  ["while"] = true
        }
    end
    return lua_keyword
end


--- create a Lua token iterator from a string or file-like object.
-- Will return the token type and value.
-- @param s the string
-- @param filter a table of token types to exclude, by default {space=true,comments=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.lua(s,filter,options)
    filter = filter or {space=true,comments=true}
    lexer.get_keywords()
    if not lua_matches then
        lua_matches = {
            {WSPACE,wsdump},
            {NUMBER3,ndump},
            {IDEN,lua_vdump},
            {NUMBER4,ndump},
            {NUMBER5,ndump},
            {STRING3,sdump},
            {STRING0,sdump},
            {STRING1,sdump},
            {'^%-%-%[%[.-%]%]',cdump},
            {'^%-%-.-\n',cdump},
            {'^%[%[.-%]%]',sdump_l},
            {'^==',tdump},
            {'^~=',tdump},
            {'^&lt;=',tdump},
            {'^&gt;=',tdump},
            {'^%.%.%.',tdump},
            {'^%.%.',tdump},
            {'^.',tdump}
        }
    end
    return lexer.scan(s,lua_matches,filter,options)
end

--- create a C/C++ token iterator from a string or file-like object.
-- Will return the token type type and value.
-- @param s the string
-- @param filter a table of token types to exclude, by default {space=true,comments=true}
-- @param options a table of options; by default, {number=true,string=true},
-- which means convert numbers and strip string quotes.
function lexer.cpp(s,filter,options)
    filter = filter or {comments=true}
    if not cpp_keyword then
        cpp_keyword = {
            ["class"] = true, ["break"] = true,  ["do"] = true, ["sizeof"] = true,
            ["else"] = true, ["continue"] = true, ["struct"] = true,
            ["false"] = true, ["for"] = true, ["public"] = true, ["void"] = true,
            ["private"] = true, ["protected"] = true, ["goto"] = true,
            ["if"] = true, ["static"] = true,  ["const"] = true, ["typedef"] = true,
            ["enum"] = true, ["char"] = true, ["int"] = true, ["bool"] = true,
            ["long"] = true, ["float"] = true, ["true"] = true, ["delete"] = true,
            ["double"] = true,  ["while"] = true, ["new"] = true,
            ["namespace"] = true, ["try"] = true, ["catch"] = true,
            ["switch"] = true, ["case"] = true, ["extern"] = true,
            ["return"] = true,["default"] = true,['unsigned']  = true,['signed'] = true,
            ["union"] =  true, ["volatile"] = true, ["register"] = true,["short"] = true,
        }
    end
    if not cpp_matches then
        cpp_matches = {
            {WSPACE,wsdump},
            {PREPRO,pdump},
            {NUMBER3,ndump},
            {IDEN,cpp_vdump},
            {NUMBER4,ndump},
            {NUMBER5,ndump},
            {STRING3,sdump},
            {STRING1,chdump},
            {'^//.-\n',cdump},
            {'^/%*.-%*/',cdump},
            {'^==',tdump},
            {'^!=',tdump},
            {'^&lt;=',tdump},
            {'^&gt;=',tdump},
            {'^-&gt;',tdump},
            {'^&amp;&amp;',tdump},
            {'^||',tdump},
            {'^%+%+',tdump},
            {'^%-%-',tdump},
            {'^%+=',tdump},
            {'^%-=',tdump},
            {'^%*=',tdump},
            {'^/=',tdump},
            {'^|=',tdump},
            {'^%^=',tdump},
            {'^::',tdump},
            {'^.',tdump}
        }
    end
    return lexer.scan(s,cpp_matches,filter,options)
end

--- get a list of parameters separated by a delimiter from a stream.
-- @param tok the token stream
-- @param endtoken end of list (default ')'). Can be '\n'
-- @param delim separator (default ',')
-- @return a list of token lists.
function lexer.get_separated_list(tok,endtoken,delim)
    endtoken = endtoken or ')'
    delim = delim or ','
    local parm_values = {}
    local level = 1 -- used to count ( and )
    local tl = {}
    local function tappend (tl,t,val)
        val = val or t
        append(tl,{t,val})
    end
    local is_end
    if endtoken == '\n' then
        is_end = function(t,val)
            return t == 'space' and val:find '\n'
        end
    else
        is_end = function (t)
            return t == endtoken
        end
    end
    local token,value
    while true do
        token,value=tok()
        if not token then return nil,'EOS' end -- end of stream is an error!
        if is_end(token,value) and level == 1 then
            append(parm_values,tl)
            break
        elseif token == '(' then
            level = level + 1
            tappend(tl,'(')
        elseif token == ')' then
            level = level - 1
            if level == 0 then -- finished with parm list
                append(parm_values,tl)
                break
            else
                tappend(tl,')')
            end
        elseif token == delim and level == 1 then
            append(parm_values,tl) -- a new parm
            tl = {}
        else
            tappend(tl,token,value)
        end
    end
    return parm_values,{token,value}
end

--- get the next non-space token from the stream.
-- @param tok the token stream.
function lexer.skipws (tok)
    local t,v = tok()
    while t == 'space' do
        t,v = tok()
    end
    return t,v
end

local skipws = lexer.skipws

--- get the next token, which must be of the expected type.
-- Throws an error if this type does not match!
-- @param tok the token stream
-- @param expected_type the token type
-- @param no_skip_ws whether we should skip whitespace
function lexer.expecting (tok,expected_type,no_skip_ws)
    assert_arg(1,tok,'function')
    assert_arg(2,expected_type,'string')
    local t,v
    if no_skip_ws then
        t,v = tok()
    else
        t,v = skipws(tok)
    end
    if t ~= expected_type then error ("expecting "..expected_type,2) end
    return v
end

package.loaded['pl.lexer'] = lexer
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>pretty</name>
					<packageName></packageName>
					<script>--- Pretty-printing Lua tables.
-- Also provides a sandboxed Lua table reader and
-- a function to present large numbers in human-friendly format.
--
-- Dependencies: `pl.utils`, `pl.lexer`
-- @module pl.pretty

local append = table.insert
local concat = table.concat
local utils = require 'pl.utils'
local lexer = require 'pl.lexer'
local assert_arg = utils.assert_arg

local pretty = {}

local function save_string_index ()
    local SMT = getmetatable ''
    if SMT then
        SMT.old__index = SMT.__index
        SMT.__index = nil
    end
    return SMT
end

local function restore_string_index (SMT)
    if SMT then
        SMT.__index = SMT.old__index
    end
end

--- read a string representation of a Lua table.
-- Uses load(), but tries to be cautious about loading arbitrary code!
-- It is expecting a string of the form '{...}', with perhaps some whitespace
-- before or after the curly braces. A comment may occur beforehand.
-- An empty environment is used, and
-- any occurance of the keyword 'function' will be considered a problem.
-- in the given environment - the return value may be `nil`.
-- @param s {string} string of the form '{...}', with perhaps some whitespace
-- before or after the curly braces.
-- @return a table
function pretty.read(s)
    assert_arg(1,s,'string')
    if s:find '^%s*%-%-' then -- may start with a comment..
        s = s:gsub('%-%-.-\n','')
    end
    if not s:find '^%s*%b{}%s*$' then return nil,"not a Lua table" end
    if s:find '[^\'"%w_]function[^\'"%w_]' then
        local tok = lexer.lua(s)
        for t,v in tok do
            if t == 'keyword' then
                return nil,"cannot have functions in table definition"
            end
        end
    end
    s = 'return '..s
    local chunk,err = utils.load(s,'tbl','t',{})
    if not chunk then return nil,err end
    local SMT = save_string_index()
    local ok,ret = pcall(chunk)
    restore_string_index(SMT)
    if ok then return ret
    else
        return nil,ret
    end
end

--- read a Lua chunk.
-- @param s Lua code
-- @param env optional environment
-- @param paranoid prevent any looping constructs and disable string methods
-- @return the environment
function pretty.load (s, env, paranoid)
    env = env or {}
    if paranoid then
        local tok = lexer.lua(s)
        for t,v in tok do
            if t == 'keyword'
                and (v == 'for' or v == 'repeat' or v == 'function' or v == 'goto')
            then
                return nil,"looping not allowed"
            end
        end
    end
    local chunk,err = utils.load(s,'tbl','t',env)
    if not chunk then return nil,err end
    local SMT = paranoid and save_string_index()
    local ok,err = pcall(chunk)
    restore_string_index(SMT)
    if not ok then return nil,err end
    return env
end

local function quote_if_necessary (v)
    if not v then return ''
    else
        if v:find ' ' then v = '"'..v..'"' end
    end
    return v
end

local keywords

local function is_identifier (s)
    return type(s) == 'string' and s:find('^[%a_][%w_]*$') and not keywords[s]
end

local function quote (s)
    if type(s) == 'table' then
        return pretty.write(s,'')
    else
        return ('%q'):format(tostring(s))
    end
end

local function index (numkey,key)
    if not numkey then key = quote(key) end
    return '['..key..']'
end


---	Create a string representation of a Lua table.
--  This function never fails, but may complain by returning an
--  extra value. Normally puts out one item per line, using
--  the provided indent; set the second parameter to '' if
--  you want output on one line.
--	@param tbl {table} Table to serialize to a string.
--	@param space {string} (optional) The indent to use.
--	Defaults to two spaces; make it the empty string for no indentation
--	@param not_clever {bool} (optional) Use for plain output, e.g {['key']=1}.
--	Defaults to false.
--  @return a string
--  @return a possible error message
function pretty.write (tbl,space,not_clever)
    if type(tbl) ~= 'table' then
        local res = tostring(tbl)
        if type(tbl) == 'string' then return quote(tbl) end
        return res, 'not a table'
    end
    if not keywords then
        keywords = lexer.get_keywords()
    end
    local set = ' = '
    if space == '' then set = '=' end
    space = space or '  '
    local lines = {}
    local line = ''
    local tables = {}


    local function put(s)
        if #s &gt; 0 then
            line = line..s
        end
    end

    local function putln (s)
        if #line &gt; 0 then
            line = line..s
            append(lines,line)
            line = ''
        else
            append(lines,s)
        end
    end

    local function eat_last_comma ()
        local n,lastch = #lines
        local lastch = lines[n]:sub(-1,-1)
        if lastch == ',' then
            lines[n] = lines[n]:sub(1,-2)
        end
    end


    local writeit
    writeit = function (t,oldindent,indent)
        local tp = type(t)
        if tp ~= 'string' and  tp ~= 'table' then
            putln(quote_if_necessary(tostring(t))..',')
        elseif tp == 'string' then
            if t:find('\n') then
                putln('[[\n'..t..']],')
            else
                putln(quote(t)..',')
            end
        elseif tp == 'table' then
            if tables[t] then
                putln('&lt;cycle&gt;,')
                return
            end
            tables[t] = true
            local newindent = indent..space
            putln('{')
            local used = {}
            if not not_clever then
                for i,val in ipairs(t) do
                    put(indent)
                    writeit(val,indent,newindent)
                    used[i] = true
                end
            end
            for key,val in pairs(t) do
                local numkey = type(key) == 'number'
                if not_clever then
                    key = tostring(key)
                    put(indent..index(numkey,key)..set)
                    writeit(val,indent,newindent)
                else
                    if not numkey or not used[key] then -- non-array indices
                        if numkey or not is_identifier(key) then
                            key = index(numkey,key)
                        end
                        put(indent..key..set)
                        writeit(val,indent,newindent)
                    end
                end
            end
            tables[t] = nil
            eat_last_comma()
            putln(oldindent..'},')
        else
            putln(tostring(t)..',')
        end
    end
    writeit(tbl,'',space)
    eat_last_comma()
    return concat(lines,#space &gt; 0 and '\n' or '')
end

---	Dump a Lua table out to a file or stdout.
--	@param t {table} The table to write to a file or stdout.
--	@param ... {string} (optional) File name to write too. Defaults to writing
--	to stdout.
function pretty.dump (t,...)
    if select('#',...)==0 then
        print(pretty.write(t))
        return true
    else
        return utils.writefile(...,pretty.write(t))
    end
end

local memp,nump = {'B','KiB','MiB','GiB'},{'','K','M','B'}

local comma
function comma (val)
    local thou = math.floor(val/1000)
    if thou &gt; 0 then return comma(thou)..','..(val % 1000)
    else return tostring(val) end
end

--- format large numbers nicely for human consumption.
-- @param num a number
-- @param kind one of 'M' (memory in KiB etc), 'N' (postfixes are 'K','M' and 'B')
-- and 'T' (use commas as thousands separator)
-- @param prec number of digits to use for 'M' and 'N' (default 1)
function pretty.number (num,kind,prec)
    local fmt = '%.'..(prec or 1)..'f%s'
    if kind == 'T' then
        return comma(num)
    else
        local postfixes, fact
        if kind == 'M' then
            fact = 1024
            postfixes = memp
        else
            fact = 1000
            postfixes = nump
        end
        local div = fact
        local k = 1
        while num &gt;= div and k &lt;= #postfixes do
            div = div * fact
            k = k + 1
        end
        div = div / fact
        if k &gt; #postfixes then k = k - 1; div = div/fact end
        if k &gt; 1 then
            return fmt:format(num/div,postfixes[k] or 'duh')
        else
            return num..postfixes[1]
        end
    end
end

package.loaded['pl.pretty'] = pretty
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>path</name>
					<packageName></packageName>
					<script>--- Path manipulation and file queries.
--
-- This is modelled after Python's os.path library (10.1); see @{04-paths.md|the Guide}.
--
-- Dependencies: `pl.utils`, `lfs`
-- @module pl.path

-- imports and locals
local _G = _G
local sub = string.sub
local getenv = os.getenv
local tmpnam = os.tmpname
local attributes, currentdir, link_attrib
local package = package
local io = io
local append = table.insert
local ipairs = ipairs
local utils = require 'pl.utils'
local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise

local attrib
local path = {}

local res,lfs = _G.pcall(_G.require,'lfs')
if res then
    attributes = lfs.attributes
    currentdir = lfs.currentdir
    link_attrib = lfs.symlinkattributes
else
    error("pl.path requires LuaFileSystem")
end

attrib = attributes
path.attrib = attrib
path.link_attrib = link_attrib
path.dir = lfs.dir
path.mkdir = lfs.mkdir
path.rmdir = lfs.rmdir
path.chdir = lfs.chdir

--- is this a directory?
-- @param P A file path
function path.isdir(P)
	assert_string(1,P)
    if P:match("\\$") then
        P = P:sub(1,-2)
    end
    return attrib(P,'mode') == 'directory'
end

--- is this a file?.
-- @param P A file path
function path.isfile(P)
	assert_string(1,P)
    return attrib(P,'mode') == 'file'
end

-- is this a symbolic link?
-- @param P A file path
function path.islink(P)
	assert_string(1,P)
    if link_attrib then
        return link_attrib(P,'mode')=='link'
    else
        return false
    end
end

--- return size of a file.
-- @param P A file path
function path.getsize(P)
	assert_string(1,P)
    return attrib(P,'size')
end

--- does a path exist?.
-- @param P A file path
-- @return the file path if it exists, nil otherwise
function path.exists(P)
	assert_string(1,P)
    return attrib(P,'mode') ~= nil and P
end

--- Return the time of last access as the number of seconds since the epoch.
-- @param P A file path
function path.getatime(P)
	assert_string(1,P)
    return attrib(P,'access')
end

--- Return the time of last modification
-- @param P A file path
function path.getmtime(P)
    return attrib(P,'modification')
end

---Return the system's ctime.
-- @param P A file path
function path.getctime(P)
	assert_string(1,P)
    return path.attrib(P,'change')
end


local function at(s,i)
    return sub(s,i,i)
end

path.is_windows = utils.dir_separator == '\\'

local other_sep
-- !constant sep is the directory separator for this platform.
if path.is_windows then
    path.sep = '\\'; other_sep = '/'
    path.dirsep = ';'
else
    path.sep = '/'
    path.dirsep = ':'
end
local sep,dirsep = path.sep,path.dirsep

--- are we running Windows?
-- @class field
-- @name path.is_windows

--- path separator for this platform.
-- @class field
-- @name path.sep

--- separator for PATH for this platform
-- @class field
-- @name path.dirsep

--- given a path, return the directory part and a file part.
-- if there's no directory part, the first value will be empty
-- @param P A file path
function path.splitpath(P)
    assert_string(1,P)
    local i = #P
    local ch = at(P,i)
    while i &gt; 0 and ch ~= sep and ch ~= other_sep do
        i = i - 1
        ch = at(P,i)
    end
    if i == 0 then
        return '',P
    else
        return sub(P,1,i-1), sub(P,i+1)
    end
end

--- return an absolute path.
-- @param P A file path
-- @param pwd optional start path to use (default is current dir)
function path.abspath(P,pwd)
    assert_string(1,P)
	if pwd then assert_string(2,pwd) end
    local use_pwd = pwd ~= nil
    if not use_pwd and not currentdir then return P end
    P = P:gsub('[\\/]$','')
    pwd = pwd or currentdir()
    if not path.isabs(P) then
        P = path.join(pwd,P)
    elseif path.is_windows and not use_pwd and at(P,2) ~= ':' and at(P,2) ~= '\\' then
        P = pwd:sub(1,2)..P -- attach current drive to path like '\\fred.txt'
    end
    return path.normpath(P)
end

--- given a path, return the root part and the extension part.
-- if there's no extension part, the second value will be empty
-- @param P A file path
function path.splitext(P)
    assert_string(1,P)
    local i = #P
    local ch = at(P,i)
    while i &gt; 0 and ch ~= '.' do
        if ch == sep or ch == other_sep then
            return P,''
        end
        i = i - 1
        ch = at(P,i)
    end
    if i == 0 then
        return P,''
    else
        return sub(P,1,i-1),sub(P,i)
    end
end

--- return the directory part of a path
-- @param P A file path
function path.dirname(P)
    assert_string(1,P)
    local p1,p2 = path.splitpath(P)
    return p1
end

--- return the file part of a path
-- @param P A file path
function path.basename(P)
    assert_string(1,P)
    local p1,p2 = path.splitpath(P)
    return p2
end

--- get the extension part of a path.
-- @param P A file path
function path.extension(P)
    assert_string(1,P)
    local p1,p2 = path.splitext(P)
    return p2
end

--- is this an absolute path?.
-- @param P A file path
function path.isabs(P)
    assert_string(1,P)
    if path.is_windows then
        return at(P,1) == '/' or at(P,1)=='\\' or at(P,2)==':'
    else
        return at(P,1) == '/'
    end
end

--- return the path resulting from combining the individual paths.
-- if the second (or later) path is absolute, we return the last absolute path (joined with any non-absolute paths following).
-- empty elements (except the last) will be ignored.
-- @param p1 A file path
-- @param p2 A file path
-- @param ... more file paths
function path.join(p1,p2,...)
    assert_string(1,p1)
    assert_string(2,p2)
    if select('#',...) &gt; 0 then
        local p = path.join(p1,p2)
        local args = {...}
        for i = 1,#args do
            assert_string(i,args[i])
            p = path.join(p,args[i])
        end
        return p
    end
    if path.isabs(p2) then return p2 end
    local endc = at(p1,#p1)
    if endc ~= path.sep and endc ~= other_sep and endc ~= "" then
        p1 = p1..path.sep
    end
    return p1..p2
end

--- normalize the case of a pathname. On Unix, this returns the path unchanged;
--  for Windows, it converts the path to lowercase, and it also converts forward slashes
-- to backward slashes.
-- @param P A file path
function path.normcase(P)
    assert_string(1,P)
    if path.is_windows then
        return (P:lower():gsub('/','\\'))
    else
        return P
    end
end

local np_gen1,np_gen2 = '[^SEP]+SEP%.%.SEP?','SEP+%.?SEP'
local np_pat1, np_pat2

--- normalize a path name.
--  A//B, A/./B and A/foo/../B all become A/B.
-- @param P a file path
function path.normpath(P)
    assert_string(1,P)
    if path.is_windows then
        if P:match '^\\\\' then -- UNC
            return '\\\\'..path.normpath(P:sub(3))
        end
        P = P:gsub('/','\\')
    end
    if not np_pat1 then
        np_pat1 = np_gen1:gsub('SEP',sep)
        np_pat2 = np_gen2:gsub('SEP',sep)
    end
    local k
    repeat -- /./ -&gt; /
        P,k = P:gsub(np_pat2,sep)
    until k == 0
    repeat -- A/../ -&gt; (empty)
        P,k = P:gsub(np_pat1,'')
    until k == 0
    if P == '' then P = '.' end
    return P
end

local function ATS (P)
    if at(P,#P) ~= path.sep then
        P = P..path.sep
    end
    return path.normcase(P)
end

--- relative path from current directory or optional start point
-- @param P a path
-- @param start optional start point (default current directory)
function path.relpath (P,start)
    assert_string(1,P)
	if start then assert_string(2,start) end
    local split,normcase,min,append = utils.split, path.normcase, math.min, table.insert
    P = normcase(path.abspath(P,start))
    start = start or currentdir()
    start = normcase(start)
    local startl, Pl = split(start,sep), split(P,sep)
    local n = min(#startl,#Pl)
    local k = n+1 -- default value if this loop doesn't bail out!
    for i = 1,n do
        if startl[i] ~= Pl[i] then
            k = i
            break
        end
    end
    local rell = {}
    for i = 1, #startl-k+1 do rell[i] = '..' end
    if k &lt;= #Pl then
        for i = k,#Pl do append(rell,Pl[i]) end
    end
    return table.concat(rell,sep)
end


--- Replace a starting '~' with the user's home directory.
-- In windows, if HOME isn't set, then USERPROFILE is used in preference to
-- HOMEDRIVE HOMEPATH. This is guaranteed to be writeable on all versions of Windows.
-- @param P A file path
function path.expanduser(P)
    assert_string(1,P)
    if at(P,1) == '~' then
        local home = getenv('HOME')
        if not home then -- has to be Windows
            home = getenv 'USERPROFILE' or (getenv 'HOMEDRIVE' .. getenv 'HOMEPATH')
        end
        return home..sub(P,2)
    else
        return P
    end
end


---Return a suitable full path to a new temporary file name.
-- unlike os.tmpnam(), it always gives you a writeable path (uses %TMP% on Windows)
function path.tmpname ()
    local res = tmpnam()
    if path.is_windows then res = getenv('TMP')..res end
    return res
end

--- return the largest common prefix path of two paths.
-- @param path1 a file path
-- @param path2 a file path
function path.common_prefix (path1,path2)
    assert_string(1,path1)
    assert_string(2,path2)
    path1, path2 = path.normcase(path1), path.normcase(path2)
    -- get them in order!
    if #path1 &gt; #path2 then path2,path1 = path1,path2 end
    for i = 1,#path1 do
        local c1 = at(path1,i)
        if c1 ~= at(path2,i) then
            local cp = path1:sub(1,i-1)
            if at(path1,i-1) ~= sep then
                cp = path.dirname(cp)
            end
            return cp
        end
    end
    if at(path2,#path1+1) ~= sep then path1 = path.dirname(path1) end
    return path1
    --return ''
end


--- return the full path where a particular Lua module would be found.
-- Both package.path and package.cpath is searched, so the result may
-- either be a Lua file or a shared libarary.
-- @param mod name of the module
-- @return on success: path of module, lua or binary
-- @return on error: nil,error string
function path.package_path(mod)
    assert_string(1,mod)
    local res
    mod = mod:gsub('%.',sep)
    res = package.searchpath(mod,package.path)
    if res then return res,true end
    res = package.searchpath(mod,package.cpath)
    if res then return res,false end
    return raise 'cannot find module on path'
end


---- finis -----
package.loaded['pl.path'] = path
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>class</name>
					<packageName></packageName>
					<script>--- Provides a reuseable and convenient framework for creating classes in Lua.
-- Two possible notations:
--
--    B = class(A)
--    class.B(A)
--
-- The latter form creates a named class.
--
-- See the Guide for further @{01-introduction.md.Simplifying_Object_Oriented_Programming_in_Lua|discussion}
-- @module pl.class

local error, getmetatable, io, pairs, rawget, rawset, setmetatable, tostring, type =
    _G.error, _G.getmetatable, _G.io, _G.pairs, _G.rawget, _G.rawset, _G.setmetatable, _G.tostring, _G.type
-- this trickery is necessary to prevent the inheritance of 'super' and
-- the resulting recursive call problems.
local function call_ctor (c,obj,...)
    -- nice alias for the base class ctor
    local base = rawget(c,'_base')
    if base then
        local parent_ctor = rawget(base,'_init')
        if parent_ctor then
            obj.super = function(obj,...)
                call_ctor(base,obj,...)
            end
        end
    end
    local res = c._init(obj,...)
    obj.super = nil
    return res
end

local function is_a(self,klass)
    local m = getmetatable(self)
    if not m then return false end --*can't be an object!
    while m do
        if m == klass then return true end
        m = rawget(m,'_base')
    end
    return false
end

local function class_of(klass,obj)
    if type(klass) ~= 'table' or not rawget(klass,'is_a') then return false end
    return klass.is_a(obj,klass)
end

local function _class_tostring (obj)
    local mt = obj._class
    local name = rawget(mt,'_name')
    setmetatable(obj,nil)
    local str = tostring(obj)
    setmetatable(obj,mt)
    if name then str = name ..str:gsub('table','') end
    return str
end

local function tupdate(td,ts)
    for k,v in pairs(ts) do
        td[k] = v
    end
end

local function _class(base,c_arg,c)
    c = c or {}     -- a new class instance, which is the metatable for all objects of this type
    -- the class will be the metatable for all its objects,
    -- and they will look up their methods in it.
    local mt = {}   -- a metatable for the class instance

    if type(base) == 'table' then
        -- our new class is a shallow copy of the base class!
        tupdate(c,base)
        c._base = base
        -- inherit the 'not found' handler, if present
        if rawget(c,'_handler') then mt.__index = c._handler end
    elseif base ~= nil then
        error("must derive from a table type",3)
    end

    c.__index = c
    setmetatable(c,mt)
    c._init = nil

    if base and rawget(base,'_class_init') then
        base._class_init(c,c_arg)
    end

    -- expose a ctor which can be called by &lt;classname&gt;(&lt;args&gt;)
    mt.__call = function(class_tbl,...)
        local obj = {}
        setmetatable(obj,c)

        if rawget(c,'_init') then -- explicit constructor
            local res = call_ctor(c,obj,...)
            if res then -- _if_ a ctor returns a value, it becomes the object...
                obj = res
                setmetatable(obj,c)
            end
        elseif base and rawget(base,'_init') then -- default constructor
            -- make sure that any stuff from the base class is initialized!
            call_ctor(base,obj,...)
        end

        if base and rawget(base,'_post_init') then
            base._post_init(obj)
        end

        if not rawget(c,'__tostring') then
            c.__tostring = _class_tostring
        end
        return obj
    end
    -- Call Class.catch to set a handler for methods/properties not found in the class!
    c.catch = function(handler)
        c._handler = handler
        mt.__index = handler
    end
    c.is_a = is_a
    c.class_of = class_of
    c._class = c

    return c
end

--- create a new class, derived from a given base class.
-- Supporting two class creation syntaxes:
-- either `Name = class(base)` or `class.Name(base)`
-- @function class
-- @param base optional base class
-- @param c_arg optional parameter to class ctor
-- @param c optional table to be used as class
local class
class = setmetatable({},{
    __call = function(fun,...)
        return _class(...)
    end,
    __index = function(tbl,key)
        if key == 'class' then
            io.stderr:write('require("pl.class").class is deprecated. Use require("pl.class")\n')
            return class
        end
        local env = _G
        return function(...)
            local c = _class(...)
            c._name = key
            rawset(env,key,c)
            return c
        end
    end
})

class.properties = class()

function class.properties._class_init(klass)
    klass.__index = function(t,key)
        -- normal class lookup!
        local v = klass[key]
        if v then return v end
        -- is it a getter?
        v = rawget(klass,'get_'..key)
        if v then
            return v(t)
        end
        -- is it a field?
        return rawget(t,'_'..key)
    end
    klass.__newindex = function (t,key,value)
        -- if there's a setter, use that, otherwise directly set table
        local p = 'set_'..key
        local setter = klass[p]
        if setter then
            setter(t,value)
        else
            rawset(t,key,value)
        end
    end
end


package.loaded['pl.class'] = class

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>List</name>
					<packageName></packageName>
					<script>--- Python-style list class.
--
-- **Please Note**: methods that change the list will return the list.
-- This is to allow for method chaining, but please note that `ls = ls:sort()`
-- does not mean that a new copy of the list is made. In-place (mutable) methods
-- are marked as returning 'the list' in this documentation.
--
-- See the Guide for further @{02-arrays.md.Python_style_Lists|discussion}
--
-- See &lt;a href="http://www.python.org/doc/current/tut/tut.html"&gt;http://www.python.org/doc/current/tut/tut.html&lt;/a&gt;, section 5.1
--
-- **Note**: The comments before some of the functions are from the Python docs
-- and contain Python code.
--
-- Written for Lua version Nick Trout 4.0; Redone for Lua 5.1, Steve Donovan.
--
-- Dependencies: `pl.utils`, `pl.tablex`
-- @module pl.List
-- @pragma nostrip

local tinsert,tremove,concat,tsort = table.insert,table.remove,table.concat,table.sort
local setmetatable, getmetatable,type,tostring,assert,string,next = setmetatable,getmetatable,type,tostring,assert,string,next
local write = io.write
local tablex = require 'pl.tablex'
local filter,imap,imap2,reduce,transform,tremovevalues = tablex.filter,tablex.imap,tablex.imap2,tablex.reduce,tablex.transform,tablex.removevalues
local tablex = tablex
local tsub = tablex.sub
local utils = require 'pl.utils'
local array_tostring,split,is_type,assert_arg,function_arg = utils.array_tostring,utils.split,utils.is_type,utils.assert_arg,utils.function_arg
local normalize_slice = tablex._normalize_slice

--[[
module ('pl.List',utils._module)
]]

local Multimap = utils.stdmt.MultiMap
-- metatable for our list objects
local List = utils.stdmt.List
List.__index = List
List._class = List

local iter

-- we give the metatable its own metatable so that we can call it like a function!
setmetatable(List,{
    __call = function (tbl,arg)
        return List.new(arg)
    end,
})

local function makelist (t,obj)
    local klass = List
    if obj then
        klass = getmetatable(obj)
    end
    return setmetatable(t,klass)
end

local function is_list(t)
    return getmetatable(t) == List
end

local function simple_table(t)
  return type(t) == 'table' and not is_list(t) and #t &gt; 0
end

function List:_init (src)
    if src then
        for v in iter(src) do
            tinsert(self,v)
        end
    end
end

--- Create a new list. Can optionally pass a table;
-- passing another instance of List will cause a copy to be created
-- we pass anything which isn't a simple table to iterate() to work out
-- an appropriate iterator  @see List.iterate
-- @param t An optional list-like table
-- @return a new List
-- @usage ls = List();  ls = List {1,2,3,4}
function List.new(t)
    local ls
    if not simple_table(t) then
        ls = {}
        List._init(ls,t)
    else
        ls = t
    end
    makelist(ls)
    return ls
end

function List:clone()
    local ls = makelist({},self)
    List._init(ls,self)
    return ls
end

function List.default_map_with(T)
    return function(self,name)
       local f = T[name]
       if f then
          return function(self,...)
             return self:map(f,...)
          end
       else
          error("method not found: "..name,2)
       end
    end
end


---Add an item to the end of the list.
-- @param i An item
-- @return the list
function List:append(i)
  tinsert(self,i)
  return self
end

List.push = tinsert

--- Extend the list by appending all the items in the given list.
-- equivalent to 'a[len(a):] = L'.
-- @param L Another List
-- @return the list
function List:extend(L)
  assert_arg(1,L,'table')
  for i = 1,#L do tinsert(self,L[i]) end
  return self
end

--- Insert an item at a given position. i is the index of the
-- element before which to insert.
-- @param i index of element before whichh to insert
-- @param x A data item
-- @return the list
function List:insert(i, x)
  assert_arg(1,i,'number')
  tinsert(self,i,x)
  return self
end

--- Insert an item at the begining of the list.
-- @param x a data item
-- @return the list
function List:put (x)
    return self:insert(1,x)
end

--- Remove an element given its index.
-- (equivalent of Python's del s[i])
-- @param i the index
-- @return the list
function List:remove (i)
    assert_arg(1,i,'number')
    tremove(self,i)
    return self
end

--- Remove the first item from the list whose value is given.
-- (This is called 'remove' in Python; renamed to avoid confusion
-- with table.remove)
-- Return nil if there is no such item.
-- @param x A data value
-- @return the list
function List:remove_value(x)
    for i=1,#self do
        if self[i]==x then tremove(self,i) return self end
    end
    return self
 end

--- Remove the item at the given position in the list, and return it.
-- If no index is specified, a:pop() returns the last item in the list.
-- The item is also removed from the list.
-- @param i An index
-- @return the item
function List:pop(i)
    if not i then i = #self end
    assert_arg(1,i,'number')
    return tremove(self,i)
end

List.get = List.pop

--- Return the index in the list of the first item whose value is given.
-- Return nil if there is no such item.
-- @class function
-- @name List:index
-- @param x A data value
-- @param idx where to start search (default 1)
-- @return the index, or nil if not found.

local tfind = tablex.find
List.index = tfind

--- does this list contain the value?.
-- @param x A data value
-- @return true or false
function List:contains(x)
    return tfind(self,x) and true or false
end

--- Return the number of times value appears in the list.
-- @param x A data value
-- @return number of times x appears
function List:count(x)
    local cnt=0
    for i=1,#self do
        if self[i]==x then cnt=cnt+1 end
    end
    return cnt
end

--- Sort the items of the list, in place.
-- @param cmp an optional comparison function, default '&lt;'
-- @return the list
function List:sort(cmp)
    if cmp then cmp = function_arg(1,cmp) end
    tsort(self,cmp)
    return self
end

--- return a sorted copy of this list.
-- @param cmp an optional comparison function, default '&lt;'
-- @return a new list
function List:sorted(cmp)
    return List(self):sort(cmp)
end

--- Reverse the elements of the list, in place.
-- @return the list
function List:reverse()
    local t = self
    local n = #t
    local n2 = n/2
    for i = 1,n2 do
        local k = n-i+1
        t[i],t[k] = t[k],t[i]
    end
    return self
end

--- return the minimum and the maximum value of the list.
-- @return minimum value
-- @return maximum value
function List:minmax()
    local vmin,vmax = 1e70,-1e70
    for i = 1,#self do
        local v = self[i]
        if v &lt; vmin then vmin = v end
        if v &gt; vmax then vmax = v end
    end
    return vmin,vmax
end

--- Emulate list slicing.  like  'list[first:last]' in Python.
-- If first or last are negative then they are relative to the end of the list
-- eg. slice(-2) gives last 2 entries in a list, and
-- slice(-4,-2) gives from -4th to -2nd
-- @param first An index
-- @param last An index
-- @return a new List
function List:slice(first,last)
    return tsub(self,first,last)
end

--- empty the list.
-- @return the list
function List:clear()
    for i=1,#self do tremove(self) end
    return self
end

local eps = 1.0e-10

--- Emulate Python's range(x) function.
-- Include it in List table for tidiness
-- @param start A number
-- @param finish A number greater than start; if absent,
-- then start is 1 and finish is start
-- @param incr an optional increment (may be less than 1)
-- @return a List from start .. finish
-- @usage List.range(0,3) == List{0,1,2,3}
-- @usage List.range(4) = List{1,2,3,4}
-- @usage List.range(5,1,-1) == List{5,4,3,2,1}
function List.range(start,finish,incr)
  if not finish then
    finish = start
    start = 1
  end
  if incr then
    assert_arg(3,incr,'number')
    if not utils.is_integer(incr) then finish = finish + eps end
  else
    incr = 1
  end
  assert_arg(1,start,'number')
  assert_arg(2,finish,'number')
  local t = List.new()
  for i=start,finish,incr do tinsert(t,i) end
  return t
end

--- list:len() is the same as #list.
function List:len()
  return #self
end

-- Extended operations --

--- Remove a subrange of elements.
-- equivalent to 'del s[i1:i2]' in Python.
-- @param i1 start of range
-- @param i2 end of range
-- @return the list
function List:chop(i1,i2)
    return tremovevalues(self,i1,i2)
end

--- Insert a sublist into a list
-- equivalent to 's[idx:idx] = list' in Python
-- @param idx index
-- @param list list to insert
-- @return the list
-- @usage  l = List{10,20}; l:splice(2,{21,22});  assert(l == List{10,21,22,20})
function List:splice(idx,list)
    assert_arg(1,idx,'number')
    idx = idx - 1
    local i = 1
    for v in iter(list) do
        tinsert(self,i+idx,v)
        i = i + 1
    end
    return self
end

--- general slice assignment s[i1:i2] = seq.
-- @param i1  start index
-- @param i2  end index
-- @param seq a list
-- @return the list
function List:slice_assign(i1,i2,seq)
    assert_arg(1,i1,'number')
    assert_arg(1,i2,'number')
    i1,i2 = normalize_slice(self,i1,i2)
    if i2 &gt;= i1 then self:chop(i1,i2) end
    self:splice(i1,seq)
    return self
end

--- concatenation operator.
-- @param L another List
-- @return a new list consisting of the list with the elements of the new list appended
function List:__concat(L)
    assert_arg(1,L,'table')
    local ls = self:clone()
    ls:extend(L)
    return ls
end

--- equality operator ==.  True iff all elements of two lists are equal.
-- @param L another List
-- @return true or false
function List:__eq(L)
    if #self ~= #L then return false end
    for i = 1,#self do
        if self[i] ~= L[i] then return false end
    end
    return true
end

--- join the elements of a list using a delimiter. &lt;br&gt;
-- This method uses tostring on all elements.
-- @param delim a delimiter string, can be empty.
-- @return a string
function List:join (delim)
    delim = delim or ''
    assert_arg(1,delim,'string')
    return concat(array_tostring(self),delim)
end

--- join a list of strings. &lt;br&gt;
-- Uses table.concat directly.
-- @class function
-- @name List:concat
-- @param delim a delimiter
-- @return a string
List.concat = concat

local function tostring_q(val)
    local s = tostring(val)
    if type(val) == 'string' then
        s = '"'..s..'"'
    end
    return s
end

--- how our list should be rendered as a string. Uses join().
-- @see List:join
function List:__tostring()
    return '{'..self:join(',',tostring_q)..'}'
end

--[[
-- NOTE: this works, but is unreliable. If you leave the loop before finishing,
-- then the iterator is not reset.
--- can iterate over a list directly.
-- @usage for v in ls do print(v) end
function List:__call()
    if not self.key then self.key = 1 end
    local value = self[self.key]
    self.key = self.key + 1
    if not value then self.key = nil end
    return value
end
--]]

--[[
function List.__call(t,v,i)
    i = (i or 0) + 1
    v = t[i]
    if v then return i, v end
end
--]]

local MethodIter = {}

function MethodIter:__index (name)
    return function(mm,...)
        return self.list:foreachm(name,...)
    end
end

--- call the function for each element of the list.
-- @param fun a function or callable object
-- @param ... optional values to pass to function
function List:foreach (fun,...)
    if fun==nil then
        return setmetatable({list=self},MethodIter)
    end
    fun = function_arg(1,fun)
    for i = 1,#self do
        fun(self[i],...)
    end
end

function List:foreachm (name,...)
    for i = 1,#self do
        local obj = self[i]
        local f = assert(obj[name],"method not found on object")
        f(obj,...)
    end
end

--- create a list of all elements which match a function.
-- @param fun a boolean function
-- @param arg optional argument to be passed as second argument of the predicate
-- @return a new filtered list.
function List:filter (fun,arg)
    return makelist(filter(self,fun,arg),self)
end

--- split a string using a delimiter.
-- @param s the string
-- @param delim the delimiter (default spaces)
-- @return a List of strings
-- @see pl.utils.split
function List.split (s,delim)
    assert_arg(1,s,'string')
    return makelist(split(s,delim))
end

local MethodMapper = {}

function MethodMapper:__index (name)
    return function(mm,...)
        return self.list:mapm(name,...)
    end
end

--- apply a function to all elements.
-- Any extra arguments will be passed to the function; if the function
-- is `nil` then `map` returns a mapper object that maps over a method
-- of the items
-- @param fun a function of at least one argument
-- @param ... arbitrary extra arguments.
-- @return a new list: {f(x) for x in self}
-- @usage List{'one','two'}:map(string.upper) == {'ONE','TWO'}
-- @usage List{'one','two'}:map():sub(1,2) == {'on','tw'}
-- @see pl.tablex.imap
function List:map (fun,...)
    if fun==nil then
        return setmetatable({list=self},MethodMapper)
    end
    return makelist(imap(fun,self,...),self)
end

--- apply a function to all elements, in-place.
-- Any extra arguments are passed to the function.
-- @param fun A function that takes at least one argument
-- @param ... arbitrary extra arguments.
-- @return the list.
function List:transform (fun,...)
    transform(fun,self,...)
	return self
end

--- apply a function to elements of two lists.
-- Any extra arguments will be passed to the function
-- @param fun a function of at least two arguments
-- @param ls another list
-- @param ... arbitrary extra arguments.
-- @return a new list: {f(x,y) for x in self, for x in arg1}
-- @see pl.tablex.imap2
function List:map2 (fun,ls,...)
    return makelist(imap2(fun,self,ls,...),self)
end

--- apply a named method to all elements.
-- Any extra arguments will be passed to the method.
-- @param name name of method
-- @param ... extra arguments
-- @return a new list of the results
-- @see pl.seq.mapmethod
function List:mapm (name,...)
    local res = {}
    local t = self
    for i = 1,#t do
      local val = t[i]
      local fn = val[name]
      if not fn then error(type(val).." does not have method "..name,2) end
      res[i] = fn(val,...)
    end
    return makelist(res,self)
end

--- 'reduce' a list using a binary function.
-- @param fun a function of two arguments
-- @return result of the function
-- @see pl.tablex.reduce
function List:reduce (fun)
    return reduce(fun,self)
end

--- partition a list using a classifier function.
-- The function may return nil, but this will be converted to the string key '&lt;nil&gt;'.
-- @param fun a function of at least one argument
-- @param ... will also be passed to the function
-- @return a table where the keys are the returned values, and the values are Lists
-- of values where the function returned that key. It is given the type of Multimap.
-- @see pl.MultiMap
function List:partition (fun,...)
    fun = function_arg(1,fun)
    local res = {}
    for i = 1,#self do
        local val = self[i]
        local klass = fun(val,...)
        if klass == nil then klass = '&lt;nil&gt;' end
        if not res[klass] then res[klass] = List() end
        res[klass]:append(val)
    end
    return setmetatable(res,Multimap)
end

--- return an iterator over all values.
function List:iter ()
    return iter(self)
end

--- Create an iterator over a seqence.
-- This captures the Python concept of 'sequence'.
-- For tables, iterates over all values with integer indices.
-- @param seq a sequence; a string (over characters), a table, a file object (over lines) or an iterator function
-- @usage for x in iterate {1,10,22,55} do io.write(x,',') end ==&gt; 1,10,22,55
-- @usage for ch in iterate 'help' do do io.write(ch,' ') end ==&gt; h e l p
function List.iterate(seq)
    if type(seq) == 'string' then
        local idx = 0
        local n = #seq
        local sub = string.sub
        return function ()
            idx = idx + 1
            if idx &gt; n then return nil
            else
                return sub(seq,idx,idx)
            end
        end
    elseif type(seq) == 'table' then
        local idx = 0
        local n = #seq
        return function()
            idx = idx + 1
            if idx &gt; n then return nil
            else
                return seq[idx]
            end
        end
    elseif type(seq) == 'function' then
        return seq
    elseif type(seq) == 'userdata' and io.type(seq) == 'file' then
        return seq:lines()
    end
end
iter = List.iterate

package.loaded['pl.List'] = List

</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Map</name>
					<packageName></packageName>
					<script>--- A Map class.
--
--    &gt; Map = require 'pl.Map'
--    &gt; m = Map{one=1,two=2}
--    &gt; m:update {three=3,four=4,two=20}
--    &gt; = m == M{one=1,two=20,three=3,four=4}
--    true
--
-- Dependencies: `pl.utils`, `pl.class`, `pl.tablex`, `pl.pretty`
-- @module pl.Map

local tablex = require 'pl.tablex'
local utils = require 'pl.utils'
local stdmt = utils.stdmt
local is_callable = utils.is_callable
local tmakeset,deepcompare,merge,keys,difference,tupdate = tablex.makeset,tablex.deepcompare,tablex.merge,tablex.keys,tablex.difference,tablex.update

local pretty_write = require 'pl.pretty' . write
local Map = stdmt.Map
local Set = stdmt.Set
local List = stdmt.List

local class = require 'pl.class'

-- the Map class ---------------------
class(nil,nil,Map)

local function makemap (m)
    return setmetatable(m,Map)
end

function Map:_init (t)
    local mt = getmetatable(t)
    if mt == Set or mt == Map then
        self:update(t)
    else
        return t -- otherwise assumed to be a map-like table
    end
end


local function makelist(t)
    return setmetatable(t,List)
end

--- list of keys.
Map.keys = tablex.keys

--- list of values.
Map.values = tablex.values

--- return an iterator over all key-value pairs.
function Map:iter ()
    return pairs(self)
end

--- return a List of all key-value pairs, sorted by the keys.
function Map:items()
    local ls = makelist(tablex.pairmap (function (k,v) return makelist {k,v} end, self))
	ls:sort(function(t1,t2) return t1[1] &lt; t2[1] end)
	return ls
end

-- Will return the existing value, or if it doesn't exist it will set
-- a default value and return it.
function Map:setdefault(key, defaultval)
   return self[key] or self:set(key,defaultval) or defaultval
end

--- size of map.
-- note: this is a relatively expensive operation!
-- @class function
-- @name Map:len
Map.len = tablex.size

--- put a value into the map.
-- @param key the key
-- @param val the value
function Map:set (key,val)
    self[key] = val
end

--- get a value from the map.
-- @param key the key
-- @return the value, or nil if not found.
function Map:get (key)
    return rawget(self,key)
end

local index_by = tablex.index_by

--- get a list of values indexed by a list of keys.
-- @param keys a list-like table of keys
-- @return a new list
function Map:getvalues (keys)
    return makelist(index_by(self,keys))
end

--- update the map using key/value pairs from another table.
-- @param table
-- @function Map:update
Map.update = tablex.update

function Map:__eq (m)
    -- note we explicitly ask deepcompare _not_ to use __eq!
    return deepcompare(self,m,true)
end

function Map:__tostring ()
    return pretty_write(self,'')
end

package.loaded['pl.Map'] = Map
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>OrderedMap</name>
					<packageName></packageName>
					<script>--- OrderedMap, a map which preserves ordering.
--
-- Derived from `pl.Map`.
--
-- Dependencies: `pl.utils`, `pl.tablex`, `pl.List`
-- @module pl.OrderedMap

local tablex = require 'pl.tablex'
local utils = require 'pl.utils'
local List = require 'pl.List'
local index_by,tsort,concat = tablex.index_by,table.sort,table.concat

local class = require 'pl.class'
local Map = require 'pl.Map'

local OrderedMap = class(Map)
OrderedMap._name = 'OrderedMap'

--- construct an OrderedMap.
-- Will throw an error if the argument is bad.
-- @param t optional initialization table, same as for @{OrderedMap:update}
function OrderedMap:_init (t)
    self._keys = List()
    if t then
        local map,err = self:update(t)
        if not map then error(err,2) end
    end
end

local assert_arg,raise = utils.assert_arg,utils.raise

--- update an OrderedMap using a table.
-- If the table is itself an OrderedMap, then its entries will be appended. &lt;br&gt;
-- if it s a table of the form &lt;code&gt;{{key1=val1},{key2=val2},...}&lt;/code&gt; these will be appended. &lt;br&gt;
-- Otherwise, it is assumed to be a map-like table, and order of extra entries is arbitrary.
-- @param t a table.
-- @return the map, or nil in case of error
-- @return the error message
function OrderedMap:update (t)
    assert_arg(1,t,'table')
    if OrderedMap:class_of(t) then
       for k,v in t:iter() do
           self:set(k,v)
       end
    elseif #t &gt; 0 then -- an array must contain {key=val} tables
       if type(t[1]) == 'table' then
           for _,pair in ipairs(t) do
               local key,value = next(pair)
               if not key then return raise 'empty pair initialization table' end
               self:set(key,value)
           end
       else
           return raise 'cannot use an array to initialize an OrderedMap'
       end
    else
       for k,v in pairs(t) do
           self:set(k,v)
       end
    end
   return self
end

--- set the key's value.   This key will be appended at the end of the map. &lt;br&gt;
-- If the value is nil, then the key is removed.
-- @param key the key
-- @param val the value
-- @return the map
function OrderedMap:set (key,val)
    if not self[key] and val ~= nil then -- ensure that keys are unique
       self._keys:append(key)
    elseif val == nil then -- removing a key-value pair
       self._keys:remove_value(key)
    end
    self[key] = val
    return self
end

--- insert a key/value pair before a given position.
-- Note: if the map already contains the key, then this effectively
-- moves the item to the new position by first removing at the old position.
-- Has no effect if the key does not exist and val is nil
-- @param pos a position starting at 1
-- @param key the key
-- @param val the value; if nil use the old value
function OrderedMap:insert (pos,key,val)
    local oldval = self[key]
    val = val or oldval
    if oldval then
        self._keys:remove_value(key)
    end
    if val then
        self._keys:insert(pos,key)
        self[key] = val
    end
    return self
end

--- return the keys in order.
-- (Not a copy!)
-- @return List
function OrderedMap:keys ()
    return self._keys
end

--- return the values in order.
-- this is relatively expensive.
-- @return List
function OrderedMap:values ()
    return List(index_by(self,self._keys))
end

--- sort the keys.
-- @param cmp a comparison function as for @{table.sort}
-- @return the map
function OrderedMap:sort (cmp)
    tsort(self._keys,cmp)
    return self
end

--- iterate over key-value pairs in order.
function OrderedMap:iter ()
    local i = 0
    local keys = self._keys
    local n,idx = #keys
    return function()
        i = i + 1
        if i &gt; #keys then return nil end
        idx = keys[i]
        return idx,self[idx]
    end
end

OrderedMap.__pairs = OrderedMap.iter

function OrderedMap:__tostring ()
    local res = {}
    for i,v in ipairs(self._keys) do
        local val = self[v]
        local vs = tostring(val)
        if type(val) ~= 'number' then
            vs = '"'..vs..'"'
        end
        res[i] = tostring(v)..'='..vs
    end
    return '{'..concat(res,',')..'}'
end

package.loaded['pl.OrderedMap'] = OrderedMap



</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>dir</name>
					<packageName></packageName>
					<script>--- Getting directory contents and matching them against wildcards.
--
-- Dependencies: `pl.utils`, `pl.path`, `pl.tablex`
--
-- Soft Dependencies: `alien`, `ffi` (either are used on Windows for copying/moving files)
-- @module pl.dir

local utils = require 'pl.utils'
local path = require 'pl.path'
local is_windows = path.is_windows
local tablex = require 'pl.tablex'
local ldir = path.dir
local chdir = path.chdir
local mkdir = path.mkdir
local rmdir = path.rmdir
local sub = string.sub
local os,pcall,ipairs,pairs,require,setmetatable,_G = os,pcall,ipairs,pairs,require,setmetatable,_G
local remove = os.remove
local append = table.insert
local wrap = coroutine.wrap
local yield = coroutine.yield
local assert_arg,assert_string,raise = utils.assert_arg,utils.assert_string,utils.raise
local List = utils.stdmt.List

local dir = {}

local function assert_dir (n,val)
    assert_arg(n,val,'string',path.isdir,'not a directory',4)
end

local function assert_file (n,val)
    assert_arg(n,val,'string',path.isfile,'not a file',4)
end

local function filemask(mask)
    mask = utils.escape(mask)
    return mask:gsub('%%%*','.+'):gsub('%%%?','.')..'$'
end

--- does the filename match the shell pattern?.
-- (cf. fnmatch.fnmatch in Python, 11.8)
-- @param file A file name
-- @param pattern A shell pattern
-- @return true or false
-- @raise file and pattern must be strings
function dir.fnmatch(file,pattern)
    assert_string(1,file)
    assert_string(2,pattern)
    return path.normcase(file):find(filemask(pattern)) ~= nil
end

--- return a list of all files which match the pattern.
-- (cf. fnmatch.filter in Python, 11.8)
-- @param files A table containing file names
-- @param pattern A shell pattern.
-- @return list of files
-- @raise file and pattern must be strings
function dir.filter(files,pattern)
    assert_arg(1,files,'table')
    assert_string(2,pattern)
    local res = {}
    local mask = filemask(pattern)
    for i,f in ipairs(files) do
        if f:find(mask) then append(res,f) end
    end
    return setmetatable(res,List)
end

local function _listfiles(dir,filemode,match)
    local res = {}
    local check = utils.choose(filemode,path.isfile,path.isdir)
    if not dir then dir = '.' end
    for f in ldir(dir) do
        if f ~= '.' and f ~= '..' then
            local p = path.join(dir,f)
            if check(p) and (not match or match(p)) then
                append(res,p)
            end
        end
    end
    return setmetatable(res,List)
end

--- return a list of all files in a directory which match the a shell pattern.
-- @param dir A directory. If not given, all files in current directory are returned.
-- @param mask  A shell pattern. If not given, all files are returned.
-- @return lsit of files
-- @raise dir and mask must be strings
function dir.getfiles(dir,mask)
    assert_dir(1,dir)
    if mask then assert_string(2,mask) end
    local match
    if mask then
        mask = filemask(mask)
        match = function(f)
            return f:find(mask)
        end
    end
    return _listfiles(dir,true,match)
end

--- return a list of all subdirectories of the directory.
-- @param dir A directory
-- @return a list of directories
-- @raise dir must be a string
function dir.getdirectories(dir)
    assert_dir(1,dir)
    return _listfiles(dir,false)
end

local function quote_argument (f)
    f = path.normcase(f)
    if f:find '%s' then
        return '"'..f..'"'
    else
        return f
    end
end


local alien,ffi,ffi_checked,CopyFile,MoveFile,GetLastError,win32_errors,cmd_tmpfile

local function execute_command(cmd,parms)
   if not cmd_tmpfile then cmd_tmpfile = path.tmpname () end
   local err = path.is_windows and ' &gt; ' or ' 2&gt; '
    cmd = cmd..' '..parms..err..cmd_tmpfile
    local ret = utils.execute(cmd)
    if not ret then
        return false,(utils.readfile(cmd_tmpfile):gsub('\n(.*)',''))
    else
        return true
    end
end

local function find_ffi_copyfile ()
    if not ffi_checked then
        ffi_checked = true
        local res
        res,alien = pcall(require,'alien')
        if not res then
            alien = nil
            res, ffi = pcall(require,'ffi')
        end
        if not res then
            ffi = nil
            return
        end
    else
        return
    end
    if alien then
        -- register the Win32 CopyFile and MoveFile functions
        local kernel = alien.load('kernel32.dll')
        CopyFile = kernel.CopyFileA
        CopyFile:types{'string','string','int',ret='int',abi='stdcall'}
        MoveFile = kernel.MoveFileA
        MoveFile:types{'string','string',ret='int',abi='stdcall'}
        GetLastError = kernel.GetLastError
        GetLastError:types{ret ='int', abi='stdcall'}
    elseif ffi then
        ffi.cdef [[
            int CopyFileA(const char *src, const char *dest, int iovr);
            int MoveFileA(const char *src, const char *dest);
            int GetLastError();
        ]]
        CopyFile = ffi.C.CopyFileA
        MoveFile = ffi.C.MoveFileA
        GetLastError = ffi.C.GetLastError
    end
    win32_errors = {
        ERROR_FILE_NOT_FOUND    =         2,
        ERROR_PATH_NOT_FOUND    =         3,
        ERROR_ACCESS_DENIED    =          5,
        ERROR_WRITE_PROTECT    =          19,
        ERROR_BAD_UNIT         =          20,
        ERROR_NOT_READY        =          21,
        ERROR_WRITE_FAULT      =          29,
        ERROR_READ_FAULT       =          30,
        ERROR_SHARING_VIOLATION =         32,
        ERROR_LOCK_VIOLATION    =         33,
        ERROR_HANDLE_DISK_FULL  =         39,
        ERROR_BAD_NETPATH       =         53,
        ERROR_NETWORK_BUSY      =         54,
        ERROR_DEV_NOT_EXIST     =         55,
        ERROR_FILE_EXISTS       =         80,
        ERROR_OPEN_FAILED       =         110,
        ERROR_INVALID_NAME      =         123,
        ERROR_BAD_PATHNAME      =         161,
        ERROR_ALREADY_EXISTS    =         183,
    }
end

local function two_arguments (f1,f2)
    return quote_argument(f1)..' '..quote_argument(f2)
end

local function file_op (is_copy,src,dest,flag)
    if flag == 1 and path.exists(dest) then
        return false,"cannot overwrite destination"
    end
    if is_windows then
        -- if we haven't tried to load Alien/LuaJIT FFI before, then do so
        find_ffi_copyfile()
        -- fallback if there's no Alien, just use DOS commands *shudder*
        -- 'rename' involves a copy and then deleting the source.
        if not CopyFile then
            src = path.normcase(src)
            dest = path.normcase(dest)
            local cmd = is_copy and 'copy' or 'rename'
            local res, err = execute_command('copy',two_arguments(src,dest))
            if not res then return nil,err end
            if not is_copy then
                return execute_command('del',quote_argument(src))
            end
        else
            if path.isdir(dest) then
                dest = path.join(dest,path.basename(src))
            end
			local ret
            if is_copy then ret = CopyFile(src,dest,flag)
            else ret = MoveFile(src,dest) end
            if ret == 0 then
                local err = GetLastError()
                for name,value in pairs(win32_errors) do
                    if value == err then return false,name end
                end
                return false,"Error #"..err
            else return true
            end
        end
    else -- for Unix, just use cp for now
        return execute_command(is_copy and 'cp' or 'mv',
            two_arguments(src,dest))
    end
end

--- copy a file.
-- @param src source file
-- @param dest destination file or directory
-- @param flag true if you want to force the copy (default)
-- @return true if operation succeeded
-- @raise src and dest must be strings
function dir.copyfile (src,dest,flag)
    assert_string(1,src)
    assert_string(2,dest)
    flag = flag==nil or flag
    return file_op(true,src,dest,flag and 0 or 1)
end

--- move a file.
-- @param src source file
-- @param dest destination file or directory
-- @return true if operation succeeded
-- @raise src and dest must be strings
function dir.movefile (src,dest)
    assert_string(1,src)
    assert_string(2,dest)
    return file_op(false,src,dest,0)
end

local function _dirfiles(dir,attrib)
    local dirs = {}
    local files = {}
    for f in ldir(dir) do
        if f ~= '.' and f ~= '..' then
            local p = path.join(dir,f)
            local mode = attrib(p,'mode')
            if mode=='directory' then
                append(dirs,f)
            else
                append(files,f)
            end
        end
    end
    return setmetatable(dirs,List),setmetatable(files,List)
end


local function _walker(root,bottom_up,attrib)
    local dirs,files = _dirfiles(root,attrib)
    if not bottom_up then yield(root,dirs,files) end
    for i,d in ipairs(dirs) do
        _walker(root..path.sep..d,bottom_up,attrib)
    end
    if bottom_up then yield(root,dirs,files) end
end

--- return an iterator which walks through a directory tree starting at root.
-- The iterator returns (root,dirs,files)
-- Note that dirs and files are lists of names (i.e. you must say path.join(root,d)
-- to get the actual full path)
-- If bottom_up is false (or not present), then the entries at the current level are returned
-- before we go deeper. This means that you can modify the returned list of directories before
-- continuing.
-- This is a clone of os.walk from the Python libraries.
-- @param root A starting directory
-- @param bottom_up False if we start listing entries immediately.
-- @param follow_links follow symbolic links
-- @return an iterator returning root,dirs,files
-- @raise root must be a string
function dir.walk(root,bottom_up,follow_links)
    assert_dir(1,root)
    local attrib
    if path.is_windows or not follow_links then
        attrib = path.attrib
    else
        attrib = path.link_attrib
    end
    return wrap(function () _walker(root,bottom_up,attrib) end)
end

--- remove a whole directory tree.
-- @param fullpath A directory path
-- @return true or nil
-- @return error if failed
-- @raise fullpath must be a string
function dir.rmtree(fullpath)
    assert_dir(1,fullpath)
    if path.islink(fullpath) then return false,'will not follow symlink' end
    for root,dirs,files in dir.walk(fullpath,true) do
        for i,f in ipairs(files) do
            remove(path.join(root,f))
        end
        rmdir(root)
    end
    return true
end

local dirpat
if path.is_windows then
    dirpat = '(.+)\\[^\\]+$'
else
    dirpat = '(.+)/[^/]+$'
end

local _makepath
function _makepath(p)
    -- windows root drive case
    if p:find '^%a:[\\]*$' then
        return true
    end
   if not path.isdir(p) then
    local subp = p:match(dirpat)
    if not _makepath(subp) then return raise ('cannot create '..subp) end
    return mkdir(p)
   else
    return true
   end
end

--- create a directory path.
-- This will create subdirectories as necessary!
-- @param p A directory path
-- @return a valid created path
-- @raise p must be a string
function dir.makepath (p)
    assert_string(1,p)
    return _makepath(path.normcase(path.abspath(p)))
end


--- clone a directory tree. Will always try to create a new directory structure
-- if necessary.
-- @param path1 the base path of the source tree
-- @param path2 the new base path for the destination
-- @param file_fun an optional function to apply on all files
-- @param verbose an optional boolean to control the verbosity of the output.
--  It can also be a logging function that behaves like print()
-- @return true, or nil
-- @return error message, or list of failed directory creations
-- @return list of failed file operations
-- @raise path1 and path2 must be strings
-- @usage clonetree('.','../backup',copyfile)
function dir.clonetree (path1,path2,file_fun,verbose)
    assert_string(1,path1)
    assert_string(2,path2)
    if verbose == true then verbose = print end
    local abspath,normcase,isdir,join = path.abspath,path.normcase,path.isdir,path.join
    local faildirs,failfiles = {},{}
    if not isdir(path1) then return raise 'source is not a valid directory' end
    path1 = abspath(normcase(path1))
    path2 = abspath(normcase(path2))
    if verbose then verbose('normalized:',path1,path2) end
    -- particularly NB that the new path isn't fully contained in the old path
    if path1 == path2 then return raise "paths are the same" end
    local i1,i2 = path2:find(path1,1,true)
    if i2 == #path1 and path2:sub(i2+1,i2+1) == path.sep then
        return raise 'destination is a subdirectory of the source'
    end
    local cp = path.common_prefix (path1,path2)
    local idx = #cp
    if idx == 0 then -- no common path, but watch out for Windows paths!
        if path1:sub(2,2) == ':' then idx = 3 end
    end
    for root,dirs,files in dir.walk(path1) do
        local opath = path2..root:sub(idx)
        if verbose then verbose('paths:',opath,root) end
        if not isdir(opath) then
            local ret = dir.makepath(opath)
            if not ret then append(faildirs,opath) end
            if verbose then verbose('creating:',opath,ret) end
        end
        if file_fun then
            for i,f in ipairs(files) do
                local p1 = join(root,f)
                local p2 = join(opath,f)
                local ret = file_fun(p1,p2)
                if not ret then append(failfiles,p2) end
                if verbose then
                    verbose('files:',p1,p2,ret)
                end
            end
        end
    end
    return true,faildirs,failfiles
end

--- return an iterator over all entries in a directory tree
-- @param d a directory
-- @return an iterator giving pathname and mode (true for dir, false otherwise)
-- @raise d must be a non-empty string
function dir.dirtree( d )
    assert( d and d ~= "", "directory parameter is missing or empty" )
    local exists, isdir = path.exists, path.isdir
    local sep = path.sep

    local last = sub ( d, -1 )
    if last == sep or last == '/' then
        d = sub( d, 1, -2 )
    end

    local function yieldtree( dir )
        for entry in ldir( dir ) do
            if entry ~= "." and entry ~= ".." then
                entry = dir .. sep .. entry
                if exists(entry) then  -- Just in case a symlink is broken.
                    local is_dir = isdir(entry)
                    yield( entry, is_dir )
                    if is_dir then
                        yieldtree( entry )
                    end
                end
            end
        end
    end

    return wrap( function() yieldtree( d ) end )
end


---	Recursively returns all the file starting at &lt;i&gt;path&lt;/i&gt;. It can optionally take a shell pattern and
--	only returns files that match &lt;i&gt;pattern&lt;/i&gt;. If a pattern is given it will do a case insensitive search.
--	@param start_path {string} A directory. If not given, all files in current directory are returned.
--	@param pattern {string} A shell pattern. If not given, all files are returned.
--	@return Table containing all the files found recursively starting at &lt;i&gt;path&lt;/i&gt; and filtered by &lt;i&gt;pattern&lt;/i&gt;.
--  @raise start_path must be a string
function dir.getallfiles( start_path, pattern )
    assert_dir(1,start_path)
    pattern = pattern or ""

    local files = {}
    local normcase = path.normcase
    for filename, mode in dir.dirtree( start_path ) do
        if not mode then
            local mask = filemask( pattern )
            if normcase(filename):find( mask ) then
                files[#files + 1] = filename
            end
        end
    end

    return files
end

package.loaded['pl.dir'] = dir
</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>config</name>
					<packageName></packageName>
					<script>--- Reads configuration files into a Lua table.
--  Understands INI files, classic Unix config files, and simple
-- delimited columns of values.
--
--    # test.config
--    # Read timeout in seconds
--    read.timeout=10
--    # Write timeout in seconds
--    write.timeout=5
--    #acceptable ports
--    ports = 1002,1003,1004
--
--    -- readconfig.lua
--    local config = require 'config'
--    local t = config.read 'test.config'
--    print(pretty.write(t))
--
--    ### output #####
--    {
--      ports = {
--        1002,
--        1003,
--        1004
--      },
--      write_timeout = 5,
--      read_timeout = 10
--    }
--
-- @module config

local type,tonumber,ipairs,io, table = _G.type,_G.tonumber,_G.ipairs,_G.io,_G.table

local function split(s,re)
    local res = {}
    local t_insert = table.insert
    re = '[^'..re..']+'
    for k in s:gmatch(re) do t_insert(res,k) end
    return res
end

local function strip(s)
    return s:gsub('^%s+',''):gsub('%s+$','')
end

local function strip_quotes (s)
    return s:gsub("['\"](.*)['\"]",'%1')
end

local config = {}

--- like io.lines(), but allows for lines to be continued with '\'.
-- @param file a file-like object (anything where read() returns the next line) or a filename.
-- Defaults to stardard input.
-- @return an iterator over the lines, or nil
-- @return error 'not a file-like object' or 'file is nil'
function config.lines(file)
    local f,openf,err
    local line = ''
    if type(file) == 'string' then
        f,err = io.open(file,'r')
        if not f then return nil,err end
        openf = true
    else
        f = file or io.stdin
        if not file.read then return nil, 'not a file-like object' end
    end
    if not f then return nil, 'file is nil' end
    return function()
        local l = f:read()
        while l do
            -- only for non-blank lines that don't begin with either ';' or '#'
            if l:match '%S' and not l:match '^%s*[;#]' then
                -- does the line end with '\'?
                local i = l:find '\\%s*$'
                if i then -- if so,
                    line = line..l:sub(1,i-1)
                elseif line == '' then
                    return l
                else
                    l = line..l
                    line = ''
                    return l
                end
            end
            l = f:read()
        end
        if openf then f:close() end
    end
end

--- read a configuration file into a table
-- @param file either a file-like object or a string, which must be a filename
-- @param cnfg a configuration table that may contain these fields:
-- &lt;ul&gt;
-- &lt;li&gt; variablilize make names into valid Lua identifiers (default true)&lt;/li&gt;
-- &lt;li&gt; convert_numbers try to convert values into numbers (default true)&lt;/li&gt;
-- &lt;li&gt; trim_space ensure that there is no starting or trailing whitespace with values (default true)&lt;/li&gt;
-- &lt;li&gt; trim_quotes remove quotes from strings (default false)&lt;/li&gt;
-- &lt;li&gt; list_delim delimiter to use when separating columns (default ',')&lt;/li&gt;
-- &lt;/ul&gt;
-- @return a table containing items, or nil
-- @return error message (same as @{config.lines}
function config.read(file,cnfg)
    local f,openf,err,auto

    local iter,err = config.lines(file)
    if not iter then return nil,err end
    local line = iter()
    cnfg = cnfg or {}
    if cnfg.smart then
        auto = true
        if line:match '^[^=]+=' then
            cnfg.keysep = '='
        elseif line:match '^[^:]+:' then
            cnfg.keysep = ':'
            cnfg.list_delim = ':'
        elseif line:match '^%S+%s+' then
            cnfg.keysep = ' '
            -- more than two columns assume that it's a space-delimited list
            -- cf /etc/fstab with /etc/ssh/ssh_config
            if line:match '^%S+%s+%S+%s+%S+' then
                cnfg.list_delim = ' '
            end
            cnfg.variabilize = false
        end
    end


    local function check_cnfg (var,def)
        local val = cnfg[var]
        if val == nil then return def else return val end
    end

    local initial_digits = '^[%d%+%-]'
    local t = {}
    local top_t = t
    local variablilize = check_cnfg ('variabilize',true)
    local list_delim = check_cnfg('list_delim',',')
    local convert_numbers = check_cnfg('convert_numbers',true)
    local trim_space = check_cnfg('trim_space',true)
    local trim_quotes = check_cnfg('trim_quotes',false)
    local ignore_assign = check_cnfg('ignore_assign',false)
    local keysep = check_cnfg('keysep','=')
    local keypat = keysep == ' ' and '%s+' or '%s*'..keysep..'%s*'
    if list_delim == ' ' then list_delim = '%s+' end

    local function process_name(key)
        if variablilize then
            key = key:gsub('[^%w]','_')
        end
        return key
    end

    local function process_value(value)
        if list_delim and value:find(list_delim) then
            value = split(value,list_delim)
            for i,v in ipairs(value) do
                value[i] = process_value(v)
            end
        elseif convert_numbers and value:find(initial_digits) then
            local val = tonumber(value)
            if not val and value:match ' kB$' then
                value = value:gsub(' kB','')
                val = tonumber(value)
            end
            if val then value = val end
        end
        if type(value) == 'string' then
           if trim_space then value = strip(value) end
           if not trim_quotes and auto and value:match '^"' then
                trim_quotes = true
            end
           if trim_quotes then value = strip_quotes(value) end
        end
        return value
    end

    while line do
        if line:find('^%[') then -- section!
            local section = process_name(line:match('%[([^%]]+)%]'))
            t = top_t
            t[section] = {}
            t = t[section]
        else
            line = line:gsub('^%s*','')
            local i1,i2 = line:find(keypat)
            if i1 and not ignore_assign then -- key,value assignment
                local key = process_name(line:sub(1,i1-1))
                local value = process_value(line:sub(i2+1))
                t[key] = value
            else -- a plain list of values...
                t[#t+1] = process_value(line)
            end
        end
        line = iter()
    end
    return top_t
end

package.loaded['pl.config'] = config

</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Event handlers</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>svo_events</name>
				<packageName></packageName>
				<script>function svo_events(...)
	local s,m = pcall(svo.events, ...)
	if not s then display(m) end
end</script>
				<eventHandlerList>
					<string>CharVitals</string>
					<string>CharName</string>
					<string>RoomNum</string>
					<string>RoomBrief</string>
					<string>sysDataSendRequest</string>
					<string>sysExitEvent</string>
					<string>mmapper updated pdb</string>
					<string>svo lost balance</string>
					<string>svo got balance</string>
					<string>svo prio changed</string>
					<string>svo system loaded</string>
					<string>svo config changed</string>
					<string>svo serverignore changed</string>
					<string>svo ignore changed</string>
					<string>svo defup changed</string>
					<string>svo keepup changed</string>
					<string>svo switched defence mode</string>
					<string>svo done defup</string>
					<string>NameDB finished honors</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo_gevents</name>
				<packageName></packageName>
				<script>function svo_gevents(...)
	local s,m = pcall(svo.gevents, ...)
	if not s then display(m) end
end</script>
				<eventHandlerList>
					<string>gmcp.Char</string>
					<string>gmcp.Room</string>
					<string>gmcp.Char.Status</string>
					<string>gmcp.IRE.Time</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.savesettings</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList>
					<string>sysExitEvent</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>svo Utilities</name>
			<packageName></packageName>
			<script>function svo.inslowcuringmode()
	return (svo.affl.retardation or svo.affl.aeon) and true or false
end

-- originally from Sidd, improved by Lynara
function svo.boxDisplay(msg, color)
    deselect()
    local colTbl = {}
    if color then
       colTbl = string.split(color, ":")
       for k = 1,2 do
          if colTbl[k] == "" then
             colTbl[k] = nil
          end
       end
       if colTbl[2] then
          bg(colTbl[2])
       end
    end
    colTbl[1] = colTbl[1] or "red"
    fg(colTbl[1])
	local leng = ((2*string.len(msg)) + 11)
	local mes = string.upper(msg)
	echo("\n ")
    echo( string.rep("-", leng+2) )
    echo(" \n|     " .. mes .. " | " .. mes .. "     |\n ")
    echo( string.rep("-", leng+2) )
    echo(" \n")
    resetFormat()
end

function svo.preattack()
  if svo.inslowcuringmode() then return end

  if svo.affl.prone then send'stand' end
end

function mapper_can_move()
  return (svo.bals.balance and svo.bals.equilibrium and svo.bals.rightarm and svo.bals.leftarm) and true or false
end

function svo.echotime(s, sameline)
  if not sameline then moveCursor(0, getLineNumber()-1) end
  moveCursor(#getCurrentLine(), getLineNumber())

  fg("dark_slate_gray")
  insertText(' ('..s..'s)')
  deselect()
  resetFormat()
  moveCursorEnd()
end

function svo.echoafftime(s, aff)
  if aff == "bleeding" and svo.conf.gagclot then return end

  if isPrompt() then
    moveCursor(0, getLineNumber()-1)
    moveCursor(#getCurrentLine(), getLineNumber())
  end

  deselect()
  fg("DarkGoldenrod")
  insertText(' ('..s..'s)')
  deselect()
  resetFormat()
  moveCursorEnd()
end

local function docc(...)
  local sendto, method
  if not svo.conf.ccto or svo.conf.ccto == 'pt' then sendto = "pt "
  elseif svo.conf.ccto == 'clt' then sendto = "clt "
  elseif svo.conf.ccto:find("^tell %w+") then sendto = "tell "..svo.conf.ccto:match("^tell (%w+)").." "
  elseif svo.conf.ccto == 'ot' then sendto = "ot "
  elseif svo.conf.ccto == 'army' then sendto = "art "
  elseif svo.conf.ccto == 'team' then sendto = "team "
  elseif svo.conf.ccto == 'echo' then method = svo.echof; sendto = ""
  else sendto = "clan "..svo.conf.ccto.." tell " end

  if not method then
    send(sendto .. string.format(...), false)
  else
    (method)(sendto .. string.format(...))
  end
end

function svo.ccnop(...)
  if svo.inslowcuringmode() then return end

  docc(...)
end

function svo.cc(...)
  if svo.conf.paused or svo.inslowcuringmode() then return end

  docc(...)
end

-- credit to: http://hci.iastate.edu/~rpavlik/downloads/vrjugglua/snapshot/share/vrjugglua/lua/string_ext.lua
function string.ordinalSuffix(n)
  n = math.mod (n, 100)
  local d = math.mod (n, 10)
  if d == 1 and n ~= 11 then
    return "st"
  elseif d == 2 and n ~= 12 then
    return "nd"
  elseif d == 3 and n ~= 13 then
    return "rd"
  else
    return "th"
  end
end

function svo.shipprompt()
--  selectCurrentLine() fg("chartreuse") deselect() resetFormat()

  svo.me.shippromptn = getLineCount()
end

-- shows memory use by Lua objects only
registerAnonymousEventHandler("svo system loaded", function()
  svo.adddefinition("@mem", "string.format('%0.2f', collectgarbage('count')/1024)")
end)

function svo.doubleRunToSend(...)
  local doubleClick = .4
  if not DoubleRunTimer then
    DoubleRunTimer = tempTimer(doubleClick,[[killTimer(DoubleRunTimer)
      DoubleRunTimer = nil
      DoubleRunCounter = nil
    ]])
  end
  if DoubleRunCounter then
    DoubleRunCounter = DoubleRunCounter + 1
  else
    DoubleRunCounter = 0
  end
  if DoubleRunCounter == 1 then
    sendAll({...})
  end
end

-- returns a list of affs that focus can get
function svo.getfocusableaffs()
  return table.n_intersection(svo.keystolist(svo.affl), svo.focuscurables)
end

-- starts the stopwatch which measures how long a balance was missing for
function svo.startbalancewatch(balance)
  svo.watch["bal_"..balance] = svo.watch["bal_"..balance] or createStopWatch()
  startStopWatch(svo.watch["bal_"..balance])
end

function svo.endbalancewatch(balance, sameline)
  if svo.watch["bal_"..balance] then
    local s = stopStopWatch(svo.watch["bal_"..balance])
    svo.stats["last"..balance] = s
    if svo.conf.showbaltimes then svo.echotime(s, sameline) end
  end
end

function svo.countbrokenlimbs()
  local affs = svo.affl

  local c = 0
  if affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm then c = c + 1 end
  if affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm then c = c + 1 end
  if affs.crippledleftleg or affs.mangledleftleg or affs.mutilatedleftleg then c = c + 1 end
  if affs.crippledrightleg or affs.mangledrightleg or affs.mutilatedrightleg then c = c + 1 end

  return c
end

function svo.countonlybrokenlimbs()
  local affs = svo.affl

  local c = 0
  if affs.crippledleftarm then c = c + 1 end
  if affs.crippledrightarm then c = c + 1 end
  if affs.crippledleftleg then c = c + 1 end
  if affs.crippledrightleg then c = c + 1 end
  return c
end

function svo.havefractures()
  local affs = svo.affl

  return affs.crackedribs or affs.skullfractures or affs.torntendons or affs.wristfractures
end</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Tree curing strats</name>
				<packageName></packageName>
				<script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.tree = svo.tree or {}

svo.tree.blackout = {
  desc = "Use tree to cure blackout",

  function () return svo.affl.blackout and not svo.ignore.blackout end
}

svo.tree.aeon = {
  desc = "Use tree to cure aeon when we have asthma or mucous",

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.tree.hardlock = {
  desc = "Use tree to cure hard locks (asthma, anorexia, slickness, and can't focus)",

  function ()

    return svo.me.locks.hard
  end
}

-- touch tree if we have 3+ limbs damaged and at least one of them is curable with tree
svo.tree.maybevivi = {
  desc = "Use tree in a situation when you might get vivisected",

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}

svo.tree.crippledandprone = {
  desc = "Use tree if prone and both legs are crippled",

  function ()
    local affs = svo.affl

    return (affs.crippledleftleg and not (affs.mangledleftleg or affs.mutilatedleftleg))
      and (affs.crippledrightleg and not (affs.mangledrightleg or affs.mutilatedrightleg)) and (affs.prone or not svo.bals.salve)
  end
}

svo.tree.getupfaster = {
  desc = "Use tree if prone, off salve balance, and a leg is crippled",

  function ()
    local affs = svo.affl

    return ((affs.crippledleftleg and not (affs.mangledleftleg or affs.mutilatedleftleg))
      or (affs.crippledrightleg and not (affs.mangledrightleg or affs.mutilatedrightleg))) and affs.prone and not svo.bals.salve
  end
}

svo.tree.curearmsfaster = {
  desc = "Use tree if both arms are crippled and you're off salve balance",

  function ()
    local affs = svo.affl

    return ((affs.crippledleftarm and not (affs.mangledleftarm or affs.mutilatedleftarm)) or (affs.crippledrightarm and not (affs.mangledrightarm or affs.mutilatedrightarm))) and not svo.bals.salve
  end
}

svo.tree.novoyriacure = {
  desc = "Use tree when you have voyria and no immunity/antigen for it",

  function ()
    return (svo.affl.voyria and ((svo.es_potions.elixir and svo.es_potions.elixir["an elixir of immunity"] and svo.es_potions.elixir["an elixir of immunity"].sips &lt;= 1)
      and (svo.es_potions.tonic and svo.es_potions.tonic["a tonic of antigen"] and svo.es_potions.tonic["a tonic of antigen"].sips &lt;= 1))
    )
  end
}

svo.tree.any2affs = {
  desc = "Use tree when we've got at least two tree-curable afflictions",

  function ()
    return #svo.gettreeableaffs() &gt;= 2
  end
}

svo.tree.any3affs = {
  desc = "Use tree when we've got at least three tree-curable afflictions",

  function ()
    return #svo.gettreeableaffs() &gt;= 3
  end
}

svo.tree.fractures = {
  desc = "Use tree you're got a fracture and are off sip balance",

  function ()
    return not svo.bals.sip and svo.havefractures()
  end
}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Restore curing strats</name>
				<packageName></packageName>
				<script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

--[[svo.restore.anylimb = {
  desc = "Use restore if any limb is crippled (useful for bashing without mending, for example)",
  function () return svo.affl.crippledleftleg or svo.affl.crippledrightleg
    or svo.affl.crippledrightarm or svo.affl.crippledleftarm
  end
}]]

svo.restore = svo.restore or {}

svo.restore.anyoneortwolimbs = {
  desc = "Use restore if one or two limbs are crippled (and no more), and you're off salve/tree balance",

  function ()
    local mangledormultilated = 0
    if svo.affl.mangledleftleg or svo.affl.mutilatedleftleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightleg or svo.affl.mutilatedrightleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightarm or svo.affl.mutilatedrightarm then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledleftarm or svo.affl.mutilatedleftarm then mangledormultilated = mangledormultilated + 1 end

    local crippled = svo.countonlybrokenlimbs()

    -- add mangled/mutilated limbs to count, so we don't exceed it
    -- don't go off on mangled/mutilated limbs only as well
    local total = mangledormultilated + crippled

    if crippled &gt; 0 and (total == 1 or total == 2) then return true end
  end
}


svo.restore.anyoneortwolimbsprone = {
  desc = "Use restore if one or two limbs are crippled (and no more), prone, and you're off salve/tree balance",

  function ()
    if not svo.affl.prone then return false end

    local mangledormultilated = 0
    if svo.affl.mangledleftleg or svo.affl.mutilatedleftleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightleg or svo.affl.mutilatedrightleg then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledrightarm or svo.affl.mutilatedrightarm then mangledormultilated = mangledormultilated + 1 end
    if svo.affl.mangledleftarm or svo.affl.mutilatedleftarm then mangledormultilated = mangledormultilated + 1 end

    local crippled = svo.countonlybrokenlimbs()

    -- add mangled/mutilated limbs to count, so we don't exceed it
    -- don't go off on mangled/mutilated limbs only as well
    local total = mangledormultilated + crippled

    if crippled &gt; 0 and (total == 1 or total == 2) then return true end
  end
}

svo.restore.riftlock = {
  desc = "Use restore on riftlocks",

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}


svo.restore.stainlock = {
  desc = "Use restore to cure stain locks (stain, slickness, broken arm and empty valerian/realgar pipe)",

  function ()
    return svo.me.locks.stain and (affs.crippledleftarm or affs.crippledrightarm) -- don't restore if we can't restore anything useful.
  end
}

-- restore if we have 3+ limbs damaged and at least one of them is curable with restore
svo.restore.maybevivi = {
  desc = "Use restore if you have 3+ limbs damaged and at least one of them is curable with restore",

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}
</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Dragonheal curing strats</name>
				<packageName></packageName>
				<script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.dragonheal = svo.dragonheal or {}

svo.dragonheal.riftlock = {
  desc = "Use dragonheal on riftlocks",

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}

svo.dragonheal.aeon = {
  desc = "Use dragonheal to cure aeon when we have asthma or mucous",

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.dragonheal.hardlock = {
  desc = "Use dragonheal to cure hard locks (asthma, anorexia, slickness, and can't focus)",

  function ()

    return svo.me.locks.hard
  end
}

svo.dragonheal.stainlock = {
  desc = "Use dragonheal to cure stain locks (stain, slickness, broken arm and empty valerian/realgar pipe)",

  function ()

    return svo.me.locks.stain
  end
}

-- dragonheal if we have 3+ limbs damaged and at least one of them is curable with dragonheal
svo.dragonheal.maybevivi = {
  desc = "Use dragonheal in a situation when you might get vivisected - if we have 3+ limbs damaged and at least one of them is curable with dragonheal",

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Shrugging curing strats</name>
				<packageName></packageName>
				<script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.shrugging = svo.shrugging or {}

-- desc should should assume it starts with 'Scenarios to use shrugging in:'
svo.shrugging.riftlock = {
  desc = "when you're riftlocked",

  function()
    local affs = svo.affl
    return (affs.asthma and (affs.slickness or svo.me.pipes.valerian.puffs &lt;= 0)
      and ((affs.crippledleftarm or affs.mangledleftarm or affs.mutilatedleftarm) and (affs.crippledrightarm or affs.mangledrightarm or affs.mutilatedrightarm))
      and not ((affs.mangledleftarm or affs.mutilatedleftarm) and (affs.mangledrightarm or affs.mutilatedrightarm))
    )
  end
}

svo.shrugging.aeon = {
  desc = "when we have aeon with asthma or mucous",

  function () return svo.affl.aeon and (svo.affl.asthma or svo.affl.mucous) end
}

svo.shrugging.hardlock = {
  desc = "when we have a hard lock (asthma, anorexia, slickness, and can't focus)",

  function ()
    return svo.me.locks.hard
  end
}

svo.shrugging.stainlock = {
  desc = "when we have a stain lock (stain, slickness, broken arm and empty valerian/realgar pipe)",

  function ()
    return svo.me.locks.stain
  end
}

svo.shrugging.any2affs = {
  desc = "when we've got at least two shruggable afflictions",

  function ()
    return #svo.gettreeableaffs() &gt;= 2
  end
}

svo.shrugging.any3affs = {
  desc = "when we've got at least three shruggable afflictions",

  function ()
    return #svo.gettreeableaffs() &gt;= 3
  end
}

-- shrugging if we have 3+ limbs damaged and at least one of them is curable with shrugging
svo.shrugging.maybevivi = {
  desc = "when you might get vivisected - if we have 3+ limbs damaged and at least one of them is curable with shrugging",

  function ()
    local affs = svo.affl

    if not (affs.crippledleftarm or affs.crippledrightarm or affs.crippledleftleg or affs.crippledrightleg)
      then return end

    return svo.countbrokenlimbs() &gt;= 3
  end
}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Rage curing strats</name>
				<packageName></packageName>
				<script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.rage = svo.rage or {}

svo.rage.any2affs = {
  desc = "Use rage when we've got at least two afflictions and one of them is rage-curable",

  function ()
    return table.size(svo.affl) &gt;= 2
  end
}

svo.rage.any3affs = {
  desc = "Use rage when we've got at least three afflictions and one of them is rage-curable",

  function ()
    return table.size(svo.affl) &gt;= 3
  end
}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Fitness curing strats</name>
				<packageName></packageName>
				<script>-- if you'd like to add your own strat: add it in another script outside Svo, so it stays upon an update.
-- make sure the script is either after the Svof one or it loads itself on the 'svo system loaded' event.
-- then just copy one of these strats and edit it! When you save it, it'll appear in the vconfig2 strat list.

-- to count how many affs you have in total, you can use: local affcount = table.size(svo.affl)

svo.fitness = svo.fitness or {}

svo.fitness.anylock = {
  desc = "Use fitness if we've got any locks we can use fitness to cure out of",

  function ()
    return (svo.me.locks.soft and not svo.doing"focus") or svo.me.locks.venom or svo.me.locks.hard or
            svo.me.locks.rift or svo.me.locks["rift 2"] or svo.me.locks.slow or svo.me.locks["true"]
  end
}

svo.fitness.asthmainaeon = {
  desc = "Use fitness if we've got asthma in aeon",

  function ()
    return svo.affl.asthma and svo.affl.aeon
  end
}

svo.fitness.hellsightconc = {
  desc = "Use fitness if we've got hellsight and a concussion",

  function ()
    return svo.affl.hellsight and (svo.affl.mildconcussion or svo.affl.seriousconcussion)
  end
}</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.isenemy</name>
				<packageName></packageName>
				<script>function svo.isenemy(name)
  return (target and target:lower():starts(name:lower())) or ndb.isenemy(name)
end</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Custom prompt tags</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>@affs</name>
					<packageName></packageName>
					<script>--[[ Iocuns prompt aff thingy from http://forums.achaea.com/index.php?showtopic=39543&amp;view=findpost&amp;p=1283964, taken with permission ]]
--[[ to use in a custom prompt, use the @paracelsus_affs_customtag tag ]]
--[[ this is now used by default in Svo ]]
local aff_abbrev = {
  ablaze              = "abl",
  addiction           = "add",
  aeon                = "ae",
  agoraphobia         = "agor",
  anorexia            = "ano",
  asleep              = "asl",
  asthma              = "ast",
  blackout            = "",
  bleeding            = "bld",
  blindaff            = "blind",
  bound               = "bound",
  burning             = "burn",
  calcifiedskull      = "calh",
  calcifiedtorso      = "calt",
  charredburn         = "4burn",
  cholerichumour      = "choH",
  claustrophobia      = "clau",
  clumsiness          = "cl",
  confusion           = "con",
  corrupted           = "corr",
  crackedribs         = "cr",
  crippledleftarm     = "la1",
  crippledleftleg     = "ll1",
  crippledrightarm    = "ra1",
  crippledrightleg    = "rl1",
  crushedthroat       = 'cru',
  darkshade           = "dark",
  deadening           = "dea",
  deafaff             = "deaf",
  degenerate          = "deg",
  dehydrated          = "deh",
  dementia            = "dem",
  depression          = "dep",
  deteriorate         = "det",
  disloyalty          = "disl",
  disrupt             = "disr",
  dissonance          = "disso",
  dizziness           = "diz",
  epilepsy            = "epi",
  extremeburn         = "3burn",
  fear                = "fear",
  frozen              = "frz",
  guilt               = 'gui',
  generosity          = "gen",
  haemophilia         = "haem",
  hallucinations      = "hall",
  hamstring           = "hms",
  hatred              = "htr",
  healthleech         = "hthl",
  heartseed           = "heart",
  hellsight           = "hell",
  hypersomnia         = "hypers",
  hypochondria        = "hypoch",
  icing               = "ice",
  illness             = "ill",
  impaled             = "impale",
  impatience          = "impat",
  justice             = "just",
  laceratedthroat     = "lac2",
  latched             = "latch",
  lethargy            = "let",
  loneliness          = "lon",
  lovers              = "lust",
  madness             = "mad",
  mangledleftarm      = "la2",
  mangledleftleg      = "ll2",
  mangledrightarm     = "ra2",
  mangledrightleg     = "rl2",
  masochism           = "maso",
  melancholichumour   = "melaH",
  meltingburn         = "5burn",
  mildconcussion      = "h1",
  mildtrauma          = "t1",
  mindravaged         = "ravg",
  mutilatedleftarm    = "la3",
  mutilatedleftleg    = "ll3",
  mutilatedrightarm   = "ra3",
  mutilatedrightleg   = "rl3",
  nausea              = "nau",
  ninkharsag          = "nkh",
  numbedleftarm       = "nbla",
  numbedrightarm      = "nbra",
  pacifism            = "pac",
  paradox             = "para",
  paralysis           = "par",
  paranoia            = "prn",
  parasite            = "prs",
  peace               = "pea",
  phlegmatichumour    = "phleH",
  phlogistication     = "phlog",
  pinshot             = "psh",
  pressure            = "pre",
  prone               = "pr",
  recklessness        = "reck",
  relapsing           = "scy",
  retardation         = "ret",
  retribution         = "reb",
  roped               = "rop",
  sanguinehumour      = "sanH",
  selarnia            = "sel",
  sensitivity         = "sen",
  seriousconcussion   = "h2",
  serioustrauma       = "t2",
  severeburn          = "2burn",
  shadowmadness       = "sham",
  shivering           = "shiv",
  shyness             = "shy",
  skullfractures      = "sf",
  slashedthroat       = "lac1",
  slickness           = "sli",
  spiritburn          = "sptb",
  stain               = "sta",
  stupidity           = "st",
  stuttering          = "stut",
  swellskin           = "swsk",
  tension             = "ten",
  tenderskin          = "tendr",
  timeflux            = "tfx",
  timeloop            = "tlp",
  torntendons         = "tt",
  transfixed          = "transf",
  unconsciousness     = "unconc",
  unknownany          = "?",
  unknowncrippledarm  = "uwna",
  unknowncrippledleg  = "uwnl",
  unknowncrippledlimb = "uwcrip",
  unknowncure         = "uc",
  unknownmental       = "?",
  unweavingbody       = "uwB",
  unweavingmind       = "uwM",
  unweavingspirit     = "uwS",
  vertigo             = "vert",
  vitrification       = "vitri",
  voided              = "void",
  voyria              = "voy",
  weakness            = "wea",
  webbed              = "web",
  wristfractures      = "wf",
}

-- recoded, it's quicker by a third
function paracelsus_affs_customtag2()
  if next(svo.affl) then
    local s, type = {}, type
    for k,v in pairs(svo.affl) do
        if (k == "unknownany" or k == "unknownmental") and (type(v) == 'table') then
          s[#s+1] = ("?"):rep(v.count)
        elseif k == "bleeding" and type(v) == 'table' then
          if v.count &gt;= svo.conf.bleedamount then
            s[#s+1] = string.format("bld(%d)", v.count)
          end
       elseif k == "lovers" and type(v) == 'table' then
          s[#s+1] = string.format("lust(%s)", svo.oneconcat(svo.affl.lovers.names))
        elseif type(v) == 'table' and v.count then
          s[#s+1] = (aff_abbrev[k] or k)..'('..v.count..')'
        else
          s[#s+1] = (aff_abbrev[k] or k)
        end
    end
    return #s &gt; 0 and ("&lt;IndianRed&gt;["..table.concat(s, " ").."]") or "" -- don't display just [] b/c of bleeding
  else
    return ""
  end
end

registerAnonymousEventHandler("svo system loaded", function()
  svo.adddefinition("@paracelsus_affs_customtag", "paracelsus_affs_customtag2()")
  svo.adddefinition("@affs", "paracelsus_affs_customtag2()")
  
  svo.adddefinition("@target", "target")
end)</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>@exits</name>
					<packageName></packageName>
					<script>svo.cpp = svo.cpp or {}

function svo.cpp.show_exits()
  if not (gmcp.Room and gmcp.Room.Info and gmcp.Room.Info.exits) then return "" end

  local list = svo.keystolist(gmcp.Room.Info.exits)
  table.sort(list)
  return table.concat(list, "|")
end


function svo.cpp.show_exits_caps()
  if not (gmcp.Room and gmcp.Room.Info and gmcp.Room.Info.exits) then return "" end

  local list = svo.keystolist(gmcp.Room.Info.exits)
  table.sort(list)
  return table.concat(list, "|"):upper()
end

registerAnonymousEventHandler("svo system loaded", function()
  svo.adddefinition("@exits", "svo.cpp.show_exits()")
  svo.adddefinition("@EXITS", "svo.cpp.show_exits_caps()")
end)</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>svo_autoslickprio</name>
				<packageName></packageName>
				<script>function svo_autoslickprio(_, balance)
  if not svo.conf.autoslick then return end
  if balance ~= 'herb' then return end
  if not (svo.affl.slickness and svo.affl.asthma) and not svo.swapped_asthma then return end

  -- see if we need to swap it back
  if svo.swapped_asthma then
    if not svo.affl.slickness or not svo.affl.asthma then
      -- all good now? undo change
      svo.prio_swap("asthma", "herb", svo.swapped_asthma)
      svo.swapped_asthma = nil
      echo'\n' svo.echof("Swapped asthma priority back down.")
      return
    end
  end

  -- don't have any more affs than this? Then asthma will get cured, so we're fine
  if table.size(svo.affl) &lt;= 2 then return end

  local asthma_prio = svo.prio.getnumber("asthma", "herb")
  local paralysis_prio = svo.prio.getnumber("paralysis", "herb")
  local impatience_prio = svo.prio.getnumber("impatience", "herb")

  -- see if it's not highest
  if asthma_prio &gt; paralysis_prio and asthma_prio &gt; impatience_prio then return end

  local currentmax = svo.prio.gethighest("herb")

  svo.prio_swap("asthma", "herb", currentmax+1)
  svo.swapped_asthma = asthma_prio
  echo'\n' svo.echof("emergency - have asthma+slickness and paralysis/impatience prio is before asthma: swapping asthma to be cured first.")
end</script>
				<eventHandlerList>
					<string>svo got balance</string>
					<string>svo lost aff</string>
					<string>svo got aff</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo_onimportant_aff</name>
				<packageName></packageName>
				<script>local bigboxaffs = {"serioustrauma", "mildtrauma", "mildconcussion", "seriousconcussion", "mutilatedleftarm", "mutilatedleftleg", "mutilatedrightarm", "mutilatedrightleg", "mangledleftarm", "mangledleftleg", "mangledrightarm", "mangledrightleg"}
local bigboxaffs_t = {}; for i = 1, #bigboxaffs do bigboxaffs_t[bigboxaffs[i]] = true end

function svo_onimportant_aff(_, which)
  if bigboxaffs_t[which] then
    svo.boxDisplay("afflicted w/ "..which, "black:DarkOrange")
  end
end</script>
				<eventHandlerList>
					<string>svo got aff</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.autopause_on_def</name>
				<packageName></packageName>
				<script>function svo.autopause_on_def(event, def)
  if (def == "blackwind" or def == "astralform") and event == "svo got def" then
    if svo.conf.paused then svo.dont_unpause_for_bw = true
    else svo.app("on") end
  elseif (def == "blackwind" or def == "astralform") and event == "svo lost def" then
    if not svo.dont_unpause_for_bw then svo.app("off") end
    svo.dont_unpause_for_bw = nil
  end
end</script>
				<eventHandlerList>
					<string>svo got def</string>
					<string>svo lost def</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.sitting</name>
				<packageName></packageName>
				<script>-- handles getting up after a manual sit
function svo.sitting(_, aff)
  if aff ~= "prone" then return end

  if svo.ignore.prone and svo.ignore.prone.because and svo.ignore.prone.because == "you sat down" then
    svo.ignore.prone = nil
    raiseEvent("svo ignore changed", "prone")
  end
end</script>
				<eventHandlerList>
					<string>svo lost aff</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.sleeping</name>
				<packageName></packageName>
				<script>-- handles unignoring sleeping after waking up
function svo.sleeping(_, aff)
  if aff ~= "sleep" then return end

  if svo.ignore.sleep and svo.ignore.sleep.because and svo.ignore.sleep.because == "you wanted to sleep" then
    svo.ignore.sleep = nil
  end
end</script>
				<eventHandlerList>
					<string>svo lost aff</string>
				</eventHandlerList>
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>svo Meteor Compress</name>
				<packageName></packageName>
				<script>function svo.updatemeteors()
  deleteLine()
  svo.prompttrigger("compress meteors", svo.showmeteors)
end

local function concatmap(tbl)
  local t = {}
  for k,v in pairs(tbl) do
    t[#t+1] = v.." on "..k
  end
  return svo.concatand(t)
end

function svo.showmeteors()
  local t = {}
  if svo.meteors.justlaunched then
    t[#t+1] = string.format("%d launched", svo.meteors.justlaunched)
  end
  if svo.meteors.justlaunchedmine then
    t[#t+1] = "plus your meteor"
  end
  if svo.meteors.headingin then
    t[#t+1] = string.format("%d heading to you", svo.meteors.headingin)
  end
  if svo.meteors.headingout then
    t[#t+1] = string.format("%d going elsewhere", svo.meteors.headingout)
  end
  if svo.meteors.brokeshield then
    t[#t+1] = svo.meteors.brokeshield.. " broke your shield"
  end
  if svo.meteors.hityou then
    t[#t+1] = string.format("%s hit you", svo.concatand(svo.meteors.hityou))
  end
  if svo.meteors.brokeshieldother then
    t[#t+1] = string.format("shield broke on: %s", concatmap(svo.meteors.brokeshieldother))
  end
  if svo.meteors.hitanother then
    t[#t+1] = string.format("meteors hit: %s", concatmap(svo.meteors.hitanother))
  end
  if svo.meteors.fellelsewhere then
    t[#t+1] = string.format("%d hit no-one", svo.meteors.fellelsewhere)
  end

  svo.echof("&lt;255,0,0&gt;meteors%s: %s", svo.getDefaultColor(), svo.concatand(t))
  svo.meteors = nil
end</script>
				<eventHandlerList />
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>commandTracker</name>
				<packageName></packageName>
				<script>lastCommands = lastCommands or {}

function commandTracker(_,what)
   local howMany = 5
   what = what:lower():gsub("^%s+","")
   table.insert(lastCommands, 1, what)
   table.remove(lastCommands, howMany+1)
end

function commandCheck(what)
   local found = false
   for k,v in ipairs(lastCommands) do
      if v:find(stupidityCheckTable[what]) then
         found = true
      end
   end
   return found
end

stupidityCheckTable = {
	["You waggle your eyebrows comically."]                                                                             = "^waggle",
	["You blink."]                                                                                                      = "^blink",
	["You twitch spasmodically."]                                                                                       = "^twitch",
	["As horrible thoughts fill your mind, you begin to sob uncontrollably."]                                           = "^sob",
	["You hug yourself compassionately."]                                                                               = "^hug",
	["My friend, clearly you know little of the sultry tango, if you think that you can perform it without a partner."] = "^tango",
	["Your mind is whirling with thoughts - you cannot settle down to sleep."]                                          = "^sleep",
	["You get down on one knee and serenade the world."]                                                                = "^serenade",
	["You make a strangled meowing noise and quickly shut up in embarrassment."]                                        = "^meow",
	["You burp obscenely."]                                                                                             = "^burp",
	["You flap your arms madly."]                                                                                       = "^flap",
	["You wouldn't want to drink a salve. It would not be tasty at all."]                                               = "^sip",
	["Tears fill your eyes and begin to slowly run down your face."]                                                    = "^cry",
	["You drop to one knee, demonstrating your humility and respect."]                                                  = "^kneel",
	["You pick your nose absently."]                                                                                    = "^picknose",
	["You wail like an old woman."]                                                                                     = "^wail",
	[ [[You grunt a bit and then let out a loud "OINK!"]] ]                                                             = "^oink",
	[ [[You let out a loud, long "MOOOOOOOOOOO!"]] ]                                                                    = "^moo",
	[ [["The voices! The voices! Get them out of my head!!" you moan, holding your head in pain.]] ]                    = "^voices",
	["You stumble and poke yourself in the eye."]                                                                       = "^poke",
	["Your mind is whirling with thoughts - you cannot settle down to sleep."]                                          = "^sleep",
}</script>
				<eventHandlerList>
					<string>sysDataSendRequest</string>
				</eventHandlerList>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Check for system updates</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>svo_downloaded_file</name>
				<packageName></packageName>
				<script>function svo_downloaded_file(_, filename)
  -- is the file that downloaded our oursystem?

  if filename == tostring(svo.versionfile) then
    svo.checkingupdates = false

    local s = io.open(filename):read("*a")
    if svo.version == s:trim() then
      if svo.announceupdates == "checking" then
        svo.announceupdates = nil
        svo.echof("You're all good! Latest version is %s and you're on it.", svo.version)
      end
      return
    end

    -- new version? See if we've already downloaded it, if not, do so
    local f = io.open(getMudletHomeDir().."/svo/downloads/available_version")

    local writtenversion

    -- new version file can not exist if we didn't download a system previously
    if f then
      writtenversion = f:read("*a")
    end

    if not writtenversion or writtenversion:trim() ~= s:trim() 
		  or not lfs.attributes(getMudletHomeDir().."/svo/downloads/".."Svof.current.zip") then
      if svo.announceupdates == "checking" then svo.echof("A new Svof is available! You're on %s, latest is %s. I'll download it for you.", svo.version, s:trim()) end
      svo.downloadnewsystem(s:trim())
    else
      if svo.announceupdates == "checking" then svo.echof("A new Svof is available and has been downloaded for you! You're on %s, latest is %s.", svo.version, s:trim()) end
      svo.showupdatereminder(writtenversion)
    end
  
  elseif filename:match("(svo \(.+\)\.xml)$") then
    local moduleName = filename:match("(svo \(.+\))\.xml$")
    downloadingModules = downloadingModules - 1
    svo.downloadedsystem[moduleName] = true
    if downloadingModules and downloadingModules ~= 0 then return end
    local dlDir = getMudletHomeDir() .. "/svo/downloads/"
    local installDir = getModulePath("svo (install me in module manager)") 
    installDir= installDir:sub(1, #installDir-38)
    for k in lfs.dir(installDir) do
      if k ~= "." and k ~= ".." then
        os.remove(installDir .. k)
      end
    end
    for k,v in pairs(svo.downloadedsystem) do 
      if v then
        os.rename(dlDir .. k .. ".xml", installDir .. k .. ".xml")
        reloadModule(k)
        svo.downloadedsystem[k] = nil
      end
    end
    svo.echof("New version installed and ready to go! Please restart mudlet to finalize cleanup.")
  end  
end</script>
				<eventHandlerList>
					<string>sysDownloadDone</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Check for updates</name>
				<packageName></packageName>
				<script>local downloadfolder = getMudletHomeDir().."/svo/downloads/"

-- this should get called at start and every hour after that
function svo.checkforupdate(type)
  local baseUrl = string.format("http://svof.github.io/svof/%s/", svo.conf.releasechannel)
 
	if svo.checkingupdates then return end
  svo.versionfile = downloadfolder.."svo_version"

  if not lfs.attributes(downloadfolder) then
     local t,s = lfs.mkdir(downloadfolder)
     if not t and s ~= "File exists" then svo.echof("Couldn't make the '"..downloadfolder.."' folder; "..s) return end
  end

  svo.checkingupdates = true
  downloadFile(svo.versionfile, baseUrl .. "current_version.txt")

  if type == "checking" then
    svo.echof("Checking for updates...")
    svo.announceupdates = "checking"
  elseif type == "force" then
    svo.echof("(re)downloading latest system...")
    svo.announceupdates = "force"
    svo.version = 0


    local location = getMudletHomeDir().."/svo/downloads/available_version"
    if io.exists(location) then
      local s,m = os.remove(location)
      if not s then svo.echof("Couldn't remove the %s file (error was: %s) - this might be a problem.", location, m) end
    end
    for k,v in pairs(svo.modules_list) do
      location = downloadfolder .. v .. ".xml"
      if io.exists(location) then
        local s,m = os.remove(location)
        if not s then svo.echof("Couldn't delete the old xml (located at %s), because of: %s. This might be a problem.", location, m) end
      end
    end
  else
    svo.announceupdates = nil
  end
end

-- downloads the system &amp; updates the system version saved
function svo.downloadnewsystem(newversion)
--  local baseUrl = string.format("http://svof.github.io/svof/%s/", svo.conf.releasechannel)
  local baseUrl = "https://github.com/svof/svof/raw/in-client-svof/"
	svo.downloadedsystem = svo.downloadedsystem or {}
  downloadingModules = 0
  if downloadTimer then killTimer(downloadTimer) end
  downloadTimer = tempTimer(10, "downloadingModules = nil killTimer(downloadTimer) downloadTimer = nil")
  -- also include base install file 
  local downloadUrl = baseUrl .. string.gsub("svo (install me in module manager)"," ", "%%20") .. ".xml"
  downloadFile(downloadfolder .. "svo (install me in module manager).xml", downloadUrl)
  svo.downloadedsystem["svo (install me in module manager)"] = false
  downloadingModules = downloadingModules + 1
  --download all the modules in the modules_list
  for k,v in pairs(svo.modules_list) do
    local downloadUrl = baseUrl .. v:gsub(" ", "%%20") .. ".xml"
    downloadFile(downloadfolder .. v .. ".xml", downloadUrl)
    svo.downloadedsystem[v] = false
    downloadingModules = downloadingModules + 1
  end
  
  svo.newdownloadedversion = newversion
end</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>svo_checkupdatestart</name>
					<packageName></packageName>
					<script>function svo_checkupdatestart()
  svo.checkforupdate("checking")
end</script>
					<eventHandlerList>
						<string>svo system loaded</string>
					</eventHandlerList>
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Update UI</name>
				<packageName></packageName>
				<script>function svo.showupdatereminder(newversion)
  svo.announceupdates = nil

  svo.updatelabel = svo.updatelabel or Geyser.Label:new({
    name = "svo.updatelabel",
    x = "-340px", y = "-115px",
    width = "320px", height = "110px",
  })

  svo.doupdatelabel = svo.doupdatelabel or Geyser.Label:new({
    name = "svo.doupdatelabel",
    x = "25%", y = "-30px",
    width = "20%", height = "20px",
  }, svo.updatelabel)

  svo.dontupdatelabel = svo.dontupdatelabel or Geyser.Label:new({
    name = "svo.dontupdatelabel",
    x = "55%", y = "-30px",
    width = "20%", height = "20px",
  }, svo.updatelabel)

  -- grey to black shade, top to bottom
  svo.updatelabel:setStyleSheet([[
      margin: 0px;
      padding: 2px;

      /* Vertical gradient */
      background: qlineargradient(
          x1: 0, y1: 0, x2: 0, y2: 1,
          stop: 0 #3c3c3c, stop: 1 #232323
      );

      border: none;
      border-radius: 4px;

      color: #ffffff;

    qproperty-alignment: 'AlignTop | AlignHCenter';
    qproperty-wordWrap: true;
    font-family: 'Ubuntu','Calibri',serif;
  ]])

  svo.doupdatelabel:setStyleSheet([[
    border-radius: 4px;
    border-style: double;
    border-width: 2px;
    border-color: green;
    font-family: monospace;
  ]])

  svo.dontupdatelabel:setStyleSheet([[
    border-radius: 4px;
    border-style: double;
    border-width: 2px;
    border-color: grey;
    font-family: monospace;
  ]])

  svo.updatelabel:echo(string.format([[&lt;p align="center" style="font-size:10pt; color:white"&gt;Hey, a new Svof (%s) has been downloaded and is available for install.&lt;br&gt;&lt;br&gt;Install and restart now, or install later?&lt;p&gt;]], newversion))

  svo.doupdatelabel:echo([[&lt;p align="center" style="font-size:8pt; color:white"&gt;Restart&lt;/p]])

  svo.dontupdatelabel:echo([[&lt;p align="center" style="font-size:8pt; color:white"&gt;Later&lt;/p]])

  svo.updatelabel:show()
  svo.doupdatelabel:show()
  svo.dontupdatelabel:show()

  svo.doupdatelabel:setClickCallback("svo_doupdate_click")
  svo.dontupdatelabel:setClickCallback("svo_dontupdate_click")
end

function svo_dontupdate_click()
  svo.updatelabel:hide()
  svo.doupdatelabel:hide()
  svo.dontupdatelabel:hide()
end

function svo_doupdate_click()
  svo.updatelabel:echo([[&lt;p align="center" style="font-size:10pt; color:white"&gt;Updating Svo...&lt;p&gt;]])
  svo.doupdatelabel:hide()
  svo.dontupdatelabel:hide()

  local class = svo.me.class

  if not io.exists(getMudletHomeDir().."/svo/downloads/Svof.current.zip") then
    svo.updatelabel:echo([[&lt;p align="center" style="font-size:10pt; color:white"&gt;Hm, can't update Svo - seems the new system we downloaded dissapeared. Do 'vupdate force' to download it again.&lt;p&gt;]])
    return
  end

  function svo_update_system()
    svo_updating_system = "uninstalling"
    svo.uninstall_all_modules()

    svo_updating_system = "installing"
    svo.updatelabel:echo([[&lt;p align="center" style="font-size:10pt; color:white"&gt;Uninstalled the old Svof, installing the new one now...&lt;p&gt;]])
    svo.install_from_zip(getMudletHomeDir().."/svo/downloads/Svof.current.zip")

    svo_updating_system = nil
    svo.echof("Svof updated! You can find the changelog on github.com/svof/svof/releases")

    svo.updatelabel:echo([[&lt;p align="center" style="font-size:10pt; color:white"&gt;Svo updated!&lt;p&gt;]])
    svo.updatelabel:setStyleSheet([[
        margin: 0px;
        padding: 2px;

        /* Vertical gradient */
        background: qlineargradient(
            x1: 0, y1: 0, x2: 0, y2: 1,
            stop: 0 #3c3c3c, stop: 1 #232323
        );

        border: none;
        border-radius: 4px;

        color: #ffffff;

      qproperty-alignment: 'AlignVCenter | AlignHCenter';
      qproperty-wordWrap: true;
      font-family: 'Ubuntu','Calibri',serif;
    ]])
		
		tempTimer(10, function() svo.updatelabel:hide() end)
  end

  svo_updating_system = "started"
  svo_update_system()
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Examples</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Use of got/lost aff/def events</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="no" isFolder="no">
					<name>svo_example_affs</name>
					<packageName></packageName>
					<script>-- Act on lost/gained affs
-- can be used, for example, to stop an instakill if you've gotten hindered - unpause system, unpause offense, etc.
-- must have vconfig eventaffs on
function svo_example_affs(eventname, data)
	svo.echof("Event: %s, data: %s", eventname, data)
--	tempTimer(0, function() svo.echof("Event: %s, data: %s", eventname, data) end)
end</script>
					<eventHandlerList>
						<string>svo got aff</string>
						<string>svo lost aff</string>
						<string>svo got def</string>
						<string>svo lost def</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>affs display window</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="no" isFolder="no">
					<name>svo_update_window</name>
					<packageName></packageName>
					<script>-- delete the line below and enable vconfig eventaffs plus this script for this demo to work!
if true or not Geyser then return end

local affslabel

local main = Geyser.Container:new({x=0,y=0,width="100%",height="100%",name="affslabelcontainer"})

affslabel = Geyser.Label:new({  name = "affslabel",
                               x = "87%", y = "80%",
                               width = "11%", height = "17%"},
                               main)
-- this sets the colour of the whole label to greenish
affslabel:setColor(100,155,0,127)

local function highlight(name)
	if not svo.ignore[name] then return name else
	return string.format([[&lt;span style="color:yellowgreen"&gt;%s&lt;/span&gt;]], name) end
end

function svo_update_window()
local s = {}
	if not affslabel then return end

	for name, namet in pairs(svo.affl) do
		if name ~= "deaf" and name ~= "blind" then
			if type(namet) == "table" and namet.count then
				s[#s+1] = string.format("%s (%d)", highlight(name), namet.count)
			else
				s[#s+1] = highlight(name)
			end
		end
	end
	affslabel:echo([[&lt;span style="color:white"&gt;]].. table.concat(s, "&lt;br&gt;") .."&lt;/span&gt;")
end</script>
					<eventHandlerList>
						<string>svo got aff</string>
						<string>svo lost aff</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
			<Script isActive="no" isFolder="no">
				<name>Customize_systems_echos</name>
				<packageName></packageName>
				<script>-- sample custom echo! Feel free to change the 'demo' name, so you can do 'vconfig echotype &lt;name&gt;'.

-- to edit this, mode this script outside of Svo - doesn't matter if it's before or after Svo scripts
-- then do 'vshow colors' to select your new colour scheme

-- this does take #'s for colours, not words - http://colorschemedesigner.com might help you in
-- selecting the hex colour code and then use http://www.yellowpipe.com/yis/tools/hex-to-rgb/color-converter.php
-- to convert it to the 3 RGB colours
function Customize_systems_echos()
if not (svo and svo.echos) then return end

-- this does the (svo): blah-style echoes
function svo.echos.demo(newline, what)
  decho("&lt;80,66,80&gt;(&lt;107,79,125&gt;svo&lt;80,66,80&gt;)&lt;87,85,89&gt;: &lt;159,128,180&gt;" .. what)
  if newline then echo"\n" end
end

-- this is the default color of the text in (svo): &lt;this colour here&gt;, so keep it consistent
-- with the last colour used above
function svo.echosd.demo()
  return "&lt;159,128,180&gt;"
end

end

-- this is so editing the scheme after loading works
Customize_systems_echos()</script>
				<eventHandlerList>
					<string>svo system loaded</string>
				</eventHandlerList>
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Display afflictions on prompt demo</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="no" isFolder="no">
					<name>mm_display_affs</name>
					<packageName></packageName>
					<script>-- just shows how to suffix affs to the prompt so you know

function mm_display_affs()
	-- put two dashes before the line below so this function will work!
	if true then return end

	-- this if/elseif chain will append one aff at a time only
	if svo.affl.prone then
		echo("[[PRONE]] ")
	elseif svo.affl.paralysis then
		echo("[[PARALYSIS]] ")
	elseif svo.affl.crippledleftleg then
		echo("[[CRIPPLED LEFTLEG]] ")
	end

	-- these stand-alone ifs will allow for several affs to be suffixed
	if svo.affl.crippledrightleg then
		echo("[[CRIPPLED RIGHT LEG]] ")
	end

	if svo.affl.tangled then
		echo("[[TANGLED]] ")
	end
end</script>
					<eventHandlerList>
						<string>svo done with prompt</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Show which affs you got/lost w/ times and count (by Lynara)</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="no" isFolder="no">
					<name>MyAffs</name>
					<packageName></packageName>
					<script>-- made by Lynara

svo.stopWatches = svo.stopWatches or {}
function MyAffs(eventname, data)
   local default = svo.getDefaultColor()
   if eventname == "svo got aff" then
      svo.stopWatches[data] = svo.affl[data] and svo.affl[data].sw or 0
      svo.echof("Got aff: &lt;0,210,0&gt;%s &lt;210,210,210&gt;(&lt;170,0,0&gt;%s%s affs&lt;210,210,210&gt;)", data, table.size(svo.affl), default )
   else
      svo.echof([[Lost aff: &lt;0,210,0&gt;%s &lt;210,210,210&gt;(&lt;0,210,0&gt;%s%ssec&lt;210,210,210&gt;) (&lt;170,0,0&gt;%s%s left&lt;210,210,210&gt;)]],
 data, getStopWatchTime(svo.stopWatches[data]), default, table.size(svo.affl), default)
   end
end</script>
					<eventHandlerList>
						<string>svo got aff</string>
						<string>svo lost aff</string>
					</eventHandlerList>
				</Script>
			</ScriptGroup>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>svo Time Tracking</name>
			<packageName></packageName>
			<script>svo.me = svo.me or {}
svo.me.time = svo.me.time or {
  h = 0, m = 0,
  tictimer = false,
  min2s = 2.5
}

function svo.sync_time(hour)
  svo.me.time.h, svo.me.time.m = hour, 0
  if svo.me.time.tictimer then killTimer(svo.me.time.tictimer) end

  svo.me.time.tictimer = tempTimer(svo.me.time.min2s - getNetworkLatency(), svo.tic_time)
end

function svo.tic_time()
  svo.me.time.m = svo.me.time.m + 1
  if svo.me.time.m &gt;= 60 then
    svo.me.time.h = svo.me.time.h + 1
    if svo.me.time.h &gt;= 24 then svo.me.time.h = 0 end

    svo.me.time.m = 0
  end

  svo.echof("It is now %.0d:%1d", svo.me.time.h, svo.me.time.m)
  svo.me.time.tictimer = tempTimer(svo.me.time.min2s, svo.tic_time)
end</script>
			<eventHandlerList />
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>svo Class Management</name>
			<packageName></packageName>
			<script>--[[ start of a class management (tn class/tn classonly) + class-specifics tricks ]]

svo.classes = {
  alchemist    = {fighting = false, skills = {"transmutation", "physiology", "alchemy"}},
  apostate     = {fighting = false, skills = {"evileye", "necromancy", "apostasy"}},
  bard         = {fighting = false, skills = {"voicecraft", "swashbuckling", "harmonics"}},
  blademaster  = {fighting = false, skills = {"twoarts", "striking", "shindo"}},
  depthswalker = {fighting = false, skills = {"shadowmancy", "aeonics", "terminus"}},
  dragon       = {fighting = false, skills = {"dragoncraft"}},
  druid        = {fighting = false, skills = {"groves", "metamorphosis", "concoctions"}},
	["earth elemental lord"] = {fighting = false, skills = {"sculpting"}},
  infernal     = {fighting = false, skills = {"necromancy", "chivalry", "forging"}},
  jester       = {fighting = false, skills = {"tarot", "pranks", "puppetry"}},
  magi         = {fighting = false, skills = {"elementalism", "crystalism", "enchantment"}},
  monk         = {fighting = false, skills = {"tekura", "kaido", "telepathy"}},
  occultist    = {fighting = false, skills = {"occultism", "tarot", "domination"}},
  paladin      = {fighting = false, skills = {"chivalry", "devotion", "forging"}},
  priest       = {fighting = false, skills = {"spirituality", "devotion", "zeal"}},
	psion        = {fighting = false, skills = {"weaving", "psionics", "emulation"}},
  runewarden   = {fighting = false, skills = {"runelore", "chivalry", "forging"}},
  sentinel     = {fighting = false, skills = {"metamorphosis", "woodlore", "concoctions"}},
  serpent      = {fighting = false, skills = {"subterfuge", "venom", "hypnosis"}},
  shaman       = {fighting = false, skills = {"spiritlore", "curses", "vodun"}},
  sylvan       = {fighting = false, skills = {"elementalism", "groves", "concoctions"}},
}
-- keeps track of what skills are actually enabled
svo.enabledskills, svo.enabledclasses = svo.enabledskills or {}, svo.enabledclasses or {}

-- this is used before we're actually sure that we're fighting a class and not illusions
svo.maybefighting = svo.maybefighting or {}

function svo.enableclass(class)
  if not svo.classes[class] or svo.enabledclasses[class] then return end

  for i = 1, #svo.classes[class].skills do
    local skill = svo.classes[class].skills[i]

    svo.enabledskills[skill] = (svo.enabledskills[skill] or 0) + 1
  end

  svo.enabledclasses[class] = true
  raiseEvent("svo enabled class", class)
end

function svo.disableclass(class)
  if not svo.classes[class] or not svo.enabledclasses[class] then return end

  for i = 1, #svo.classes[class].skills do
    local skill = svo.classes[class].skills[i]

    svo.enabledskills[skill] = (svo.enabledskills[skill] or 0) - 1
    if svo.enabledskills[skill] &lt;= 0 then svo.enabledskills[skill] = nil end
  end

  svo.enabledclasses[class] = nil
  raiseEvent("svo disabled class", class)
end

function svo.enableallclasses()
  for class in pairs(svo.classes) do
    svo.enableclass(class)
  end
end

function svo.disableallclasses()
  for class in pairs(svo.classes) do
    svo.disableclass(class)
  end
end

-- once a class is enabled, maybefighting shouldn't be added, but the timer renewed
function svo.startedfighting(class, name)
  svo.valid.gothit(class, name) -- check for **ILLUSION**s
end</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>svo_show_classes</name>
				<packageName></packageName>
				<script>function svo_show_classes()
  if not next(svo.enabledclasses) then svo.echof("No class tricks are enabled.") return end

  local l = svo.keystolist(svo.enabledclasses)
  table.sort(l)
  svo.echof("Enabled tricks for: %s", svo.concatand(l))
end</script>
				<eventHandlerList>
					<string>svo onshow</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.registerhit</name>
				<packageName></packageName>
				<script>function svo.registerhit(_, class, name)
  if not svo.classes[class] or not svo.conf.autoclasses then return end

  if not svo.enabledclasses[class] then
    svo.maybefighting[class] = (svo.maybefighting[class] or 0) + 1

    tempTimer(svo.conf.classattackswithin, function()
      if svo.maybefighting[class] then
        svo.maybefighting[class] = svo.maybefighting[class] - 1
        if svo.maybefighting[class] &lt;= 0 then
          svo.maybefighting[class] = nil
        end
      end
    end)
  end

  -- enable if we got attacked enough
  if svo.maybefighting[class] and svo.maybefighting[class] &gt;= svo.conf.classattacksamount and not svo.enabledclasses[class] then
    svo.enableclass(class)
    svo.prompttrigger("enabled "..class, function() svo.echof("Seems that we're fighting with %s - enabled class tricks.", string.title(class)) end)
  end

  -- start/renew timer
  if svo.classes[class].fighting then killTimer(svo.classes[class].fighting) end
  svo.classes[class].fighting = tempTimer(60*svo.conf.enableclassesfor, function()
    svo.classes[class].fighting = nil
    if not svo.enabledclasses[class] then return end

    svo.disableclass(class)
    if svo.stats.currenthealth ~= 0 then echo'\n' svo.echof("Don't think we're fighting with class %s anymore, disabled tricks.", string.title(class)) end
    svo.showprompt()
  end)
end</script>
				<eventHandlerList>
					<string>svo got hit by</string>
				</eventHandlerList>
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>svo UI Experiments</name>
			<packageName></packageName>
			<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>Enable Comm</name>
				<packageName></packageName>
				<script>function svo_enableCommChannel()
	-- register after GMCP is enabled. gmod doesn't re-register atm on restart
    sendGMCP([[Core.Supports.Add ["Comm.Channel 1"] ]])
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo_captureChats</name>
				<packageName></packageName>
				<script>-- magical chat capture that doesn't require any triggers!
-- made for Svo
svo.ui = svo.ui or {}

function svo_captureChats()
    if not svo.ui.chat then return end

    tempLineTrigger(0,1,[[
        if isPrompt() then return end
		selectCurrentLine()
		copy()

		if string.starts(line, "(Party)") then svo.ui.chat:Append("Party")
		else svo.ui.chat:Append("All") end
]])
end</script>
				<eventHandlerList>
					<string>gmcp.Comm.Channel.Start</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>Rift label dimensions</name>
				<packageName></packageName>
				<script>-- after editing this, do vshow herbstat to make it appear. To adjust the font size used, use vconfig herbstatsize #

-- if you'd like your changes to stay between Svo updates, move this script out of Svo's folder,
-- and make sure it is *after* Svo's folder after an update


svo.riftlabel = Geyser.Label:new({  name = "svo.riftlabel",
                               x = -360, y = -166,
                               width = 355, height = 166})

if not svo or not svo.conf or not svo.conf.riftlabel then svo.riftlabel:hide() end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>Load &amp; init</name>
			<packageName></packageName>
			<script>-- Controls the loading of the addon modules
svo.modules_list = {
    'svo (actions dictionary)',
    'svo (alias and defence functions)',
    'svo (curing skeleton, controllers, action system)',
    'svo (custom prompt, serverside, peopletracker)',
    'svo (install, config, pipes, rift, parry, prios)',
    'svo (setup, misc, empty, funnies, dor)',
    'svo (trigger functions)',
    'svo (aliases, triggers)',
    'svo (namedb)',
    'svo (elistsorter)',
    'svo (fishdist)',
    'svo (inker)',
    'svo (logger)',
    'svo (mindnet)',
    'svo (offering)',
    'svo (peopletracker)',
    'svo (reboundingsileristracker)',
    'svo (refiller)',
    'svo (runeidentifier)',
    'svo (stormhammertarget)',
    'svo (limbcounter)',
    'svo (burncounter)',
    'svo (priestreport)',
    'svo (enchanter)'

  }</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>svo_init_system</name>
				<packageName></packageName>
				<script>-- Svof consists of multiples Mudlet modules which need to be loaded in the correct order
-- (since a module can require functions already defined in another module)
-- this loader will load them in the correct order by calling the svo.loader.* function 
-- each file defines


-- Loads the system independent of the order of xmls/modules got installed within Mudlet
-- also used when the system needs to be reloaded with a new class
function svo_init_system()
  if svo.systemloaded then return end

  -- list of required Svof subsystems that need to be loaded before we can
	-- load everything else that starts on the 'svo.signals.systemstart' event
  local required_subsystems = {
    'setup',
    'misc',
    'empty',
    'dict',
    'sk',
    'controllers',
    'action',
    'pipes',
    'rift',
    'diag',
    'valid_simple',
    'valid_main',
    'config',
    'install',
    'aliases',
    'defences',
    'prio',
    'parry',
    'funnies',
    'dor',
    'customprompt',
    'serverside',
    'peopletracker',
  }
	
  -- addons that make use of the loader mechanism to load after the system is loaded
	local addons = {
	  'limbcounter',
		'priestreporter'
	}
	
	-- Penlight is not loaded yet	
	if not package.loaded['pl.tablex'] then return end
		
	local tablex = require('pl.tablex')
	local loaded_subsystems = tablex.keys(svo.loader)
	
	-- check if any of the required modules are missing
	if not table.is_empty(table.n_complement(required_subsystems, loaded_subsystems)) then
	  return
	end
	
	-- ensure Mudlet is new enough for the system to work without issues
	if not mudletOlderThan or mudletOlderThan(3,20) then
	  cecho("&lt;SkyBlue:firebrick&gt;Can't load Svof: your Mudlet is too old for the system to run well.\nPlease update to latest to enjoy it!\n")
		return
	end
	
	for _, subsystem in ipairs(required_subsystems) do
	  svo.loader[subsystem]()
	end

  svo.signals.systemstart:emit()
  svo.systemloaded = true
  raiseEvent("svo system loaded")
	
	-- if we're already logged in when the system is installed, initialise a few other things
	if gmcp and gmcp.Char and gmcp.Char.Name then
	  svo.signals.gmcpcharname:emit()
	end
	
  svo.echofn("Loaded &amp; ready to go, version %s (", tostring(svo.version))
  echoLink("homepage", 'openUrl"http://svof.github.io/svof"', "Svof homepage")
  decho(svo.getDefaultColor()..")\n")
	
	-- load any addons that wait for the system to load,
	-- plus ensure only the class-specific limbcounter is present
	for _, addon in ipairs(addons) do
	  if svo.loader[addon] then svo.loader[addon]() end
	end
	
	-- setup prompt stats on a reload
	if force_init then sendSocket("\n") end
end</script>
				<eventHandlerList>
					<string>sysLoadEvent</string>
					<string>sysInstall</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.classchange</name>
				<packageName></packageName>
				<script>function svo.classchange(override)
  local newclass = (override ~= "gmcp.Char.Status") and override or gmcp.Char.Status.class
	local temp_defs = {}
  
	-- if you're in an unrecognised class, use the None system
	if not svo.knownskills[newclass:lower()] then newclass = "None" end
		
	-- save general defences in temp table, so svo doesn't waste resources
	-- deffing what is already up	
  for k,v in pairs(svo.defc) do
    if v then
      if not svo.defs_data[k] then
        svo.defc[k] = nil
      else
        if svo.defs_data[k].type == "general" then
          temp_defs[k] = true
        end
      end
    end
  end
	
  if svo.me.class ~= newclass then
    local oldclass = svo.me.class
    
    -- kill temporary defense triggers for old class
    for k,v in pairs(svo.defencetemptriggers) do
      killTrigger(v)
    end
    svo.defencetemptriggers = {}
    svo.me.class = newclass
    svo.signals.saveconfig:emit()
		
		-- reset all serverside prios so serverside doesn't spam class-specific defences
		-- it's a bug in the game that serverside still tries to put up defences you can't
    svo.sk.resetserversideprios()
		
    svo.systemloaded = false; svo_init_system()
    
    for defname,v in pairs(temp_defs) do
      svo.defences.got(defname)
    end

    svo.echof("Changed your Svof from %s over to %s.", oldclass, svo.me.class)
    
		-- if system is not paused after dragonforming, unpause serverside
    if not svo.conf.paused then
      svo.app("off")
    end
  end
end</script>
				<eventHandlerList>
					<string>gmcp.Char.Status</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.install_other_modules</name>
				<packageName></packageName>
				<script>function svo.install_other_modules(_, installedmodule)
  if installedmodule ~= "svo (install me in module manager)" then return end
	
	local modules_list = svo.modules_list
	
	local current_module_name = 'svo (install me in module manager)'
	local basepath = getModulePath(current_module_name)
	-- -4 to account for the .xml ending
	basepath = basepath:sub(1, #basepath-#current_module_name-4)
	
	-- if Mudlet does not support syncModule(), ask the person to do it manually
	local warn_manual_sync
	
	-- install missing modules &amp; sync if Mudlet supports it
	for _, modulename in ipairs(modules_list) do
	  if not getModulePath(modulename) then
		  local modulepath = basepath..modulename..".xml"
			
			if io.exists(modulepath) then
  		  -- workaround for https://github.com/Mudlet/Mudlet/issues/1223
  			tempTimer(0, function()
				  installModule(basepath..modulename..".xml")
					if syncModule then
					  syncModule(modulename)
					else
					  if warn_manual_sync then killTimer(warn_manual_sync) end
					  warn_manual_sync = tempTimer(0, svo.ask_to_sync_manual)
					end
				end)
			end
		end
	end
	
	-- sync this module too
	if syncModule then syncModule('svo (install me in module manager)') end
end
svo.install_other_modules()

function svo.ask_to_sync_manual()
	cecho("\n&lt;dark_orchid&gt;Installed all modules - now make sure to tick 'sync' in the Module Manager for everything Svof!")
end</script>
				<eventHandlerList>
					<string>sysInstallModule</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.installed_as_package</name>
				<packageName></packageName>
				<script>function svo.installed_as_package(_, installedpackage)
  if not (installedpackage == "svo (install me in module manager)"
	  or installedpackage == "Svof - dont install me as package") then return end
	
	if svo_installed_as_package then killTimer(svo_installed_as_package) end
	svo_installed_as_package = tempTimer(0, function() cecho(
[[&lt;indian_red&gt;Svof needs to be installed as a module, not a package -
please uninstall it and instead install using the &lt;orange_red&gt;Module Manager&lt;indian_red&gt;!
]])
  svo_installed_as_package = nil
  end)
end</script>
				<eventHandlerList>
					<string>sysInstallPackage</string>
				</eventHandlerList>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.uninstall_all_modules</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
function svo.uninstall_all_modules()
  for _, modulename in ipairs(svo.modules_list) do
	  uninstallModule(modulename)
	end
	
	uninstallModule('svo (install me in module manager)')
	svo.systemloaded = nil
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>svo.install_from_zip</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
local templocation = getMudletHomeDir() .. "/svo/downloads/temp/"

-- deletedir credit: https://stackoverflow.com/a/43407750/72944
local deletedir =
  function(dir)
    for file in lfs.dir(dir) do
      local file_path = dir .. '/' .. file
      if file ~= "." and file ~= ".." then
        if lfs.attributes(file_path, 'mode') == 'file' then
          os.remove(file_path)
        elseif lfs.attributes(file_path, 'mode') == 'directory' then
          deletedir(file_path)
        end
      end
    end
    lfs.rmdir(dir)
  end

local function maketemplocation(location)
  if lfs.attributes(location) then
    deletedir(location)
  end
  return lfs.mkdir(location)
end

local function getmoduleslist(location)
  return svo.pl.dir.getfiles(location, "*.xml")
end

local function get_names_from_paths(locations, location)
	-- get a list of module names from their locations
	local modules_list = svo.pl.tablex.imap(string.sub, locations, #location+1)
	-- strip the final .xml as well
	modules_list = svo.pl.tablex.imap(string.sub, modules_list, 1, -5)
	return modules_list
end

function svo.install_all_modules_in(location)
  if not string.ends(location, '/') then
    location = location .. "/"
  end
  local modules_locations_list = getmoduleslist(location)
  local modules_list = get_names_from_paths(modules_locations_list, location)
  -- if Mudlet does not support syncModule(), ask the person to do it manually
  local warn_manual_sync
  -- install missing modules &amp; sync if Mudlet supports it
  for i, modulelocation in ipairs(modules_locations_list) do
    tempTimer(
      0,
      function()
        local s, m = installModule(modulelocation)
        if syncModule then
          syncModule(modules_list[i])
        else
          if warn_manual_sync then
            killTimer(warn_manual_sync)
          end
          warn_manual_sync = tempTimer(0, svo.ask_to_sync_manual)
        end
      end
    )
  end
end

function svo.install_from_zip(ziplocation)
  svo.signals.saveconfig:emit()
  -- check that zip is present
  if not io.exists(ziplocation) then
    return nil, "input file zip is missing"
  end
  -- create temporary location to extract zip into
  if not maketemplocation(templocation) then
    return nil, "couldn't create temporary download location"
  end
  -- extract zip into said temporary location
  unzip(ziplocation, templocation)
  -- install all modules
  svo.install_all_modules_in(templocation)
  -- delete temporary location
  deletedir(templocation)
  -- reset the loaded flag
  svo.systemloaded = nil
  -- happy times
  svo_init_system()
end</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
