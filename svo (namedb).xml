<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE MudletPackage>
<MudletPackage version="1.001">
	<TriggerPackage>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Data Capture</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Lists</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>NameDB cwho</name>
					<script>temp_name_list = {}
temp_dragon = 0
ndb.temp_classes_list = {}</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>100</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^Citizen\s+Rank\s+CT\s+Class$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Get name (cwho)</name>
						<script>resetFormat()
local match = getColorWildcard(14)

if match then
  local matches = multimatches[1]
  local isdragon
  if (matches[4] and matches[4]:lower():find("dragon")) then matches[4] = nil; isdragon = true end

  temp_name_list[#temp_name_list + 1] = {
    name = match[1],
    class = (matches[4] and matches[4]:lower()),
    city_rank = tonumber(matches[3]),
    city = gmcp.Char.Status.city:match("^(%w+)")
  }

  if isdragon then temp_name_list[#temp_name_list].dragon = 1 end

	-- if we know a class, add it in
	local class = ndb.getclass(match[1])
	local dragon
	if ndb.isdragon then dragon = ndb.isdragon(match[1]) end

	if class and class ~= "" then
		ndb.temp_classes_list[class] = (ndb.temp_classes_list[class] or 0) + 1
	if matches[4] and dragon  then cecho(" &lt;a_darkwhite&gt;(Dragon)") temp_dragon = temp_dragon +1 elseif dragon then cecho(" &lt;a_darkwhite&gt;("..class:title()..")") temp_dragon = temp_dragon +1 
	end end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^([A-Za-z].+)\s+(1|2|3|4|5|6)\s+(?:On|Off)\s+(.*)$</string>
							<string>return not isPrompt()</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>4</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stop getting (cwho)</name>
						<script>setTriggerStayOpen("NameDB cwho", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

if next(ndb.temp_classes_list) then
  local classes = svo.keystolist(ndb.temp_classes_list)
  table.sort(classes)

  for i = 1, #classes do
    classes[i] = ndb.temp_classes_list[classes[i]] .. " "..(ndb.temp_classes_list[classes[i]] == 1 and classes[i] or string.pluralize(classes[i]))
  end

  moveCursor(0, getLineNumber())
  svo.itf("%s present, of those %s %s dragon%s (%s total).\n", svo.concatand(classes), temp_dragon, (temp_dragon == 1 and 'is a' or 'are'), (temp_dragon == 1 and '' or 's'), #temp_name_list)
  moveCursorEnd()
  ndb.temp_classes_list = nil
end


temp_name_list = nil

raiseEvent("NameDB got new data")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^\d+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>NameDB hwho</name>
					<script>temp_name_list = {}</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>100</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Member              Rank      HTell  HNTell  Probation      Class</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Get name (hwho)</name>
						<script>if matches[3]:lower() == "dragon" then matches[3] = nil end

temp_name_list[#temp_name_list + 1] = {
  name = matches[2],
  class = (matches[3] and matches[3]:lower()),
  guild = ndb.findfromtable(gmcp.Char.Status.house, ndb.valid.houses)
}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(\w+)\s+(?:\* )?\d+\s+\w+\s+\w+\s+\w+\s+(\w+)$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stop getting (hwho)</name>
						<script>setTriggerStayOpen("NameDB hwho", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^\d+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Citizens</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>93</conditonLineDelta>
					<mStayOpen>999</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^The following are (?:IN)?ACTIVE citizens of (\w+)\:$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stop getting (citizens)</name>
						<script>setTriggerStayOpen("Citizens", 0)
stop_capturing = true


ndb.templist = {}
ndb.templist = string.split(ndb.tempnames, ",")

for i,k in pairs(ndb.templist) do
	ndb.templist[i] = k:trim()
end

-- last on name on list might have a dot
if string.sub(ndb.templist[#ndb.templist], -1, -1) == "." then
	ndb.templist[#ndb.templist] = string.sub(ndb.templist[#ndb.templist], 1, -2)
end

ndb.tempnames = nil

temp_name_list = {}

for i,j in ipairs(ndb.templist) do
	temp_name_list[#temp_name_list + 1] = {
		name = j,
		city = gmcp.Char.Status.city:match("^(%w+)")
	}
end

db:merge_unique(ndb.db.people, temp_name_list)

raiseEvent("NameDB got new data")

-- reload all highlights, as citizens list is big anyhow
ndb.loadhighlights()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Total:</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>2</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Save line</name>
						<script>if stop_capturing then stop_capturing = nil return end
if string.find(line, "The following are ACTIVE citizens of .*") then return end

if ndb.tempnames == nil then ndb.tempnames = "" end

ndb.tempnames = ndb.tempnames .. " " .. line
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>return true</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>4</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>House members</name>
					<script>temp_name_list = {}</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>999</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string> HR Stat Class      Name + Title</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Get name (house members)</name>
						<script>local match = getColorWildcard(14)

if match then
  if matches[2]:lower() == "dragon" then matches[2] = nil end

  temp_name_list[#temp_name_list + 1] = {
    name = match[1],
    class = ((matches[2] and ndb.isvalidclass(matches[2])) and matches[2]:lower() or ""),
    guild = ndb.findfromtable(gmcp.Char.Status.house, ndb.valid.houses)
  }
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^ *\d+(?: prob)? +(\w+)\s+.*$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stop getting (house members)</name>
						<script>setTriggerStayOpen("House members", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^\d+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Clan who</name>
					<script>temp_name_list = {}
temp_dragon = 0
ndb.temp_classes_list = {}</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>100</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The following members of the clan of </string>
						<string>are in the realms:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>0</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Get name (clan who)</name>
						<script>local match = getColorWildcard(14)

if match then
	local title = line:gsub(" %(off channel%)", "")

	temp_name_list[#temp_name_list + 1] = {
		name = match[1],
		title = title
	}

	-- if we know a class, add it in
	local class = ndb.getclass(match[1])
	local dragon
	if ndb.isdragon then dragon = ndb.isdragon(ndb.findname(line)) end

	if class and class ~= "" then
		class = class:title()
		echo((" "):rep(70-#line))
		cecho("&lt;a_darkwhite&gt;("..class..")")
		ndb.temp_classes_list[class] = (ndb.temp_classes_list[class] or 0) + 1
		if dragon then cecho(" &lt;a_darkwhite&gt;(Dragon)") temp_dragon = temp_dragon +1 end
	elseif dragon then echo((" "):rep(70-#line)) cecho("&lt;a_darkwhite&gt;(Dragon)") temp_dragon = temp_dragon +1 
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^</string>
							<string>return not isPrompt()</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>4</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stop (clan who)</name>
						<script>setTriggerStayOpen("Clan who", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

if next(ndb.temp_classes_list) then
  local classes = svo.keystolist(ndb.temp_classes_list)
  table.sort(classes)

  for i = 1, #classes do
    classes[i] = ndb.temp_classes_list[classes[i]] .. " "..(ndb.temp_classes_list[classes[i]] == 1 and classes[i] or string.pluralize(classes[i]))
  end

  moveCursor(0, getLineNumber())
  svo.itf("%s present, of those %s %s dragon%s (%s total).\n", svo.concatand(classes), temp_dragon, (temp_dragon == 1 and 'is a' or 'are'), (temp_dragon == 1 and '' or 's'), #temp_name_list)
  moveCursorEnd()
  ndb.temp_classes_list = nil
end

temp_name_list, temp_dragon = nil, nil

raiseEvent("NameDB got new data")
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string></string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>7</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Party who</name>
					<script>temp_name_list = {}
temp_dragon = 0
ndb.temp_classes_list = {}</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>100</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The following members of your party are in the realms:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Get name (party who)</name>
						<script>resetFormat()

local match = ndb.findname(line)
if match then
	temp_name_list[#temp_name_list + 1] = {
		name = ndb.findname(line),
		title = line
	}

	-- if we know a class, add it in
	local class = ndb.getclass(ndb.findname(line))
	local dragon
	if ndb.isdragon then dragon = ndb.isdragon(ndb.findname(line)) end

	if class and class ~= "" then
		echo((" "):rep(60-#line))
		cecho("&lt;a_darkwhite&gt;("..class:title()..")")
		ndb.temp_classes_list[class] = (ndb.temp_classes_list[class] or 0) + 1
		if dragon then cecho(" &lt;a_darkwhite&gt;(Dragon)") temp_dragon = temp_dragon +1 end
	elseif dragon then echo((" "):rep(60-#line)) cecho("&lt;a_darkwhite&gt;(Dragon)") temp_dragon = temp_dragon +1 
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^</string>
							<string>return not isPrompt()</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>4</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stop (party who)</name>
						<script>setTriggerStayOpen("Party who", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

if next(ndb.temp_classes_list) then
  local classes = svo.keystolist(ndb.temp_classes_list)
  table.sort(classes)

  for i = 1, #classes do
    classes[i] = ndb.temp_classes_list[classes[i]] .. " "..(ndb.temp_classes_list[classes[i]] == 1 and classes[i] or string.pluralize(classes[i]))
  end

  moveCursor(0, getLineNumber())
  svo.itf("%s present, of those %s %s dragon%s.\n", svo.concatand(classes), temp_dragon, (temp_dragon == 1 and 'is a' or 'are'), (temp_dragon == 1 and '' or 's'))
  moveCursorEnd()
  ndb.temp_classes_list = nil
end

temp_name_list, temp_dragon = nil, nil
raiseEvent("NameDB got new data")
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string></string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>7</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Order members</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>999</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The order has no mortal order head.</string>
						<string>Mortal order head:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>2</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Skip (order members)</name>
						<script>temp_name_list = {}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>3</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^</string>
							<string>3</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
							<integer>5</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Member</name>
							<script>if matches[2] == "Total" then return end

local class = line:sub(47):match("^(%w+)")
if class and class:lower() == "dragon" then class = nil end

temp_name_list[#temp_name_list + 1] = {
  name = matches[2],
  class = class,
  order = gmcp.Char.Status.order:match("(%w+)")
}</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>^([A-Za-z]+)\*?</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Stop (order members)</name>
							<script>setTriggerStayOpen("Order members", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

temp_name_list = nil

raiseEvent("NameDB got new data")</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string></string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>7</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>NameDB qw</name>
					<script>local data = string.split(line, ", ")

-- fix last name that ends with a dot
data[#data] = string.sub(data[#data], 1, #data[#data] - 1)

-- fix the 'and Name' from qw2
if data[#data]:starts("and ") then
  data[#data] = data[#data]:match("and (%w+)")
end

local city_colours = {
  ["0,255,0"] = "Eleusis",
  ["0,128,128"] = "Cyrene",
  ["255,0,0"] = "Mhaldor",
  ["128,128,0"] = "Hashan",
  ["128,0,128"] = "Ashtan",
  ["255,255,255"] = "Targossas"
}

temp_name_list = {}

local selectString, getFgColor, format = selectString, getFgColor, string.format


-- see if we can glean off city affiliation off qwc colours
for _, name in ipairs(data) do
  temp_name_list[#temp_name_list + 1] = {name = name}

  if selectString(name,1) &gt;= 0 then
    local r,g,b = getFgColor()
    local rgb = format("%d,%d,%d", r,g,b)
    if city_colours[rgb] then
      temp_name_list[#temp_name_list].city = city_colours[rgb]
    else
      temp_name_list[#temp_name_list].city = "rogue"
    end
    setFgColor(192,192,192)
    deselect()
  end

end
</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+),</string>
						<string>return not isPrompt()</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>4</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>NameDB qw</name>
					<script>local function commit()
  db:merge_unique(ndb.db.people, temp_name_list)

  for _, person in pairs(temp_name_list) do
    raiseEvent("NameDB saw list name", person.name)
  end

  raiseEvent("NameDB got new data")
end

-- ignore yourself gemmed offplane
if multimatches[1][1] == "None." then
  disableTrigger("NameDB qw")
  ndb.checkingqwi = nil
  commit()
  return
end



--[[
for _,name in ipairs(data) do
  -- check for guides, but ignore Gods, who show as (God)
  if name:find("(", 1, true) then
    local secondname
    name, secondname = name:match("(%w+)%((%w+)%)")
    if name and secondname then
      temp_name_list[#temp_name_list + 1] = {
        name = secondname
      }
 
      temp_name_list[#temp_name_list + 1] = {
        name = name
      } 
    end
  else
    -- add a plain name
    temp_name_list[#temp_name_list + 1] = {
      name = name
    }
  end
end
]]

-- re-honors if asked for
if ndb.qwtype and ndb.qwtype == "update" then
  for _, name in pairs(temp_name_list) do
    name.xp_rank = -1
  end

-- or organize by cities
elseif ndb.qwtype and ndb.qwtype == "organize cities" then
  local cities = {}

  local getcity = ndb.getcity
  for _, person in pairs(temp_name_list) do
    local city = getcity(person.name)

    city = city or "unknown"
    if city == "" then city = "rogue" end

    if ndb.isimmortal(person.name) then city = "Immortal" end
    
    cities[city] = cities[city] or {}
    cities[city][#cities[city]+1] = person.name
  end

  echo'\n\n'
  svo.echof("qw, sorted by members and count:")

  local sortbycount, longestcityname = {}, 0
  for city, members in pairs(cities) do
    sortbycount[city] = #members
    if #city &gt; longestcityname then longestcityname = #city end
  end

  local sortbycount = {}; for city in pairs(cities) do sortbycount[#sortbycount+1] = {city, #cities[city]} end
  table.sort(sortbycount, function(a, b)
    return a[2] &gt; b[2]
  end)

  for _, org in ipairs(sortbycount) do
    local city, members = org[1], cities[org[1]]
    table.sort(members)
    cecho(string.format("  &lt;royal_blue&gt;%-"..longestcityname.."s&lt;a_grey&gt; &lt;DarkSlateGrey&gt;(&lt;blaze_orange&gt;%d&lt;DarkSlateGrey&gt;): &lt;a_grey&gt;%s\n", city, #members, svo.concatand(members)))
  end

-- or report to cc
elseif ndb.qwtype and ndb.qwtype:starts("report members of ") then
  local org = ndb.qwtype:match("^report members of (%w+)"):lower()

  local citizens = {}
  for _, city in ipairs(ndb.valid.cities) do
    if city:lower():starts(org) then
      org = city

      for _, person in pairs(temp_name_list) do
        local persons_city = ndb.getcity(person.name)
        if persons_city == city then citizens[#citizens+1] = person.name end
      end

      break
    end
  end

  if not citizens[1] then echo'\n' svo.echof("No citizens of %s seem to be on.", org) return end

  table.sort(citizens)

  svo.cc("%s %s visible: %s", #citizens, ndb.getpluralcity(org, #citizens), svo.concatand(citizens))
elseif ndb.qwtype == "show marks" then
  local marks = {}
  for _, person in pairs(temp_name_list) do
    local mark = ndb.ismark(person.name)

    if mark then
      marks[mark] = marks[mark] or {}
      marks[mark][#marks[mark]+1] = person.name
    end
  end

  echo'\n\n'
  svo.echof("Marks:")
  if not next(marks) then svo.echof("(none found)") end
  for cat, people in pairs(marks) do
    table.sort(people)
    cecho(string.format("  %s: %s\n", cat:title(), svo.concatandf(people, ndb.getcolorn)))
  end

elseif ndb.qwtype == "show infamous" then
  local infamous = {}
  for _, person in pairs(temp_name_list) do
    local infamy = ndb.isinfamous(person.name)

    if infamy and infamy &gt;= 1 then
      infamous[infamy] = infamous[infamy] or {}
      infamous[infamy][#infamous[infamy]+1] = person.name
    end
  end

  echo'\n\n'
  svo.echof("Infamous:")
  if not next(infamous) then svo.echof("(none found)") end
  for cat, people in pairs(infamous) do
    table.sort(people)
    cecho(string.format("  %s: %s\n", ndb.valid.shortinfamous[cat], svo.concatandf(people, ndb.getcolorn)))
  end
end

commit()
disableTrigger("NameDB qw")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>1</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>.*</string>
						<string>1</string>
						<string>^(?:Plus another \d+ whose presence you cannot fully sense )?\(\d+ total\)\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>5</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>City/House/Order enemies</name>
					<script>local field
if multimatches[2][1]:find("City") then
  ndb.fixed_set(ndb.db.people.cityenemy, 0)
  field = "city"
elseif multimatches[2][1]:find("Order") then
  ndb.fixed_set(ndb.db.people.orderenemy, 0)
  field = "order"
else
  ndb.fixed_set(ndb.db.people.houseenemy, 0)
  field = "house"
end

local names = string.split(multimatches[4][1], ",")

for i = 1, #names do
  names[i] = names[i]:trim()
end

ndb.fixed_set(ndb.db.people[field.."enemy"], 1, db:in_(ndb.db.people.name, names))

-- reload all highlights
ndb.loadhighlights()

echo'\n'

if ndb.checkingenemies and ndb.checkingenemies.option then
  local temp_name_list = {}
  for i = 1, #names do
    temp_name_list[#temp_name_list + 1] = {
      name = names[i],
    }
  end

  db:merge_unique(ndb.db.people, temp_name_list)

  svo.echof(field:title().." enemies list updated, and new names added.")

  raiseEvent("NameDB got new data")
else
  svo.echof(field:title().." enemies list updated.")
end

disableTrigger("City/House/Order enemies")
if ndb.checkingenemies then killTimer(ndb.checkingenemies[1]) end
ndb.checkingenemies = nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>3</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#00b300</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Enemies of the </string>
						<string>ANSI_COLORS_F{002}_B{000}</string>
						<string>1</string>
						<string>.+</string>
						<string>1</string>
						<string>Total:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>6</integer>
						<integer>5</integer>
						<integer>1</integer>
						<integer>5</integer>
						<integer>2</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Birthdays list</name>
					<script>bdayTable = bdayTable or {}
bdayTable[#bdayTable+1] = matches[2]

svo.prompttrigger("namedb capture birtdhdays", function()
	local temp_name_list = {}

	for i,j in ipairs(bdayTable) do
		temp_name_list[#temp_name_list + 1] = {
			name = j
		}
	end

	db:merge_unique(ndb.db.people, temp_name_list)

	raiseEvent("NameDB got new data")
	bdayTable = nil
end)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) is \d+ years old today!$</string>
						<string>^The soul of (\w+) is \d+ years old today!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Friend Checking</name>
					<script>temp_name_list = {}
temp_dragon = 0
ndb.temp_classes_list = {}</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>100</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You have acknowledged the following adventurers as mutual friends:</string>
						<string>You have requested formal acknowledgement as friend from the following:</string>
						<string>You have no outstanding requests for formal acknowledgement of friendship.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Get name (Friend)</name>
						<script>local match = getColorWildcard(14)
line = line:trim()
if match then
	temp_name_list[#temp_name_list + 1] = {
		name = match[1],
		title = line
	}

	-- if we know a class, add it in
	local class = ndb.getclass(match[1])
	local dragon
	if ndb.isdragon then dragon = ndb.isdragon(ndb.findname(line)) end

	if class and class ~= "" then
		class = class:title()
		echo((" "):rep(70-#line))
		cecho("&lt;a_darkwhite&gt;("..class..")")
		ndb.temp_classes_list[class] = (ndb.temp_classes_list[class] or 0) + 1
		if dragon then cecho(" &lt;a_darkwhite&gt;(Dragon)") temp_dragon = temp_dragon +1 end
	elseif dragon then echo((" "):rep(60-#line)) cecho("&lt;a_darkwhite&gt;(Dragon)") temp_dragon = temp_dragon +1 
	end
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stop (friend who)</name>
						<script>setTriggerStayOpen("Friend Checking", 0)

db:merge_unique(ndb.db.people, temp_name_list)

for _, person in pairs(temp_name_list) do
  raiseEvent("NameDB saw list name", person.name)
end

if next(ndb.temp_classes_list) then
  local classes = svo.keystolist(ndb.temp_classes_list)
  table.sort(classes)

  for i = 1, #classes do
    classes[i] = ndb.temp_classes_list[classes[i]] .. " "..(ndb.temp_classes_list[classes[i]] == 1 and classes[i] or string.pluralize(classes[i]))
  end

  moveCursor(0, getLineNumber())
  svo.itf("%s present, of those %s %s dragon%s (%s total).\n", svo.concatand(classes), temp_dragon, (temp_dragon == 1 and 'is a' or 'are'), (temp_dragon == 1 and '' or 's'), #temp_name_list)
  moveCursorEnd()
  ndb.temp_classes_list = nil
end

temp_name_list, temp_dragon = nil, nil

raiseEvent("NameDB got new data")
</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string></string>
							<string>See FRIENDS R[EQUESTS] to see outstanding requests to or from you.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>7</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Clan Position Start</name>
					<script></script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>99</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>The leadership positions are:</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Clan Position Name</name>
						<script>setTriggerStayOpen("Clan Position Name",99)
setTriggerStayOpen("Clan Position Start",99)</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>99</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#0000ff</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>ANSI_COLORS_F{012}_B{000}</string>
							<string>.+</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>6</integer>
							<integer>1</integer>
						</regexCodePropertyList>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="yes" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>People In Position</name>
							<script>if not clanNames then 
   clanNames = multimatches[2][2]:gsub(",? and ", ", ")
else
   clanNames = clanNames .. " " .. multimatches[2][2]:gsub(",? and ", ", ")
end

setTriggerStayOpen("Clan Position Name",99)
setTriggerStayOpen("Clan Position Start",99)</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#c0c0c0</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>ANSI_COLORS_F{007}_B{000}</string>
								<string>^   (.+)$</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>6</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
						<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
							<name>Close Clan Positions</name>
							<script>setTriggerStayOpen("Clan Position Name",0)
setTriggerStayOpen("Clan Position Start",0)

clanNames = string.split(clanNames, ",? ")
local clan_name_list = {}
local added = {}
for k,v in pairs(clanNames) do 
  if not added[v] then
     clan_name_list[#clan_name_list+1] = {name = v}
  end
  added[v] = true
end
db:merge_unique(ndb.db.people, clan_name_list)
raiseEvent("NameDB got new data")
clanNames = nil</script>
							<triggerType>0</triggerType>
							<conditonLineDelta>0</conditonLineDelta>
							<mStayOpen>0</mStayOpen>
							<mCommand></mCommand>
							<packageName></packageName>
							<mFgColor>#ff0000</mFgColor>
							<mBgColor>#ffff00</mBgColor>
							<mSoundFile></mSoundFile>
							<colorTriggerFgColor>#000000</colorTriggerFgColor>
							<colorTriggerBgColor>#000000</colorTriggerBgColor>
							<regexCodeList>
								<string>There are </string>
								<string>^There are \d+ active members in this clan.</string>
							</regexCodeList>
							<regexCodePropertyList>
								<integer>2</integer>
								<integer>1</integer>
							</regexCodePropertyList>
						</Trigger>
					</Trigger>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Various common things</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Channel history</name>
					<script>ndb.temp_name_list = {}

-- atm, this breaks the 'more' itself. Should add a delayed timer. Until then, getting names off channel history is disabled</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>1000</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>Channel History for</string>
						<string>[File continued via MORE]</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>3</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>A line</name>
						<script>ndb.temp_name_list[#ndb.temp_name_list + 1] = {
  name = matches[2]
}</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^- .+? - ([A-Za-z]+)</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>End (channel history)</name>
						<script>setTriggerStayOpen("Channel history", 0)

db:merge_unique(ndb.db.people, ndb.temp_name_list)

ndb.temp_name_list = nil

raiseEvent("NameDB got new data")</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string></string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>7</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Newbie spawned - house newcomers</name>
					<script>local temp_name_list = temp_name_list or {}

temp_name_list[#temp_name_list + 1] = {
  name = multimatches[2][2],
  class = ndb.isvalidclass(multimatches[2][3]) and multimatches[2][3]:lower() or "",
  city = ndb.isvalidcity(multimatches[2][4]) and multimatches[2][4]:title() or ""
}

db:merge_unique(ndb.db.people, temp_name_list)

raiseEvent("NameDB got new data")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>(House Newcomers):</string>
						<string>^\(House Newcomers\): (\w+) is a new (\w+) of (\w+)\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Newbie spawned - reborn</name>
					<script>local temp_name_list = { {name = matches[2], xp_rank = -1} }

db:merge_unique(ndb.db.people, temp_name_list)

raiseEvent("NameDB got new data")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+) has been Reborn in the Flame!$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Citizened a person</name>
					<script>local name = multimatches[2][2]

db:merge_unique(ndb.db.people, {{
  name = name,
  city = gmcp.Char.Status.city:match("^(%w+)"),
  city_rank = 1,
}})

raiseEvent("NameDB got new data")</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>You ask</string>
						<string>^You ask (\w+) to repeat the oaths of citizenship after you\. (?:He|She) does, and you admit (?:him|her) as the newest, proudest member of (\w+)\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>2</integer>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
			<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Honors on a person</name>
				<script></script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList />
				<regexCodePropertyList />
				<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Honors</name>
					<script>if ndb.honorsid then killTimer(ndb.honorsid) end

local pronoun = line:match("^(%w+)")

ndb.getinfo(ndb.honorsname)

temp_name_list = {}
temp_name_list[1] = {name = ndb.honorsname, city = "", city_rank = 0, dragon = 0,
  guild = "", gender = (pronoun == "He" or pronoun == "His") and 'male' or 'female',
  mark = "",
}

moveCursorEnd() -- make sure the cursor is at the current line

local foundname
local startline = getLineNumber()
for i = 1, 10 do -- word wrapping can mess it up, go so back a fair bit in case of small screen

  -- work backwards until the line with the name is located
  if string.find(getCurrentLine(), "%f[%a]"..ndb.honorsname.."%f[%A]") then
    -- pick up the race as it is listed
    local race = getCurrentLine():match("%(male (.-)%)") or getCurrentLine():match("%(female (.-)%)") or ""

    local occultist = race:match("Chaos .- resembling a (%a+)")
    if occultist then
      race = occultist
      temp_name_list[1].class = "occultist"
    end
    local sylvan = race:match("Viridian (%a+)")
    if sylvan then
      race = sylvan
      temp_name_list[1].class = "sylvan"
    end

    if ndb.isvalidrace(race) then
      temp_name_list[1].race = race:lower()
    elseif race:find("Dragon") then
      temp_name_list[1].dragon = 1
    end

    foundname = true
    break
  end
  if ndb.gaghonours then deleteLine() end
  moveCursor(0, startline-i)
end

-- failsafe for ndb update all messing up - in case we didn't find the name, don't capture any data
if not foundname then
  setTriggerStayOpen("Honors", 0)
  disableTrigger("Honors")
  local gaghonours = ndb.gaghonours
  ndb.honorsid, ndb.gaghonours = nil, nil

  raiseEvent("NameDB finished honors", temp_name_list[1].name, (gaghonours and "quiet" or "manual"))

  temp_name_list = nil
end

moveCursorEnd()</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>100</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(?:H|Sh)e is \d+ years old,</string>
						<string>His date of birth is hidden by the sand of Aeon.</string>
						<string>Her date of birth is hidden by the sand of Aeon.</string>
						<string>He was born before the fall of the Seleucarian Empire.</string>
						<string>She was born before the fall of the Seleucarian Empire.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Stop getting (honors)</name>
						<script>setTriggerStayOpen("Honors", 0)
disableTrigger("Honors")

if not temp_name_list then return end

if ndb.gaghonours then
  if ndb.honorseqgag then killTrigger(ndb.honorseqgag) end
  ndb.honorseqgag = tempExactMatchTrigger("You have recovered equilibrium.", [[svo.deleteLineP(); killTrigger(ndb.honorseqgag); ndb.honorseqgag = nil]])
  deleteLine()
end

temp_name_list[1].combat_rank = temp_name_list[1].combat_rank or 0
temp_name_list[1].combat_rating = temp_name_list[1].combat_rating or 0
temp_name_list[1].city_soldier = temp_name_list[1].city_soldier or 0
temp_name_list[1].motto = temp_name_list[1].motto or ""
temp_name_list[1].warcry = temp_name_list[1].warcry or ""

db:merge_unique(ndb.db.people, temp_name_list)

local gaghonours = ndb.gaghonours
ndb.honorsid, ndb.gaghonours = nil, nil

raiseEvent("NameDB finished honors", temp_name_list[1].name, (gaghonours and "quiet" or "manual"))

temp_name_list = nil</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string></string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>7</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Age</name>
						<script>if not temp_name_list then return end

temp_name_list[1].birth_day = tonumber(matches[3])
temp_name_list[1].birth_month = ndb.valid.months[matches[4]]
temp_name_list[1].birth_year = tonumber(matches[5])
temp_name_list[1].birth_hidden = 0</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:H|Sh)e is (\d+) years old, having been born on the (\d+)(?:st|nd|rd|th) of (Sarapin|Daedalan|Aeguary|Miraman|Scarlatan|Ero|Valnuary|Lupar|Phaestian|Chronos|Glacian|Mayan), (\d+) years after the fall of the Seleucarian Empire\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Age hidden</name>
						<script>if not temp_name_list then return end

temp_name_list[1].birth_hidden = 1</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>His date of birth is hidden by the sand of Aeon.</string>
							<string>Her date of birth is hidden by the sand of Aeon.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>XP rank</name>
						<script>if not temp_name_list then return end

temp_name_list[1].xp_rank = tonumber(matches[2])

-- 200 is a safe amount to set it at, as the number will vary
if tonumber(matches[2]) &lt; 240 then temp_name_list[1].dragon = 1 end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:She|He) is ranked (\d+)\w+ in Achaea\.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Unranked</name>
						<script>if not temp_name_list then return end

temp_name_list[1].xp_rank = -2</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>He is unranked in Achaea.</string>
							<string>She is unranked in Achaea.</string>
							<string>He has given up the adventuring life.</string>
							<string>She has given up the adventuring life.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Combat rank</name>
						<script>if not temp_name_list then return end

temp_name_list[1].combat_rank = tonumber(matches[2])
temp_name_list[1].combat_rating = tonumber(matches[3])</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:H|Sh)e is the (\d+)(?:st|nd|rd|th) ranked combatant with a rating of (\d+)\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>City &amp; rank</name>
						<script>if not temp_name_list then return end

temp_name_list[1].city_rank = ndb.getrankincity(matches[3], matches[2])
temp_name_list[1].city = matches[3]</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:She|He) is an? (\w+) in (\w+)\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>City soldier</name>
						<script>if not temp_name_list then return end

temp_name_list[1].city_soldier = -2</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:H|Sh)e is .+ in the army of (?:Ashtan|Cyrene|Eleusis|Hashan|Mhaldor|Targossas)\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Housemate</name>
						<script>if not temp_name_list then return end

if ndb.isvalidhouse(matches[2]) then
  temp_name_list[1].guild = matches[2]
end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:She|He) is .* in the (\w+)\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Might</name>
						<script>if not temp_name_list then return end

temp_name_list[1].might = tonumber(matches[2])

-- toads in Lusternia are considered "It" in might. Maggots here could be getting the same treatment</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>87</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:She|He|It) is considered to be approximately (\d+)% of your might\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Equal might</name>
						<script>if not temp_name_list then return end

temp_name_list[1].might = 100</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>He is considered to be approximately equal to your might.</string>
							<string>She is considered to be approximately equal to your might.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Any line</name>
						<script>if ndb.gaghonours then deleteLine() end</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>99</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>return true</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>4</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>ivory mark</name>
						<script>if not temp_name_list then return end

temp_name_list[1].mark = "Ivory"</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>He is a member of the Ivory Mark.</string>
							<string>She is a member of the Ivory Mark.</string>
							<string>^(?:He|She) is the .+? in the Ivory Mark\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>quisalis mark</name>
						<script>if not temp_name_list then return end

temp_name_list[1].mark = "Quisalis"</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>He is the Silent Executioner in the Quisalis Mark.</string>
							<string>She is the Silent Executioner in the Quisalis Mark.</string>
							<string>He is a member of the Quisalis Mark.</string>
							<string>She is a member of the Quisalis Mark.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Divorced</name>
						<script>if not temp_name_list then return end

temp_name_list[1].divorces = tonumber(matches[2]) or 1</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:H|Sh)e has been divorced (?:(\d+) times|once)\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Arms</name>
						<script>if not temp_name_list then return end

temp_name_list[1].arms = matches[2]</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^(?:H|Sh)e bears the arms: (.+)\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Motto/Warcry</name>
						<script>if not temp_name_list then return end

temp_name_list[1][matches[2]] = matches[3]:trim()</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>^H(?:is|er) (motto|warcry): '(.+)'$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Not Infamous</name>
						<script>temp_name_list[1].infamous = 0</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>She is not known for acts of infamy.</string>
							<string>He is not known for acts of infamy.</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>3</integer>
							<integer>3</integer>
						</regexCodePropertyList>
					</Trigger>
					<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="yes" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
						<name>Infamous</name>
						<script>local line = multimatches[2][3]
temp_name_list[1].infamous = ndb.valid.infamous[line]</script>
						<triggerType>0</triggerType>
						<conditonLineDelta>0</conditonLineDelta>
						<mStayOpen>0</mStayOpen>
						<mCommand></mCommand>
						<packageName></packageName>
						<mFgColor>#ff0000</mFgColor>
						<mBgColor>#ffff00</mBgColor>
						<mSoundFile></mSoundFile>
						<colorTriggerFgColor>#000000</colorTriggerFgColor>
						<colorTriggerBgColor>#000000</colorTriggerBgColor>
						<regexCodeList>
							<string>Infamous</string>
							<string>^(She|He) (.+)\.$</string>
						</regexCodeList>
						<regexCodePropertyList>
							<integer>0</integer>
							<integer>1</integer>
						</regexCodePropertyList>
					</Trigger>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>No Honours</name>
					<script>if ndb.honorsid then killTimer(ndb.honorsid) ndb.honorsid = nil else return end

disableTrigger("Honors")

if ndb.gaghonours then svo.deleteLineP() end

echo("\n")
svo.echof(ndb.honorsname .. " doesn't exist anymore, deleted them.")
local deletedname = ndb.honorsname

db:delete(ndb.db.people, db:eq(ndb.db.people.name, ndb.honorsname))
svo.debugf("deleted %s", ndb.honorsname)

local gaghonours = ndb.gaghonours
ndb.gaghonours = nil

raiseEvent("NameDB finished honors", "", (gaghonours and "quiet" or "manual"))

raiseEvent("NameDB name deleted", deletedname)</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>There is no such person, I'm afraid.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Immortal</name>
					<script>if ndb.honorsid then killTimer(ndb.honorsid) ndb.honorsid = nil end

disableTrigger("Honors")

if ndb.gaghonours then svo.deleteLineP() end

local temp_name_list = {}
temp_name_list[1] = {name = ndb.honorsname, immortal = 1}
db:merge_unique(ndb.db.people, temp_name_list)

local gaghonours = ndb.gaghonours
ndb.gaghonours = nil

raiseEvent("NameDB finished honors", ndb.honorsname, (gaghonours and "quiet" or "manual"))</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>She was born before time was counted.</string>
						<string>He was born before time was counted.</string>
						<string>His birth was foretold in legend.</string>
						<string>He was born from the Spiral Ribbons of Creation.</string>
						<string>He is the last of the line of Nicator.</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
						<integer>3</integer>
					</regexCodePropertyList>
				</Trigger>
			</TriggerGroup>
		</TriggerGroup>
		<TriggerGroup isActive="yes" isFolder="yes" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
			<name>Scripting Examples</name>
			<script></script>
			<triggerType>0</triggerType>
			<conditonLineDelta>0</conditonLineDelta>
			<mStayOpen>0</mStayOpen>
			<mCommand></mCommand>
			<packageName></packageName>
			<mFgColor>#ff0000</mFgColor>
			<mBgColor>#ffff00</mBgColor>
			<mSoundFile></mSoundFile>
			<colorTriggerFgColor>#000000</colorTriggerFgColor>
			<colorTriggerBgColor>#000000</colorTriggerBgColor>
			<regexCodeList />
			<regexCodePropertyList />
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Tentacle enemies down</name>
				<script>-- if you'd like to use this trigger, enable it and move it out of the NameDB folder - so your changes to it will stay

if ndb.isenemy(matches[2]) then
  if svo.defc.dragonform then
    svo.doadd("becalm")
  else
    svo.doadd("touch tentacle " .. matches[2])
  end
end</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>0</conditonLineDelta>
				<mStayOpen>0</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>^(\w+) flits into view directly overhead\.$</string>
					<string>^You recognise the form of (\w+) high above\.$</string>
					<string>^(\w+) begins to flap (?:his|her) wings powerfully, and rises quickly up into the firmament\.$</string>
					<string>^(\w+) is quickly carried up into the skies\.$</string>
					<string>^(\w+) grabs hold of a nearby branch and swings up and out of sight into the treetops\.$</string>
					<string>^(\w+) crouches down upon (?:his|her) haunches, then with a powerful thrust of (?:his|her) legs, launches (?:him|her)self straight up into the air\.$</string>
					<string>^(\w+) swoops down from above, tries to hoist \w+, and fails\.$</string>
					<string>^(\w+) sucks in (?:his|her) breath, and with a mighty blast of air exhales while uttering a word of magic\. Suddenly, s?he is lifted into the skies by an unseen force\.$</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
					<integer>1</integer>
				</regexCodePropertyList>
			</Trigger>
			<Trigger isActive="no" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
				<name>Falcon observe</name>
				<script>parse_enemies = {}</script>
				<triggerType>0</triggerType>
				<conditonLineDelta>3</conditonLineDelta>
				<mStayOpen>100</mStayOpen>
				<mCommand></mCommand>
				<packageName></packageName>
				<mFgColor>#ff0000</mFgColor>
				<mBgColor>#ffff00</mBgColor>
				<mSoundFile></mSoundFile>
				<colorTriggerFgColor>#000000</colorTriggerFgColor>
				<colorTriggerBgColor>#000000</colorTriggerBgColor>
				<regexCodeList>
					<string>Your falcon reports seeing the following people in its area:</string>
				</regexCodeList>
				<regexCodePropertyList>
					<integer>3</integer>
				</regexCodePropertyList>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Each line</name>
					<script>local name = matches[2]

if ndb.isenemy(name) then
	parse_enemies[name] = (100 / tonumber(matches[4])) * tonumber(matches[3])
end</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>99</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string>^(\w+)\s+(\d+) health out of (\d+)\.$</string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>1</integer>
					</regexCodePropertyList>
				</Trigger>
				<Trigger isActive="yes" isFolder="no" isTempTrigger="no" isMultiline="no" isPerlSlashGOption="no" isColorizerTrigger="no" isFilterTrigger="no" isSoundTrigger="no" isColorTrigger="no" isColorTriggerFg="no" isColorTriggerBg="no">
					<name>Close gate (falcon observe)</name>
					<script>setTriggerStayOpen("Falcon observe", 0)

local function say(tbl, affiliation)
	if not next(tbl) then return end

	local temp = {}
	for i,j in pairs(tbl) do
		temp[#temp+1] = string.format("%s %d%%hp", i, j)
	end

	svo.cc("%s outside in area: %s", affiliation, svo.concatand(temp))
end


say(parse_enemies, "Enemies")
parse_enemies = nil</script>
					<triggerType>0</triggerType>
					<conditonLineDelta>0</conditonLineDelta>
					<mStayOpen>0</mStayOpen>
					<mCommand></mCommand>
					<packageName></packageName>
					<mFgColor>#ff0000</mFgColor>
					<mBgColor>#ffff00</mBgColor>
					<mSoundFile></mSoundFile>
					<colorTriggerFgColor>#000000</colorTriggerFgColor>
					<colorTriggerBgColor>#000000</colorTriggerBgColor>
					<regexCodeList>
						<string></string>
					</regexCodeList>
					<regexCodePropertyList>
						<integer>7</integer>
					</regexCodePropertyList>
				</Trigger>
			</Trigger>
		</TriggerGroup>
	</TriggerPackage>
	<TimerPackage />
	<AliasPackage>
		<AliasGroup isActive="yes" isFolder="yes">
			<name>NameDB</name>
			<script></script>
			<command></command>
			<packageName></packageName>
			<regex></regex>
			<Alias isActive="yes" isFolder="no">
				<name>Who is</name>
				<script>ndb.showwhois(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^whois (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Honors a person</name>
				<script>ndb.honors(matches[2], "manual")</script>
				<command></command>
				<packageName></packageName>
				<regex>^honou?rs? (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb set person category value) Adjust person data</name>
				<script>local name = matches[2]:title()
local category = matches[3]
local towhat = tonumber(matches[4]) or matches[4]

local temp_name_list = {}

if category == "city" then
  towhat = towhat:title()
  if not ndb.isvalidcity(towhat) then
    svo.echof("%s isn't a known city, sorry.\n  Available ones are: %s", towhat, svo.concatand(ndb.valid.cities))
    return
  end

elseif category == "class" then
  towhat = towhat:lower()
  if not ndb.isvalidclass(towhat) then
    svo.echof("%s isn't a known class, sorry.\n  Available ones are: %s", towhat, svo.concatand(ndb.valid.classes))
    return
  end

elseif category == "race" then
  towhat = towhat:lower()
  if not ndb.isvalidrace(towhat) then
    svo.echof("%s isn't a known race, sorry.\n  Available ones are: %s", towhat, svo.concatand(ndb.valid.races))
    return
  end

elseif category == "house" then category = "guild"
end

if category == "guild" or category == "order" then towhat = towhat:title() end
if category == "notes" then towhat = towhat:gsub([[\n]], "\n") end

if category == "cityenemy" or category == "houseenemy" or category == "orderenemy" or category == "immortal" or category == "dragon" then
  towhat = svo.toboolean(towhat) and 1 or 0
end

temp_name_list[#temp_name_list + 1] = {
  name = name,
  [category] = towhat
}

db:merge_unique(ndb.db.people, temp_name_list)

ndb.showwhois(name)

-- re-honors person if necessary
if category == "xp_rank" or category == "might" then
  raiseEvent"NameDB got new data"
end

raiseEvent("NameDB set name changed", name)

-- regenerate order vconfigs
if category == "order" then ndb.setuporders() end</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb set (\w+) ([a-z_]+) (.+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(iff person status)</name>
				<script>ndb.setiff(matches[2], matches[3])

ndb.showwhois(matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^iff (\w+) (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>qw/qw2</name>
				<script>ndb.checkqw() -- qw and qw2 are the same now</script>
				<command></command>
				<packageName></packageName>
				<regex>^qw(2)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(qw update) Re-check people on qw list</name>
				<script>ndb.checkqw(nil, "update")</script>
				<command></command>
				<packageName></packageName>
				<regex>^qw update$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(qwc) Organize by city members</name>
				<script>ndb.checkqw(nil, "organize cities")</script>
				<command></command>
				<packageName></packageName>
				<regex>^qwc$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ppof) Report visible citizens of a city</name>
				<script>ndb.checkqw(nil, "report members of "..matches[2])</script>
				<command></command>
				<packageName></packageName>
				<regex>^ppof (\w+)</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(npp) Toggle name highlighting</name>
				<script>svo.config.set("ndbpaused", matches[2], true)</script>
				<command></command>
				<packageName></packageName>
				<regex>^npp(?: (\w+))?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb stats) See DB stats</name>
				<script>svo.echof("Compiling database stats...")
svo.showprompt()

local function makestats()
  local alldata = db:fetch(ndb.db.people)

  if not alldata or not next(alldata) then svo.echof("Your NameDB is empty! Check 'qw', 'citizens' to start filling it up...") return end

  local totalcount = #alldata

  local cities = {}
  for i = 1, #alldata do
    local p = alldata[i]
    if not p.city or p.city == '' then p.city = "none" end
    cities[p.city] = cities[p.city] or {}
    cities[p.city][#cities[p.city]+1] = p.name
  end
  local citiessorted = {}; for city in pairs(cities) do citiessorted[#citiessorted+1] = {city, #cities[city]} end
  table.sort(citiessorted, function(a, b)
    return a[2] &gt; b[2]
  end)
  
  echo'\n'
  svo.echof("People in the DB: %s", totalcount)
  svo.echof("City stats:")
  for i = 1, #citiessorted do
    cecho(string.format("  %-8s - %d citizens.\n", citiessorted[i][1], citiessorted[i][2]))
  end

  svo.showprompt()
end

tempTimer(0, makestats)</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb stats$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb cancel) Cancel honors'ing people</name>
				<script>ndb.cancelhonors()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb cancel$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb honorsnew) Honors backlog of new people</name>
				<script>ndb.manualcheck = true
ndb.updatebyhonors()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb honorsnew$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb export) export DB</name>
				<script>-- keep the location used between exports
local oldlocation = false
if ndb.exportdata and ndb.exportdata.location then oldlocation = ndb.exportdata.location end

ndb.exportdata = {
  fields = {},
  people = {all = true},
  location = oldlocation
}

-- setup defaults
for key, _ in pairs(ndb.schema.people) do
  ndb.exportdata.fields[key] = true
end
ndb.exportdata.fields.notes = false

ndb.exportmenu()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb export$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb import) import DB</name>
				<script>-- keep the location used between imports
local oldlocation = false
if ndb.importdata and ndb.importdata.location then oldlocation = ndb.importdata.location end

ndb.importdata = {
  location = oldlocation,
  data = false,
  fields = {},
}

if ndb.importdata.location then ndb.getimportfields() end
ndb.importmenu()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb import$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb delete all) Wipe the database clean</name>
				<script>if not ndb.deleteall then
  svo.echof("Are you really sure you want to wipe the database completely clean? Nothing will be saved, and this is irreversible. If yes, do this again.")
  svo.showprompt()
  ndb.deleteall = true
  return
end

ndb.deleteall = nil
db:delete(ndb.db.people, true)

-- clear highlights
ndb.loadhighlights()

svo.echof("Database completely wiped.")
svo.showprompt()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb delete all$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb delete unranked) Wipe all unranked (newbies and dormant) players</name>
				<script>local howmany = #db:fetch(ndb.db.people, db:eq(ndb.db.people.xp_rank, -2))

if not ndb.deleteunranked then
  svo.echof("Are you really sure you want to wipe the database of all unranked people? This will affect newbies and dormant players and get rid of %s entries.", howmany)
  svo.showprompt()
  ndb.deleteunranked = true
  return
end


ndb.deleteunranked = nil
db:delete(ndb.db.people, db:eq(ndb.db.people.xp_rank, -2))

-- clear highlights
ndb.loadhighlights()

svo.echof("Wiped %s unranked players from NameDB.", howmany)
svo.showprompt()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb delete unranked$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb update all) Re-check every person in the database</name>
				<script>local alldata = db:fetch(ndb.db.people)

if not svo.conf.autocheck or not svo.conf.usehonors then
	svo.echof("Both vconfig usehonors and vconfig autocheck must be set to yes to update all entries.")
	return 
end
if #alldata &gt;= 100 and not ndb.updateall then
  svo.echof("Are you really sure you want to re-check everybody in the database? You've got %d names - this'll take a while. If yes, do this again.", #alldata)
  svo.showprompt()
  ndb.updateall = true
  return
end

ndb.updateall = nil
ndb.fixed_set(ndb.db.people.xp_rank, -1)

svo.echof("Re-checking all %d known people in NameDB.", #alldata)
raiseEvent("NameDB got new data")</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb update all$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb update unranked) Re-check all unranked players</name>
				<script>-- catches newbies who switch cities or suicide, contributed by Adet

local names = {}
local alldata = db:fetch(ndb.db.people, db:eq(ndb.db.people.xp_rank, -2))

if #alldata &gt;= 100 and not ndb.updateunranked then
  svo.echof("Are you really sure you want to check all unranked people? You've got %d names - this'll take a while. If yes, do this again.", #alldata)
  svo.showprompt()
  ndb.updateunranked = true
  return
end
ndb.updateunranked = nil

for _, person in pairs(alldata) do
  table.insert(names, person.name)
end

local temp_name_list = {}
for i = 1, #names do 
  temp_name_list[#temp_name_list+1] = {name = names[i], xp_rank = -1}
end

db:merge_unique(ndb.db.people, temp_name_list)
raiseEvent("NameDB got new data")</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb update unranked$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb delete person) Delete one individual entry</name>
				<script>if matches[2] == "all" then return end -- handled by another alias
if matches[2] == "unranked" then return end -- handled by another alias

local name = matches[2]:title()

local exists = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))

if not (exists and next(exists)) then svo.echof("%s doesn't exist in the database already.", name) svo.showprompt() return end

db:delete(ndb.db.people, db:eq(ndb.db.people.name, name))

raiseEvent("NameDB name deleted", name)

svo.echof("Deleted %s's entry from NameDB.", name)
svo.showprompt()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb delete (\w+)$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(vshow highlightignore) See people on highlightignore</name>
				<script>local l = (next(svo.me.highlightignore) and svo.oneconcat(svo.me.highlightignore) or "(none - use vconfig highlightignore &lt;person&gt; to add)")
svo.echof("People on the highlightignore (those, who shouldn't be highlighted by NameDB) list: %s", l)
svo.showprompt()</script>
				<command></command>
				<packageName></packageName>
				<regex>^vshow highlightignore$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>Enemies lists</name>
				<script>if ndb.checkingenemies then killTimer(ndb.checkingenemies[1]) end

ndb.checkingenemies = {
  tempTimer(10+getNetworkLatency(), [[
    ndb.checkingenemies = nil
    disableTrigger"City/House/Order enemies"
  ]]),
  option = (matches[3] and matches[3]:trim() or nil)
}

enableTrigger"City/House/Order enemies"
send(matches[2].." enemies", false)</script>
				<command></command>
				<packageName></packageName>
				<regex>^(city|house|order) enemies( add)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>ndb alias cheatsheet</name>
				<script>local class = svo.me.class:title()

-- load help data in
if not ndb.help then
  local path = svo.installationfolder() .."/ndb-help.lua"
  
  local f, m = io.open(path)
  local s = f:read("*a")

  local data = loadstring("return "..s)()
  if not data then
    svo.echof("Couldn't load data from the ndb-help.lua file :/ maybe it is messed up.")
    return
  end

  ndb.help = data
end

local function gettooltip(entry)
  return table.concat(entry.definition, "\n")
end

local function getdesc(entry)
  return table.concat(entry.definition, "\n")
end

local function showshort()
	svo.echof("ndb alias cheatsheet:")

	for id, entry in pairs(ndb.help) do
		fg("DarkSlateGrey") echo"  * " setFgColor(unpack(svo.getDefaultColorNums)) echoLink(entry.term, 'ndb.showhelp('..id..')', gettooltip(entry), true) echo"\n"
	end
end

local function showlong()
	svo.echof("ndb alias cheatsheet (extended):")

	for id, entry in pairs(ndb.help) do
		fg("DarkSlateGrey") echo"  * " setFgColor(unpack(svo.getDefaultColorNums)) echoLink(entry.term, 'ndb.showhelp('..id..')', gettooltip(entry), true) echo"\n"
		echo"      " echo(getdesc(entry)) echo"\n"  echo"\n"
	end
end

if matches[2] then showlong() else showshort() end
svo.showprompt() echo'\n'</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb( long)?$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(qwm) Show marks</name>
				<script>ndb.checkqw(nil, "show marks")</script>
				<command></command>
				<packageName></packageName>
				<regex>^qwm$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(qwic) Show Infamous (quick)</name>
				<script>ndb.checkqw(nil, "show infamous")</script>
				<command></command>
				<packageName></packageName>
				<regex>^qwic$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(qwi) Show Infamous (update first)</name>
				<script>if not svo.conf.usehonors then
  svo.echof("You need to enable vconfig usehonors for Infamous info to show.")
  return
else
  ndb.checkingqwi = true
  ndb.checkqw(nil, "update")
end

</script>
				<command></command>
				<packageName></packageName>
				<regex>^qwi$</regex>
			</Alias>
			<Alias isActive="yes" isFolder="no">
				<name>(ndb infamous) Shows known infamous people in the database</name>
				<script>ndb.showinfamous()</script>
				<command></command>
				<packageName></packageName>
				<regex>^ndb infamous$</regex>
			</Alias>
		</AliasGroup>
	</AliasPackage>
	<ActionPackage />
	<ScriptPackage>
		<ScriptGroup isActive="yes" isFolder="yes">
			<name>NameDB</name>
			<packageName></packageName>
			<script>ndb = ndb or {}

function ndbPrio(_, module)
  if module ~= "svo (namedb)" then return end
  setModulePriority(module, 1)
end

registerAnonymousEventHandler("sysInstall", "ndbPrio")

svo.modules_version = svo.modules_version or {}
svo.modules_version["svo (namedb)"] = 1</script>
			<eventHandlerList />
			<Script isActive="yes" isFolder="no">
				<name>ndb.init</name>
				<packageName></packageName>
				<script>ndb.schema = {
  people = {
    name          = "",
    title         = "",
    gender        = "",
    class         = "",
    city          = "",
    city_rank     = 0,
    city_soldier  = -1, -- -1 default, 0 no, -2 yes
    guild         = "",
    might         = -1, -- 0 is a possible might, -1 unknown
    importance    = 0,
    xp_rank       = -1, -- -1 default, -2 unranked
    level         = -1, -- -1 default (unknown)
    immortal      = 0,
    iff           = -1, -- -1 autodetected, 1 enemy, 2 ally
    cityenemy     = 0, -- 0 is not enemy, 1 is enemy
    orderenemy    = 0, -- 0 is not enemy, 1 is enemy
    houseenemy    = 0, -- 0 is not enemy, 1 is enemy
    order         = "",
    notes         = "",
    dragon        = 0,
    mark          = "", -- contributed by Veldrin
    race          = "",
    combat_rank   = -1, -- -1 default, 0 no rank, &gt; 0 yes
    combat_rating = -1, -- -1 default, 0 no rating, &gt; 0 yes
    birth_day     = 0, -- 0 default, &gt; 0 yes
    birth_month   = 0, -- 0 default, &gt; 0 yes
    birth_year    = 0, -- 0 default, &gt; 0 yes
    birth_hidden  = -1, -- -1 default, 0 not hidden, 1 hidden
    arms          = "",
    divorces      = 0, -- 0 default,
    motto         = "",
    warcry        = "",
    infamous      = -1, -- -1 default, 0 not infamous, 1 nearly, 2-7 infamous 

    _unique     = {"name"},
    _violations = "REPLACE"
  },
}

function ndb.init()
  ndb.db = db:create("NameDB", ndb.schema)
  -- necessary on Windows, because its IO tends to... slow down with time.
  -- http://www.sqlite.org/pragma.html#pragma_synchronous
  db.__conn["namedb"]:execute("pragma synchronous = OFF")

  -- automigration by db: doesn't work anymore because LuaSQL bugs out on the pragma statement
  -- so if there was any data at all in the db, see if any of it needs to be added

  local test = db:fetch(ndb.db.people)
  if next(test) then
    local _,someperson = next(test)
    
    if someperson.order == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "order" TEXT NULL DEFAULT ""]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons order.\n")
    end

    if someperson.race == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "race" TEXT NULL DEFAULT ""]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons race.\n")
    end

    if someperson.dragon == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "dragon" REAL NULL DEFAULT 0]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field to see if a person is a dragon.\n")
    end

    if someperson.mark == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "mark" TEXT NULL DEFAULT ""]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field to see if a person is a mark.\n")
    end

    if someperson.combat_rank == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "combat_rank" REAL NULL DEFAULT -1]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the person combat rank.\n")
    end

    if someperson.combat_rating == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "combat_rating" REAL NULL DEFAULT -1]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons combat rating.\n")
    end

    if someperson.city_soldier == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "city_soldier" REAL NULL DEFAULT -1]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field to see if a person is a city soldier.\n")
    end

    if someperson.birth_day == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "birth_day" REAL NULL DEFAULT 0]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons birth day.\n")
    end

    if someperson.birth_month == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "birth_month" REAL NULL DEFAULT 0]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons birth month.\n")
    end

    if someperson.birth_year == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "birth_year" REAL NULL DEFAULT 0]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons birth year.\n")
    end

    if someperson.birth_hidden == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "birth_hidden" REAL NULL DEFAULT -1]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field to see if a person has a hidden birthdate.\n")
    end

    if someperson.arms == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "arms" TEXT NULL DEFAULT ""]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons arms.\n")
    end

    if someperson.divorces == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "divorces" REAL NULL DEFAULT 0]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field to see how many divorces a person has had.\n")
    end

    if someperson.infamous == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "infamous" REAL NULL DEFAULT 0]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field to track Infamous people.\n")
    end

    if someperson.motto == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "motto" TEXT NULL DEFAULT ""]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons motto.\n")
    end

    if someperson.warcry == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "warcry" TEXT NULL DEFAULT ""]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field for the persons warcry.\n")
    end

    if someperson.level == nil then
      local conn = db.__conn.namedb
      local sql_add = [[ALTER TABLE people ADD COLUMN "level" REAL NULL DEFAULT 0]]
      conn:execute(sql_add)
      conn:commit()
      cecho("(namedb): upgraded your database to have a field to track a persons level.\n")
    end
  end

  -- shuffle Shallamese into Targossas
  local c = #(db:fetch(ndb.db.people, db:eq(ndb.db.people.city, "Shallam")))
  if c ~= 0 then
    -- wait for ndb.fixed_set to be loaded
    tempTimer(0, [[ndb.fixed_set(ndb.db.people.city, "Targossas", db:eq(ndb.db.people.city, "Shallam")); svo.echof("Migrated ]]..c..[[ Shallamese to be called Targossians now.")]])
  end

   tempTimer(0, function()
     -- fix up knowns to go into rogue
     ndb.fixed_set(ndb.db.people.city, "rogue", db:eq(ndb.db.people.city, "(none)"))
     ndb.fixed_set(ndb.db.people.city, "rogue", db:eq(ndb.db.people.city, "none"))
     ndb.fixed_set(ndb.db.people.city, "rogue", db:eq(ndb.db.people.city, ""))
   end)
end

ndb.init()</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.valid</name>
				<packageName></packageName>
				<script>ndb.valid = ndb.valid or {}

ndb.valid.cities = {
  "Ashtan", "Cyrene", "Hashan", "Eleusis", "Mhaldor", "Targossas"
}
ndb.valid.classes = {
  "alchemist", "apostate", "bard", "blademaster", "depthswalker", "druid", "infernal", "jester", "magi", "monk", "occultist", "paladin", "priest", "psion", "runewarden", "sentinel", "serpent", "shaman", "sylvan"
}
ndb.valid.houses = {
  "Scions", "Merchants", "Heartwood", "Cij", "Somatikos", "Shield", "Krymenian", "Virtuosi", "Outriders", "Dawnblade", "Harbingers", "Luminai", "Legates", "Insidium", "Consortium", "Savants", "Vanguard"
}
ndb.valid.races = {
  "tsol'aa", "dwarf", "human", "troll", "atavian", "rajamala", "horkval", "grook", "xoran", "siren", "satyr", "mhun", "tash'la", "elemental lord", "elemental lady"
}
ndb.valid.infamous = {
  ["is rapidly approaching the ranks of the Infamous"] = 1,
  ["is one of the Infamous"]                        = 2,
  ["is one of the solidly Infamous"]                = 3,
  ["is one of the staggeringly Infamous"]           = 4,
  ["is one of the entrenched Infamous"]             = 5,
  ["is one of the near-permanent Infamous"]         = 6,
  ["is one of the inveterately Infamous"]           = 7,
}
ndb.valid.shortinfamous = {
  "nearly",
  "Infamous",
  "solidly Infamous",
  "staggeringly Infamous",
  "entrenched Infamous",
  "near-permanent Infamous",
  "inveterately Infamous"
}

ndb.valid.cityranks = {
  Mhaldor = {
    Slave = 1,
    Troni = 2,
    Dynamis = 3,
    Dominion = 4,
    Archai = 5,
    Exsusiai = 6,
  },

  Cyrene = {
    Citizen = 1,
    Peer = 2,
    Noble = 3,
    Marquis = 4,
    Marquise = 4,
    Duke = 5,
    Duchess = 5,
    Lord = 6,
    Lady = 6,
  },

  Ashtan = {
    Plebeian = 1,
    Equite = 2,
    Centurion = 3,
    Patrician = 4,
    Matrician = 4,
    Consul = 5,
    Praetor = 6,
  },

  Eleusis = {
    Freeman = 1,
    Freewoman = 1,
    Ranger = 2,
    Tender = 3,
    Warden = 4,
    Watcher = 5,
    Elder = 6,
  },

  Hashan = {
    Peasant = 1,
    Commoner = 2,
    Burgher = 3,
    Esquire = 4,
    Peer = 5,
    Peeress = 5,
    Lord = 6,
    Lady = 6,
  },

  -- dead city, but some people in your namedb could be listed as Shallam still
  Shallam = {
    Villager = 1,
    Citizen = 2,
    Chieftain = 3,
    Satrap = 4,
    Ataman = 5,
    Emir = 6
  },

  Targossas = {
    Settler = 1,
    Sentry = 2,
    Devout = 3,
    Vigilant = 4,
    Paragon = 5,
    Vanguard = 6,
  },
}

-- make a reverse map as well, rank = name
for city, citydata in pairs(ndb.valid.cityranks) do
  for rank, rankn in pairs(citydata) do
    citydata[rankn] = rank
  end
end

ndb.valid.months = {
  "Sarapin",
  "Daedalan",
  "Aeguary",
  "Miraman",
  "Scarlatan",
  "Ero",
  "Valnuary",
  "Lupar",
  "Phaestian",
  "Chronos",
  "Glacian",
  "Mayan",
  Sarapin = 1,
  Daedalan = 2,
  Aeguary = 3,
  Miraman = 4,
  Scarlatan = 5,
  Ero = 6,
  Valnuary = 7,
  Lupar = 8,
  Phaestian = 9,
  Chronos = 10,
  Glacian = 11,
  Mayan = 12,
}

function ndb.isvalidcity(which)
  which = which:title()
  return table.contains(ndb.valid.cities, which) and true or false
end

function ndb.isvalidhouse(which)
  which = which:title()
  return table.contains(ndb.valid.houses, which) and true or false
end

function ndb.isvalidclass(which)
  which = which:lower()
  return table.contains(ndb.valid.classes, which) and true or false
end

function ndb.isvalidrace(which)
  which = which:lower()
  return table.contains(ndb.valid.races, which) and true or false
end</script>
				<eventHandlerList />
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.support</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>ndb.finished_honors</name>
					<packageName></packageName>
					<script></script>
					<eventHandlerList>
						<string>NameDB finished honors</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.updatebyhonors</name>
					<packageName></packageName>
					<script>-- this just registers the handler, the script is supposed to be blank</script>
					<eventHandlerList>
						<string>NameDB got new data</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.datamining</name>
					<packageName></packageName>
					<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
					<eventHandlerList />
					<Script isActive="yes" isFolder="no">
						<name>ndb.setfromclass</name>
						<packageName></packageName>
						<script>ndb.classhits = ndb.classhits or {}

function ndb.setfromclass(_, class, name)
  -- a name isn't always given if it is not available
  if not name then return end

  class = class:lower()

  if class == "knight" then return end

  ndb.classhits[name] = ndb.classhits[name] or {hits = 0, class = class}

  if ndb.classhits[name].class ~= class then
    ndb.classhits[name].hits = 0 -- reset on a hit from the same person on another class
  else
    ndb.classhits[name].hits = ndb.classhits[name].hits + 1

    if ndb.classhits[name].hits &gt;= svo.conf.autoclassset then
      if class == "dragon" then
        if not ndb.isdragon(name) then
          ndb.setdragon(name, true)
          svo.echof("Auto-set %s as a Dragon.", name)
        end
      else
        local oldclass = ndb.getclass(name)
        if not oldclass then return end -- if the name isn't known, don't add it - could be fake names from illusions

        if class ~= oldclass then
          ndb.setclass(name, class)
          svo.echof("Auto-set %s's class to %s.", name, class:title())
        end
      end

      ndb.classhits[name].hits = 0 -- reset, so we aren't querying the db on every hit
    end
  end
end</script>
						<eventHandlerList>
							<string>svo got hit by</string>
						</eventHandlerList>
					</Script>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.downloaded_file</name>
					<packageName></packageName>
					<script>-- credit to Veldrin for the original function

function ndb.downloaded_file(_, filename)
  -- is the file that downloaded ours?
  if not string.find(filename, "namedb.json") then return end
  local f = io.open(filename)
  local s = f:read("*all")
  if f then f:close() end
  os.remove(filename)
  s = s:gsub("\"", "")
  local name = filename:match("(%w+)-namedb")
  local fullname = s:match([[fullname:(.+),city]])
  local level = s:match([[level:(%d+),class]])
  local city = s:match([[city:(.+),house]])
  local house = s:match([[house:(.+),level]])
  local class = s:match([[class:(.+),mob_kills]])
  local xp_rank = s:match([[xp_rank:(%d+),explorer_rank]])
  local dragon
  local temp_name_list

  -- sometimes players, unless you're logged in, aren't visible
  if s:find("I do not recognize that player.") then
    temp_name_list = {{
      name = name,
      xp_rank = -2,
    }}

  elseif level == nil then
    temp_name_list = {{
      name = name,
      immortal = 1
    }}
 
  else
    
    if tonumber(level) &gt; 98 then dragon = 1 else dragon = 0 end
    if tonumber(xp_rank) == 0 then xp_rank = -2 end -- unranked shows up as 0

    temp_name_list = {{
      name = name,
      class = class,
      dragon = dragon,
      title = fullname,
      level = level,
      immortal = 0,
      xp_rank = xp_rank and xp_rank or -1,
    }}
    if city ~= "(hidden)" then
        temp_name_list[1].city = (city ~= "(none)" and string.title(city) or "rogue")
    end
    -- house info isn't shown if you're logged in to the website for some people
    if not(house == "(hidden)" or house == "(none)") then
      temp_name_list[1].guild = string.title(house)
    end
  end

  db:merge_unique(ndb.db.people, temp_name_list)

  raiseEvent("NameDB finished honors")
end

function ndb.getinfo(person)
  downloadFile(getMudletHomeDir().."/"..person.."-namedb.json", "http://api.achaea.com/characters/"..person..".json")
end</script>
					<eventHandlerList>
						<string>sysDownloadDone</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.ui</name>
					<packageName></packageName>
					<script>function ndb.showhonorswindow(text)
  ndb.autochecklabel = ndb.autochecklabel or Geyser.Label:new({
    name = "ndb.autochecklabel",
    x = "-370px", y = "-35px",
    width = "350px", height = "25px",
  })

  ndb.autochecklabel:setStyleSheet([[
    margin: 0px;
    padding: 2px;

    background: rgba(0, 0, 51, 75%);
    border: none;
    border-radius: 4px;

    qproperty-alignment: 'AlignLeft | AlignVCenter';
    qproperty-wordWrap: true;
    font-family: 'Ubuntu','Calibri',serif;
  ]])

  ndb.autochecklabel:show()
  ndb.autochecklabel:echo([[&lt;p style="color: grey; font-size: 15px;"&gt;]]..text..[[&lt;/p&gt;]])
end

function ndb.hidehonorswindow()
  if ndb.autochecklabel then ndb.autochecklabel:hide() end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.configs</name>
					<packageName></packageName>
					<script>function ndb.setuporders()
  local r = db:fetch_sql(ndb.db.people, [[SELECT DISTINCT "order" FROM 'people';]])
  if not r then return end

  table.sort(r, function(a,b) return a.order &lt; b.order end)

  for i = 1, #r do
    if r[i].order ~= "" then
      local order = r[i].order

      svo.config.setoption("highlight"..order:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s highlight %s's Order members.", svo.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s highlight %s's Order members.", svo.getDefaultColor(), order) end,
      })
      svo.config.setoption("bold"..order:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s bold %s's Order members.", svo.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s bold %s's Order members.", svo.getDefaultColor(), order) end,
      })
      svo.config.setoption("underline"..order:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s underline %s's Order members.", svo.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s underline %s's Order members.", svo.getDefaultColor(), order) end,
      })
      svo.config.setoption("italicize"..order:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s italicize %s's Order members.", svo.getDefaultColor(), order) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s italicize %s's Order members.", svo.getDefaultColor(), order) end,
      })

      svo.config.setoption(order:lower().."color", {
        type = "string",
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[svo.conf[order:lower().."color"]])
          svo.echof("Highlighting %s Order members in &lt;%s,%s,%s&gt;%s%s now.", order, r,g,b, svo.conf[order:lower().."color"], svo.getDefaultColor())
        end,
      })
    end
  end
end

function ndb.configs()
  if svo.conf.autocheck == nil then svo.conf.autocheck = true end
  if svo.conf.ndbpause == nil then svo.conf.ndbpause = false end
  if svo.conf.usehonors == nil then svo.conf.usehonors = false end

  svo.config.setoption("usehonors", {
    type = "boolean",
    vconfig2string = true,
    onenabled = function () svo.echof("&lt;0,250,0&gt;Will%s make use of honors when checking new people, which'll allow NameDB to capture more information.", svo.getDefaultColor()) end,
    ondisabled = function () svo.echof("&lt;250,0,0&gt;Won't%s make use of honors when checking new people.", svo.getDefaultColor()) end
  })

  svo.config.setoption("autocheck", {
    type = "boolean",
    vconfig2string = true,
    onenabled = function () svo.echof("&lt;0,250,0&gt;Will%s automatically, and quietly, honors new people we come across.", svo.getDefaultColor()) ndb.updatebyhonors() end,
    ondisabled = function () svo.echof("&lt;250,0,0&gt;Won't%s automatically honors new people. Use 'ndb honorsnew' to clear the new names backlog manually.", svo.getDefaultColor()) ndb.cancelhonors(true) end,
    onshow = function (defaultcolour)
      fg("gold")
      echoLink("NameDB:", "", "svo NameDB", true)
      fg(defaultcolour) echo(" ")
      fg("a_cyan") echoLink(svo.conf.autocheck and "Auto-checking" or "Not auto-checking", "svo.config.set('autocheck', "..(svo.conf.autocheck and "false" or "true")..", true)", "Click to "..(svo.conf.autocheck and "disable" or "enable").." automatic name checks on new people that we see", true)
      fg(defaultcolour)
      echo(" new people, highlighting names is ")
      fg(defaultcolour)
      fg("a_cyan") echoLink(not svo.conf.ndbpaused and "on" or "off", "svo.config.set('ndbpaused', "..(svo.conf.ndbpaused and "false" or "true")..", true)", "Click to "..(svo.conf.ndbpaused and "start" or "stop").." highlighting names", true)
      fg(defaultcolour)
      echo(", ")
      fg("a_cyan") echoLink(svo.conf.usehonors and "will" or "won't", "svo.config.set('usehonors', "..(svo.conf.usehonors and "false" or "true")..", true)", "Click to "..(not svo.conf.usehonors and "enable" or "disable").." using honors to check names", true)
      fg(defaultcolour)
      echo(" use honors.\n")
    end
  })

  svo.config.setoption("ndbpaused", {
    type = "boolean",
    onenabled = function () ndb.loadhighlights() svo.echof("Name highlighting &lt;250,0,0&gt;stopped%s.", svo.getDefaultColor()) end,
    ondisabled = function () ndb.loadhighlights() svo.echof("Name highlighting &lt;0,250,0&gt;resumed%s.", svo.getDefaultColor()) end
  })

  svo.conf.autoclassset = svo.conf.autoclassset or 10
  svo.config.setoption("autoclassset", {
    type = "number",
    vconfig2string = true,
    onshow = function (defaultcolour)
      fg("gold")
      echoLink("NameDB:", "", "svo NameDB", true)
      fg(defaultcolour) echo(" Capture a persons class after ")
      fg("a_cyan") echoLink(tostring(svo.conf.autoclassset), "printCmdLine('vconfig autoclassset ')", "Click to set the amount of consecutive attacks a person must do from a particular class before it's recorded in NameDB. This is for anti-illusion purposes, so illusions can't easily make NameDB mess with their known class", true)
      fg(defaultcolour)
      echo(" consecutive attacks.\n")
    end,
    onset = function ()
      svo.echof("Will record/change a persons class after %d class-specific attacks from them.", svo.conf.autoclassset)
    end,
  })

  svo.config.setoption("politics", {
    type = "custom",
    onmenu = function () ndb.showpolitics(true) end,
  })

  local function setupwatchfor()
    svo.config.setoption("highlightwatchfor", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s highlight names on the watchfor list.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s highlight names on the watchfor list.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("boldwatchfor", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s bold names on the watchfor list.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s bold names on the watchfor list.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("underlinewatchfor", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s underline names on the watchfor list.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s underline names on the watchfor list.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("italicizewatchfor", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s italicize names on the watchfor list.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s italicize names on the watchfor list.", svo.getDefaultColor()) end,
    })

    svo.config.setoption("watchforcolor", {
      type = "string",
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[svo.conf.watchforcolor])
        svo.echof("Highlighting watchfor names in &lt;%s,%s,%s&gt;%s%s now.", r,g,b, svo.conf.watchforcolor, svo.getDefaultColor())
      end,
    })
  end

  local function setupcities()
    for _, city in ipairs(ndb.valid.cities) do
      svo.config.setoption("highlight"..city:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s highlight citizens of %s.", svo.getDefaultColor(), city) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s highlight citizens of %s.", svo.getDefaultColor(), city) end,
      })
      svo.config.setoption("bold"..city:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s bold the names of %s citizens.", svo.getDefaultColor(), city) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s bold the names of %s citizens.", svo.getDefaultColor(), city) end,
      })
      svo.config.setoption("underline"..city:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s underline the names of %s citizens.", svo.getDefaultColor(), city) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s underline the names of %s citizens.", svo.getDefaultColor(), city) end,
      })
      svo.config.setoption("italicize"..city:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s italicize the names of %s citizens.", svo.getDefaultColor(), city) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s italicize the names of %s citizens.", svo.getDefaultColor(), city) end,
      })

      svo.config.setoption(city:lower().."color", {
        type = "string",
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[svo.conf[city:lower().."color"]])
          svo.echof("Highlighting %s citizens in &lt;%s,%s,%s&gt;%s%s now.", city, r,g,b, svo.conf[city:lower().."color"], svo.getDefaultColor())
        end,
      })
    end
  end

  local function setuprogues()
    svo.config.setoption("highlightrogues", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s highlight rogues.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s highlight rogues.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("boldrogues", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s bold the names of rogues.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s bold the names of rogues.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("underlinerogues", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s underline the names of rogues.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s underline the names of rogues.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("italicizerogues", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s italicize the names of rogues.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s italicize the names of rogues.", svo.getDefaultColor()) end,
    })

    svo.config.setoption("roguescolor", {
      type = "string",
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[svo.conf["roguescolor"]])
        svo.echof("Highlighting rogues in &lt;%s,%s,%s&gt;%s%s now.", r,g,b, svo.conf["roguescolor"], svo.getDefaultColor())
      end,
    })
  end

  local function setupenemies()
    for _, org in ipairs({"city", "house", "order"}) do
      svo.config.setoption("highlight"..org:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s highlight enemies of your of %s.", svo.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s highlight enemies of your of %s.", svo.getDefaultColor(), org) end,
      })
      svo.config.setoption("bold"..org:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s bold the names of your %s enemies.", svo.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s bold the names of your %s enemies.", svo.getDefaultColor(), org) end,
      })
      svo.config.setoption("underline"..org:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s underline the names of your %s enemies.", svo.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s underline the names of your %s enemies.", svo.getDefaultColor(), org) end,
      })
      svo.config.setoption("italicize"..org:lower(), {
        type = "boolean",
        onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s italicize the names of your %s enemies.", svo.getDefaultColor(), org) end,
        ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s italicize the names of your %s enemies.", svo.getDefaultColor(), org) end,
      })

      svo.config.setoption(org:lower().."color", {
        type = "string",
        check = function (what)
          if color_table[what] then return true end
        end,
        onset = function ()
          ndb.loadhighlights()
          local r,g,b = unpack(color_table[svo.conf[org:lower().."color"]])
          svo.echof("Highlighting your %s enemies in &lt;%s,%s,%s&gt;%s%s now.", org, r,g,b, svo.conf[org:lower().."color"], svo.getDefaultColor())
        end,
      })
    end
  end
  
  local function setupdivines()
    svo.config.setoption("highlightdivine", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s highlight Divines.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s highlight Divines.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("bolddivine", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s bold Divines.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s bold Divines.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("underlinedivine", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s underline Divines.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s underline Divines.", svo.getDefaultColor()) end,
    })
    svo.config.setoption("italicizedivine", {
      type = "boolean",
      onenabled = function () ndb.loadhighlights() svo.echof("&lt;0,250,0&gt;Will%s italicize Divines.", svo.getDefaultColor()) end,
      ondisabled = function () ndb.loadhighlights() svo.echof("&lt;250,0,0&gt;Won't%s italicize Divines.", svo.getDefaultColor()) end,
    })

    svo.config.setoption("divinecolor", {
      type = "string",
      check = function (what)
        if color_table[what] then return true end
      end,
      onset = function ()
        ndb.loadhighlights()
        local r,g,b = unpack(color_table[svo.conf.divinecolor])
        svo.echof("Highlighting Divines in &lt;%s,%s,%s&gt;%s%s now.", r,g,b, svo.conf.divinecolor, svo.getDefaultColor())
      end,
    })
  end

  local function addhighlightignore()
    svo.me.highlightignore = svo.me.highlightignore or {}

    svo.config.setoption("highlightignore", {
      type = "string",
      check = function(what)
        if what:find("^%w+$") then return true end
      end,
      onset = function ()
        local name = string.title(svo.conf.highlightignore)
        -- we want nil, not false so 'or' doesn't help
        if svo.me.highlightignore[name] then svo.me.highlightignore[name] = nil else svo.me.highlightignore[name] = true end

        if svo.me.highlightignore[name] then
          svo.echof("Added &lt;0,255,0&gt;%s%s to the highlightignore list - so we won't highlight them.", name, svo.getDefaultColor())
        else
          svo.echof("Removed %s from the highlightignore list.", name)
        end
        raiseEvent("NameDB highlightignore name changed", name)
      end
    })
  end

  setupcities()
  setuprogues()
  setupwatchfor()
  setupenemies()
  setupdivines()
  ndb.setuporders()
  addhighlightignore()
end

-- improve: add background colors
--   rogues as a section
function ndb.showpolitics(noprompt)
  local echo, setFgColor, setUnderline, setFgColor, echoLink = echo, setFgColor, setUnderline, setFgColor, echoLink
  svo.echof("Adjust city stances and setup highlights (currently highlighting %s names):", table.size(ndb.highlightIDs))
  svo.echofn("(click on underlined to change, ")
    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true) echoLink("view color list", "showColors()", "Click here to view the list of possible colors you can choose", true) setUnderline(false)
    echo("):\n\n")

  local function showcities()
    svo.echof("City politics:")

    -- cities
    for _, city in ipairs(ndb.valid.cities) do
      local status = ndb.conf.citypolitics[city]
      local extraspaces = 0
      setFgColor(unpack(svo.getDefaultColorNums))
      echo("  ")
      echo(string.format("%-9s is ", city))

      local nextstatus
      if status == "ally" then fg("a_green"); nextstatus = "enemy"; status = "an ally"; extraspaces = 7
      elseif status == "enemy" then fg("a_red"); nextstatus = "neutral"; status = "an enemy"; extraspaces = 8
      else fg("a_darkwhite"); nextstatus = "ally"; extraspaces = 7 end

      if svo.conf.org ~= city then
        setUnderline(true) echoLink(tostring(status), "ndb.conf.citypolitics."..city.." = '"..nextstatus.."'; ndb.showpolitics()", 'Click to set '..city.."s status to "..nextstatus, true) setUnderline(false)
      else
        setFgColor(unpack(svo.getDefaultColorNums)) echo("your home"); extraspaces = 9
      end

      setFgColor(unpack(svo.getDefaultColorNums))
      echo(",")
      echo((" "):rep(10-extraspaces))

      setUnderline(true)
      echoLink(svo.conf["highlight"..city:lower()] and "highlighting" or "not highlighting", 
        'svo.config.set("highlight'..city:lower()..'", '..(svo.conf["highlight"..city:lower()] and "false" or "true")..', true); ndb.showpolitics()', 
        'Click to '..(svo.conf["highlight"..city:lower()] and "stop" or "start").. ' highlighting citizens of '..city, 
      true)
      setUnderline(false)

      if not svo.conf["highlight"..city:lower()] then
        echo("  its citizens in any color,")
        echo((" "):rep(2))
      else
        echo((" "):rep(5))
        echo(" its citizens in ")
        setUnderline(true)
        setFgColor(unpack(color_table[svo.conf[city:lower().."color"] or "a_darkwhite"]))
        echoLink(svo.conf[city:lower().."color"] or "a_darkwhite", 
          "printCmdLine'vconfig "..city:lower().."color '", 
          'Click to set the color of '..ndb.getpluralcity(city, 2)..' citizens', 
        true)
        setUnderline(false)
        setFgColor(unpack(svo.getDefaultColorNums))
        echo(", ")
        echo((" "):rep(10-#(svo.conf[city:lower().."color"] or "a_darkwhite")))
      end

      echo("(")

      setUnderline(true)
      echoLink(svo.conf["bold"..city:lower()] and "bold" or "no bld", 
        'svo.config.set("bold'..city:lower()..'", '..(svo.conf["bold"..city:lower()] and "false" or "true")..', true); ndb.showpolitics()', 
        'Click to '..(svo.conf["bold"..city:lower()] and "stop" or "start").. ' bolding citizens of '..city, 
      true)
      setUnderline(false)
      echo(", ")

      setUnderline(true)
      echoLink(svo.conf["underline"..city:lower()] and "undl" or "no undl", 
        'svo.config.set("underline'..city:lower()..'", '..(svo.conf["underline"..city:lower()] and "false" or "true")..', true); ndb.showpolitics()', 
        'Click to '..(svo.conf["underline"..city:lower()] and "stop" or "start").. ' underlining citizens of '..city, 
      true)
      setUnderline(false)
      echo(", ")

      setUnderline(true)
      echoLink(svo.conf["italicize"..city:lower()] and "ital" or "no ital", 
        'svo.config.set("italicize'..city:lower()..'", '..(svo.conf["italicize"..city:lower()] and "false" or "true")..', true); ndb.showpolitics()', 
        'Click to '..(svo.conf["italicize"..city:lower()] and "stop" or "start").. ' italicizing citizens of '..city, 
      true)
      setUnderline(false)

      echo(")")

      echo('\n')
    end

    -- rogues
    setFgColor(unpack(svo.getDefaultColorNums))
    echo("  Rogues are neutral,     ")

    setUnderline(true)
    echoLink(svo.conf["highlightrogues"] and "highlighting" or "not highlighting", 
      'svo.config.set("highlightrogues", '..(svo.conf["highlightrogues"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["highlightrogues"] and "stop" or "start").. ' highlighting rogues', 
    true)
    setUnderline(false)

    if not svo.conf["highlightrogues"] then
      echo("  them in any color,")
      echo((" "):rep(10))
    else
      echo((" "):rep(5))
      echo(" them in ")
      setUnderline(true)
      setFgColor(unpack(color_table[svo.conf["roguescolor"] or "a_darkwhite"]))
      echoLink(svo.conf["roguescolor"] or "a_darkwhite", 
        "printCmdLine'vconfig rogues".."color '", 
        'Click to set the color of rogues', 
      true)
      setUnderline(false)
      setFgColor(unpack(svo.getDefaultColorNums))
      echo(", ")
      echo((" "):rep(18-#(svo.conf["roguescolor"] or "a_darkwhite")))
    end

    echo("(")

    setUnderline(true)
    echoLink(svo.conf["boldrogues"] and "bold" or "no bld", 
      'svo.config.set("boldrogues", '..(svo.conf["boldrogues"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["boldrogues"] and "stop" or "start").. ' bolding rogues', 
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(svo.conf["underlinerogues"] and "undl" or "no undl", 
      'svo.config.set("underlinerogues", '..(svo.conf["underlinerogues"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["underlinerogues"] and "stop" or "start").. ' underlining rogues', 
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(svo.conf["italicizerogues"] and "ital" or "no ital", 
      'svo.config.set("italicizerogues", '..(svo.conf["italicizerogues"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["italicizerogues"] and "stop" or "start").. ' italicizing rogues', 
    true)
    setUnderline(false)

    echo(")")

    echo('\n')
  end

  local function showwatchfor()
    svo.echof("Watchfor list:")
    setFgColor(unpack(svo.getDefaultColorNums))
    echo("  ")
    setUnderline(true)
    echoLink(svo.conf["highlightwatchfor"] and "Highlighting" or "Not highlighting", 
      'svo.config.set("highlightwatchfor", '..(svo.conf["highlightwatchfor"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["highlightwatchfor"] and "stop" or "start").. ' highlighting names on the watchfor list',
    true)
    setUnderline(false)

    if not svo.conf["highlightwatchfor"] then
      echo(" names on the watchfor list. ")
      echo((" "):rep(25))
    else
      echo(" names on the watchfor list in ")
      setUnderline(true)
      setFgColor(unpack(color_table[svo.conf["watchforcolor"] or "a_darkwhite"]))
      echoLink(svo.conf["watchforcolor"] or "a_darkwhite", 
        "printCmdLine'vconfig watchfor".."color '", 
        'Click to set the color of names on the watchfor list', 
      true)
      setUnderline(false)
      setFgColor(unpack(svo.getDefaultColorNums))
      echo(", ")
      echo((" "):rep(25-#(svo.conf["watchforcolor"] or "a_darkwhite")))
    end

    echo("(")

    setUnderline(true)
    echoLink(svo.conf["boldwatchfor"] and "bold" or "no bld", 
      'svo.config.set("boldwatchfor", '..(svo.conf["boldwatchfor"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["boldwatchfor"] and "stop" or "start").. ' bolding names on watchfor list', 
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(svo.conf["underlinewatchfor"] and "undl" or "no undl", 
      'svo.config.set("underlinewatchfor", '..(svo.conf["underlinewatchfor"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["underlinewatchfor"] and "stop" or "start").. ' underlining names on watchfor list', 
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(svo.conf["italicizewatchfor"] and "ital" or "no ital", 
      'svo.config.set("italicizewatchfor", '..(svo.conf["italicizewatchfor"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["italicizewatchfor"] and "stop" or "start").. ' italicizing names on watchfor list', 
    true)
    setUnderline(false)

    echo(")")
    echo("\n")
  end

  local function showdivines()
    svo.echof("Divine list:")
    setFgColor(unpack(svo.getDefaultColorNums))
    echo("  ")
    setUnderline(true)
    echoLink(svo.conf["highlightdivine"] and "Highlighting" or "Not highlighting", 
      'svo.config.set("highlightdivine", '..(svo.conf["highlightdivine"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["highlightdivine"] and "stop" or "start").. ' highlighting Divines',
    true)
    setUnderline(false)

    if not svo.conf["highlightdivine"] then
      echo(" Divines. ")
      echo((" "):rep(44))
    else
      echo(" Divines in ")
      setUnderline(true)
      setFgColor(unpack(color_table[svo.conf["divinecolor"] or "a_darkwhite"]))
      echoLink(svo.conf["divinecolor"] or "a_darkwhite", 
        "printCmdLine'vconfig divine".."color '", 
        'Click to set the color of Divine names', 
      true)
      setUnderline(false)
      setFgColor(unpack(svo.getDefaultColorNums))
      echo(", ")
      echo((" "):rep(44-#(svo.conf["divinecolor"] or "a_darkwhite")))
    end

    echo("(")

    setUnderline(true)
    echoLink(svo.conf["bolddivine"] and "bold" or "no bld", 
      'svo.config.set("bolddivine", '..(svo.conf["bolddivine"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["bolddivine"] and "stop" or "start").. ' bolding Divines', 
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(svo.conf["underlinedivine"] and "undl" or "no undl", 
      'svo.config.set("underlinedivine", '..(svo.conf["underlinedivine"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["underlinedivine"] and "stop" or "start").. ' underlining Divines', 
    true)
    setUnderline(false)
    echo(", ")

    setUnderline(true)
    echoLink(svo.conf["italicizedivine"] and "ital" or "no ital", 
      'svo.config.set("italicizedivine", '..(svo.conf["italicizedivine"] and "false" or "true")..', true); ndb.showpolitics()', 
      'Click to '..(svo.conf["italicizedivine"] and "stop" or "start").. ' italicizing Divines', 
    true)
    setUnderline(false)

    echo(")")
    echo("\n")
  end

  local function showenemies()
    svo.echof("House, City and Order enemies:")

    for _, org in ipairs({"house", "city", "order"}) do
      setFgColor(unpack(svo.getDefaultColorNums))
      echo("  ")
      setUnderline(true)
      echoLink(svo.conf["highlight"..org] and "Highlighting" or "Not highlighting", 
        'svo.config.set("highlight'..org..'", '..(svo.conf["highlight"..org] and "false" or "true")..', true); ndb.showpolitics()', 
        'Click to '..(svo.conf["highlight"..org] and "stop" or "start").. ' highlighting names of your '..org..' enemies',
      true)
      setUnderline(false)

      if not svo.conf["highlight"..org] then
        echo(" names of your "..org.." enemies. ")
        echo((" "):rep(29-#org))
      else
        echo("     names of your "..org.. " enemies in ")
        setUnderline(true)
        setFgColor(unpack(color_table[svo.conf[org.."color"] or "a_darkwhite"]))
        echoLink(svo.conf[org.."color"] or "a_darkwhite", 
          "printCmdLine'vconfig "..org.."color '", 
          'Click to set the color of names on '..org..' enemies list', 
        true)
        setUnderline(false)
        setFgColor(unpack(svo.getDefaultColorNums))
        echo(", ")
        echo((" "):rep(25-#org-#(svo.conf[org.."color"] or "a_darkwhite")))
      end
      
      echo("(")

      setUnderline(true)
      echoLink(svo.conf["bold"..org] and "bold" or "no bld", 
        'svo.config.set("bold'..org..'", '..(svo.conf["bold"..org] and "false" or "true")..', true); ndb.showpolitics()', 
        'Click to '..(svo.conf["bold"..org] and "stop" or "start").. ' bolding names of your '..org..' enemies', 
      true)
      setUnderline(false)
      echo(", ")

      setUnderline(true)
      echoLink(svo.conf["underline"..org] and "undl" or "no undl", 
        'svo.config.set("underline'..org..'", '..(svo.conf["underline"..org] and "false" or "true")..', true); ndb.showpolitics()', 
        'Click to '..(svo.conf["underline"..org] and "stop" or "start").. ' underlining names of your '..org..' enemies', 
      true)
      setUnderline(false)
      echo(", ")

      setUnderline(true)
      echoLink(svo.conf["italicize"..org] and "ital" or "no ital", 
        'svo.config.set("italicize'..org..'", '..(svo.conf["italicize"..org] and "false" or "true")..', true); ndb.showpolitics()', 
        'Click to '..(svo.conf["italicize"..org] and "stop" or "start").. ' italicizing names of your '..org..' enemies', 
      true)
      setUnderline(false)

      echo(")")
      echo("\n")
    end
  end

  local function showordermembers()
    local r = db:fetch_sql(ndb.db.people, [[SELECT DISTINCT "order" FROM 'people';]])
    if not r then return end

    table.sort(r, function(a,b) return a.order &lt; b.order end)

    local shownsomething
    svo.echof("Order members:")
    for i = 1, #r do
      if r[i].order ~= "" then
        shownsomething = true
        local order = r[i].order

        setFgColor(unpack(svo.getDefaultColorNums))
        echo("  ")
        setUnderline(true)
        echoLink(svo.conf["highlight"..order:lower()] and "Highlighting" or "Not highlighting", 
          'svo.config.set("highlight'..order:lower()..'", '..(svo.conf["highlight"..order:lower()] and "false" or "true")..', true); ndb.showpolitics()', 
          'Click to '..(svo.conf["highlight"..order:lower()] and "stop" or "start").. ' highlighting names of '..order:lower()..'\'s members',
        true)
        setUnderline(false)

        if not svo.conf["highlight"..order:lower()] then
          echo(" names of "..order.."'s Order members. ")
          echo((" "):rep(26-#order))
        else
          echo("     names of "..order.. "'s Order members in ")
          setUnderline(true)
          setFgColor(unpack(color_table[svo.conf[order:lower().."color"] or "a_darkwhite"]))
          echoLink(svo.conf[order:lower().."color"] or "a_darkwhite", 
            "printCmdLine'vconfig "..order:lower().."color '", 
            'Click to set the color of '..order:lower()..'\'s Order members', 
          true)
          setUnderline(false)
          setFgColor(unpack(svo.getDefaultColorNums))
          echo(", ")
          echo((" "):rep(22-#order-#(svo.conf[order:lower().."color"] or "a_darkwhite")))
        end
        
        echo("(")

        setUnderline(true)
        echoLink(svo.conf["bold"..order:lower()] and "bold" or "no bld", 
          'svo.config.set("bold'..order:lower()..'", '..(svo.conf["bold"..order:lower()] and "false" or "true")..', true); ndb.showpolitics()', 
          'Click to '..(svo.conf["bold"..order:lower()] and "stop" or "start").. ' bolding names '..order:lower()..'\'s Order members', 
        true)
        setUnderline(false)
        echo(", ")

        setUnderline(true)
        echoLink(svo.conf["underline"..order:lower()] and "undl" or "no undl", 
          'svo.config.set("underline'..order:lower()..'", '..(svo.conf["underline"..order:lower()] and "false" or "true")..', true); ndb.showpolitics()', 
          'Click to '..(svo.conf["underline"..order:lower()] and "stop" or "start").. ' underlining names '..order:lower()..'\'s Order members', 
        true)
        setUnderline(false)
        echo(", ")

        setUnderline(true)
        echoLink(svo.conf["italicize"..order:lower()] and "ital" or "no ital", 
          'svo.config.set("italicize'..order:lower()..'", '..(svo.conf["italicize"..order:lower()] and "false" or "true")..', true); ndb.showpolitics()', 
          'Click to '..(svo.conf["italicize"..order:lower()] and "stop" or "start").. ' italicizing names '..order:lower()..'\'s Order members',
        true)
        setUnderline(false)

        echo(")")
        echo("\n")
      end
    end

    if not shownsomething then
      setFgColor(unpack(svo.getDefaultColorNums))
      echo("  (no members of Orders are known)")
      resetFormat()
      echo("\n")
    end
  end

  -- watchfor &gt; divine &gt; city &gt; order &gt; house &gt; citizens
  showwatchfor()
  echo("\n")
  showdivines()
  echo("\n")
  showenemies()
  echo("\n")
  showordermembers()
  echo("\n")
  showcities()

  if not noprompt then svo.showprompt() end
end</script>
					<eventHandlerList>
						<string>svo system loaded</string>
					</eventHandlerList>
					<Script isActive="yes" isFolder="no">
						<name>ndb.onshow</name>
						<packageName></packageName>
						<script>function ndb.onshow()
    local c = table.size(svo.me.highlightignore)

    svo.echofn("# of people on the highlightignore: %d ", c)

    setFgColor(unpack(svo.getDefaultColorNums))
    setUnderline(true)
    echoLink("(view)", 'echo"\\n" expandAlias"vshow highlightignore"', 'Click here open the highlightignore list menu', true)
    echo"\n"
end</script>
						<eventHandlerList>
							<string>svo onshow</string>
						</eventHandlerList>
					</Script>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.loadsettings</name>
					<packageName></packageName>
					<script>function ndb.loadsettings()
  ndb.conf = ndb.conf or {}
  ndb.conf.citypolitics = ndb.conf.citypolitics or {}

  local conf_path = getMudletHomeDir() .. "/svo/namedb/citypolitics"

  if lfs.attributes(conf_path) then
    table.load(conf_path, ndb.conf.citypolitics)
  end

  -- setup defaults
  if next(ndb.conf.citypolitics) then return end

  -- include own city in table in case of org switch
  if svo.conf.org == "Shallam" then svo.config.set("org", "Targossas") end

  if svo.conf.org == "Targossas" then
    ndb.conf.citypolitics = {
      Ashtan = "enemy", Hashan = "enemy", Eleusis = "neutral", Cyrene = "ally", Mhaldor = "enemy", Targossas = "ally"
    }
  elseif svo.conf.org == "Mhaldor"  then
    ndb.conf.citypolitics = {
      Ashtan = "enemy", Hashan = "enemy", Eleusis = "enemy", Cyrene = "enemy", Targossas = "enemy", Mhaldor = "ally"
    }
  elseif svo.conf.org == "Ashtan"  then
    ndb.conf.citypolitics = {
      Mhaldor = "enemy", Hashan = "neutral", Eleusis = "enemy", Cyrene = "enemy", Targossas = "enemy", Ashtan = "ally"
    }
  elseif svo.conf.org == "Hashan"  then
    ndb.conf.citypolitics = {
      Mhaldor = "enemy", Ashtan = "neutral", Eleusis = "neutral", Cyrene = "neutral", Targossas = "enemy", Hashan = "ally"
    }
  elseif svo.conf.org == "Cyrene"  then
    ndb.conf.citypolitics = {
      Mhaldor = "neutral", Ashtan = "neutral", Eleusis = "neutral", Hashan = "neutral", Targossas = "ally", Cyrene = "ally"
    }
  elseif svo.conf.org == "Eleusis"  then
    ndb.conf.citypolitics = {
      Mhaldor = "enemy", Ashtan = "enemy", Cyrene = "neutral", Hashan = "neutral", Targossas = "neutral", Eleusis = "ally"
    }
  else
    ndb.conf.citypolitics = {
      Mhaldor = "neutral", Ashtan = "neutral", Cyrene = "neutral", Hashan = "neutral", Targossas = "neutral", Eleusis = "neutral"
    }
  end
end</script>
					<eventHandlerList>
						<string>svo system loaded</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.fixes</name>
					<packageName></packageName>
					<script>function ndb.fixed_set(field, value, query)
   local db_name = field.database
   local s_name = field.sheet

   local conn = db.__conn[db_name]

   local sql_update = [[UPDATE OR %s %s SET "%s" = %s]]
   if query then
       sql_update = sql_update .. [[ WHERE %s]]
   end

   local sql = sql_update:format(db.__schema[db_name][s_name].options._violations, s_name, field.name, db:_coerce(field, value), query)

   db:echo_sql(sql)
   assert(conn:execute(sql))
   if db.__autocommit[db_name] then
      conn:commit()
   end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.close</name>
					<packageName></packageName>
					<script>function ndb.close()
  db:close()
  ioprint("ndb.close sysExitEvent")
end</script>
					<eventHandlerList>
						<string>sysExitEvent</string>
					</eventHandlerList>
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>ndb.showqwi</name>
					<packageName></packageName>
					<script>function ndb.showqwi()
  if not ndb.checkingqwi then return end
  ndb.checkingqwi = nil

  ndb.checkqw(nil, "show infamous")
end</script>
					<eventHandlerList>
						<string>NameDB finished all honors</string>
					</eventHandlerList>
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.highlighter</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>ndb.addhighlightname</name>
					<packageName></packageName>
					<script>function ndb.addhighlightname(_, name)
  if not name then return end -- no name is passed on a suicided person

  local person = ndb.getname(name)

  if not person then return end -- in case a person was deleted
  ndb.singlehighlight(name,
      person.city or "", 
      person.order or "", 
      person.cityenemy or 0,
      person.orderenemy or 0, 
      person.houseenemy or 0, 
      svo.me.watchfor[person.name],
      person.immortal or 0)
end</script>
					<eventHandlerList>
						<string>NameDB finished honors</string>
						<string>svo watchfor name changed</string>
						<string>NameDB highlightignore name changed</string>
						<string>NameDB set name changed</string>
						<string>NameDB saw list name</string>
						<string>NameDB name deleted</string>
					</eventHandlerList>
				</Script>
			</Script>
			<Script isActive="yes" isFolder="no">
				<name>ndb.aliases</name>
				<packageName></packageName>
				<script>function ndb.showwhois(whom)
  whom = whom:lower():title()
  local data = ndb.getname(whom)

  if not data then svo.echof("I'm afraid we don't know person named %s.", matches[2]:title()) svo.showprompt() return end

  cecho("\n&lt;a_darkblue&gt;--&lt;purple&gt;(svo) &lt;a_grey&gt;"..data.name.."'s ("..data.gender:sub(1,1)..") NameDB profile&lt;a_darkblue&gt;" .. ("-"):rep(55-#data.name) .. "\n")

  local function getclass()
    return (data.class == '' and 'unknown' or data.class)
  end

  local function getxprank()
    return (data.xp_rank == -2 and 'unranked' or (data.xp_rank == -1 and 'unknown' or data.xp_rank))
  end

  local function getmight()
    return (data.might == -1 and 'unranked' or data.might)
  end

  local function getlevel()
    return ((data.level == -1 or data.level == 0 or data.level == nil) and 'unknown' or data.level)
  end

  local function getcombatrank()
    return (data.combat_rank &gt; 0
       and ("%d (rank) %d (score)"):format(data.combat_rank, data.combat_rating)
       or (data.combat_rank == 0 and 'unranked' or 'unknown'))
  end

  local function getdragon()
    return (data.dragon == 1 and 'yep' or 'nope')
  end

  local function getrace()
    return (data.race == '' and 'unknown' or data.race)
  end

  local function getbirthday()
    return ((data.birth_day ~= 0
       and ("%d %s(%d) %d"):format(data.birth_day, ndb.valid.months[data.birth_month], data.birth_month, data.birth_year)
       or '') .. (data.birth_hidden == 1 and ' (h)' or ''))

  end

  local function getimportance()
    return (data.importance == 0 and 'unset' or data.importance)
  end

  local function getinfamous()
    return (data.infamous == -1 and 'unknown' or (data.infamous == 0 and 'none' or ndb.valid.shortinfamous[data.infamous]))
  end

  if data.immortal == 0 then
    cecho("&lt;a_darkcyan&gt;  Orgs:\n")
    cecho(string.format("&lt;a_darkgrey&gt;    House:  %-24s City:        %s (cr%s)%s\n",
      (data.guild == '' and 'unknown' or data.guild),
      (data.city == '' and 'unknown' or data.city),
      (data.city_rank == 0 and '?' or data.city_rank),
      (data.city_soldier == 0 and '' or ' (S)')
    ))

    cecho(string.format("&lt;a_darkgrey&gt;    Order:  %-24s Mark:        %s\n",
      (data.order == '' and 'unknown' or data.order),
      (data.mark == '' and 'no' or data.mark)
    ))

    cecho("\n&lt;a_darkcyan&gt;  Personal:\n")
    cecho(string.format("&lt;a_darkgrey&gt;    Class:  %-24s Infamy:      %s\n",
      getclass(),
      getinfamous()
    ))
    cecho(string.format("&lt;a_darkgrey&gt;    Level:  %-24s XP rank:     %s\n",
      getlevel(),
      getxprank()
    ))
    cecho(string.format("&lt;a_darkgrey&gt;    Might:  %-24s Combat:      %s\n",
      getmight(),
      getcombatrank()
    ))
    cecho(string.format("&lt;a_darkgrey&gt;    Dragon: %-24s Race:        %s\n",
      getdragon(),
      getrace()
    ))
    cecho(string.format("&lt;a_darkgrey&gt;    Birth:  %-24s Importance:  %s\n",
      getbirthday(),
      getimportance()
    ))
    
    cecho("\n&lt;a_darkcyan&gt;  Status to you:\n")
    cecho(string.format("&lt;a_darkgrey&gt;    City enemy:  %-19s House enemy: %s\n",
      (data.cityenemy == 0 and 'nope' or 'yep'),
      (data.houseenemy == 0 and 'nope' or 'yep')
    ))

    cecho(string.format("&lt;a_darkgrey&gt;    Order enemy: %-19s \n",
      data.orderenemy == 0 and 'nope' or 'yep'
    ))

    local currenstatus
    if data.iff == -1 then
      if ndb.isenemy(data.name) then currenstatus = "enemy (auto)"
      else currenstatus = "ally (auto)" end
    end

    cecho(string.format("&lt;a_darkgrey&gt;    Actual status to you: %s\n", 
      (data.iff == -1 and currenstatus or (data.iff == 1 and "enemy (manual)" or "ally (manual)"))
    ))
  else
    cecho("\n&lt;a_darkcyan&gt;    They are an Immortal.\n")
  end

  cecho("\n&lt;a_darkcyan&gt;  Notes (")
  setUnderline(true)
  fg("a_darkcyan")
  echoLink("edit", 'printCmdLine"ndb set '..whom:title()..' notes '..data.notes:gsub("\n", [[\\n]])..'"', 'Click to edit the notes you have on '..whom:title()..' - you can use \\n for a linebreak, and &lt;color&gt; to color text', true)
  resetFormat()
  cecho("&lt;a_darkcyan&gt;):\n")
  cecho(string.format("    &lt;a_blue&gt;- &lt;a_grey&gt;"..((data.notes and data.notes ~= "") and data.notes:gsub("\n", "\n    &lt;a_blue&gt;-&lt;reset&gt; ") or "none yet").."\n"))
  deselect() fg("a_darkblue") echo(string.rep("-", 80)) resetFormat() echo'\n'
  svo.showprompt()
end

function ndb.exportmenu()
  svo.echof("Exporting works in 3 steps:\n")

  setFgColor(unpack(svo.getDefaultColorNums))
  echo("a) select what data about people you'd like to export:\n")
  for key, _ in pairs(ndb.schema.people) do
    echo("  ")

    if key == "name" then
      echoLink("[X] name", [[svo.echof("The name has to stay, otherwise what'll be there to import?")]], "If you'd just like to share the list of names known, you can tick everything else off and leave this on", true)
    else
      echoLink("["..(ndb.exportdata.fields[key] and 'X' or ' ')..'] '..key, 
        [[ndb.exportdata.fields.]]..key..[[ = ]]..tostring(not ndb.exportdata.fields[key])..[[;ndb.exportmenu()]],
        'Click to '..(not ndb.exportdata.fields[key] and 'add' or 'remove') .. ' '..key .. ' for export', true)
    end
    echo("\n")
  end

  echo("\n")
  echo("b) select which people you'd like to export:\n")
  for key, _ in pairs(ndb.exportdata.people) do
    setFgColor(unpack(svo.getDefaultColorNums))
    echo("  ")

    echoLink("["..(ndb.exportdata.people[key] and 'X' or ' ')..'] '..key, 
      [[ndb.exportdata.people.]]..key..[[ = ]]..tostring(not ndb.exportdata.people[key])..[[;ndb.exportmenu()]],
      (ndb.exportdata.people[key] and 'Click to export '..key or 'Click not to export '..key), true)

    echo("\n")
  end

  echo("\n")
  echo("d) select a folder to export to: ")
  setUnderline(true)
  echoLink((not ndb.exportdata.location and "&lt;folder&gt;" or ndb.exportdata.location), [[
    ndb.exportdata.location = invokeFileDialog(false, "Where do you want to save the file? Select it and click Open")
    if ndb.exportdata.location == "" then ndb.exportdata.location = false end
    ndb.exportmenu()]],
    '', true)
  setUnderline(false)
  echo("\n")

  echo("\n")
  svo.echofn("All set? ")

  setUnderline(true)
  setFgColor(unpack(svo.getDefaultColorNums))
  echoLink("Export!", (not ndb.exportdata.location and 'svo.echof("Pick a folder to export to, silly.")' or 'ndb.doexport()'), 'Click to export', true)
  setUnderline(false)
end

function ndb.importmenu()
  svo.echof("Import NameDB data:")

  setFgColor(unpack(svo.getDefaultColorNums))
  echo("\n")
  if not ndb.importdata.location then echo("a) select a file to import: ") else echo("a) file to import: ") end
  setUnderline(true)
  echoLink((not ndb.importdata.location and "&lt;file&gt;" or ndb.importdata.location), [[
    ndb.importdata.location = invokeFileDialog(true, "Pick the file you'd like to import and select Open")
    if ndb.importdata.location == "" then ndb.importdata.location = false end
    if ndb.importdata.location then ndb.getimportfields() end
    ndb.importmenu()]],
    '', true)
  setUnderline(false)
  echo("\n")

  echo("\n")
  if not ndb.importdata.data then
    echo("b) select which fields to import once you've picked a file")
  else
    echo("b) select which fields to import:\n")
    for key, _ in pairs(ndb.importdata.fields) do
      echo("  ")

      if key == "name" then
        echoLink("[X] name", [[svo.echof("The name has to stay, otherwise how will the import data make sense?")]], "The persons name - this has to stay", true)
      else
        echoLink("["..(ndb.importdata.fields[key] and 'X' or ' ')..'] '..key, 
          [[ndb.importdata.fields.]]..key..[[ = ]]..tostring(not ndb.importdata.fields[key])..[[;ndb.importmenu()]],
          'Click to '..(not ndb.importdata.fields[key] and 'add' or 'remove') .. ' '..key .. ' for import', true)
      end
      echo("\n")
    end
  end
  echo("\n")

  echo("\n")
  svo.echofn("All set? ")

  setUnderline(true)
  setFgColor(unpack(svo.getDefaultColorNums))
  echoLink("Import!", (not ndb.importdata.data and 'svo.echof("Pick a file to import first!")' or 'ndb.doimport()'), 'Click to import', true)
  setUnderline(false)
  echo("\n")
end

function ndb.checkqw(suffix, how)
  if ndb.qwtimer then killTimer(ndb.qwtimer) end

  enableTrigger("NameDB qw")
  ndb.qwtimer = tempTimer(3, function() disableTrigger("NameDB qw"); ndb.qwtimer = nil end)
  ndb.qwtype = how

  send("qwc", false)
end</script>
				<eventHandlerList />
			</Script>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Data Input</name>
				<packageName></packageName>
				<script>-------------------------------------------------
--         Put your Lua functions here.        --
--                                             --
-- Note that you can also use external Scripts --
-------------------------------------------------
</script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Names from Semla Feb 10th 2010</name>
					<packageName></packageName>
					<script>if true then return end

--

local temp_name_list = {}

for key,value in pairs(citizens:split("|")) do
	temp_name_list[key] = {name = value, xp_rank = -1}
end

db:merge_unique(ndb.db.people, temp_name_list)

raiseEvent("NameDB got new data")</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<ScriptGroup isActive="yes" isFolder="yes">
				<name>Third-party</name>
				<packageName></packageName>
				<script></script>
				<eventHandlerList />
				<Script isActive="yes" isFolder="no">
					<name>Pluralization</name>
					<packageName></packageName>
					<script>--
-- MySQL Workbench Doctrine Export Plugin
-- Version: 0.3.6
-- Authors: Johannes Mueller, Karsten Wutzke
-- Copyright (c) 2008-2009
--
-- http://code.google.com/p/mysql-workbench-doctrine-plugin/
--
-- This file is free software: you can redistribute it and/or
-- modify it under the terms of the GNU Lesser General Public
-- License as published by the Free Software Foundation, either
-- version 3 of the License, or (at your option) any later version.
--
-- This library is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-- Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public
-- License along with this library.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
--

function string.endswith(s, suffix)
    return s:sub(#s - #suffix + 1) == suffix
end

function isPlural(s)
    -- is plural if string ends with an "s" but not with "ss"
    return string.endswith(s, "s") and not string.endswith(s, "ss") and #s &gt; 1
end

function isSingular(s)
    -- is singular if not plural
    return not isPlural(s)
end

local t = {
    "bison", "magi", "buffalo", "deer", "fish", "sheep", "salmon", "trout", "swine", "plankton", "squid"
}
local irregularPlurals = {}
for _,v in ipairs(t) do irregularPlurals[v] = true end

function isIrregular(s)
    return irregularPlurals[s] and true or false
end

function string.singularize(s)

    -- is plural?
    if ( isPlural(s) ) then
        -- strip "s"
        s = string.sub(s, 1, #s - 1)

        -- we can't just strip the s without looking at the remaining English plural endings
        -- see http://en.wikipedia.org/wiki/English_plural

        -- if the table name ends with "e" ("coache", "hashe", "addresse", "buzze", "heroe", ...)
        if (    string.endswith(s, "che")
             or string.endswith(s, "she")
             or string.endswith(s, "sse")
             or string.endswith(s, "zze")
             or string.endswith(s, "oe") ) then

            -- strip an "e", too
            s = string.sub(s, 1, #s - 1)

        -- if table name ends with "ie"
        elseif ( string.endswith(s, "ie") ) then
            -- replace "ie" by a "y" ("countrie" -&gt; "country", "hobbie" -&gt; "hobby", ...)
            s = string.sub(s, 1, #s - 2) .. "y"

        elseif ( string.endswith(s, "ve") ) then
            -- replace "ve" by an "f" ("calve" -&gt; "calf", "leave" -&gt; "leaf", ...)
            s = string.sub(s, 1, #s - 2) .. "f"

            -- does *not* work for certain words ("knive" -&gt; "knif", "stave" -&gt; "staf", ...): TODO (hard)
        else
            -- do nothing ("game", "referee", "monkey", ...)

            -- note: table names like "Caches" can't be handled correctly because of the "che" rule above,
            -- that word however basically stems from French and might be considered a special case anyway
            -- also collective names like "Personnel", "Cast" (caution: SQL keyword!) can't be singularized
        end
    end

    return s
end

function string.pluralize(s)

    -- is singular?
    if ( isSingular(s) and not isIrregular(s) ) then

        -- we can't just append the s without looking at the English singular endings
        -- see https://en.wikipedia.org/wiki/English_plural

        -- if the table name ends with "ch", "sh", "ss" or "zz" ("coach", "hash", "address", "buzz", "hero", ...)
        if (    string.endswith(s, "ch")
             or string.endswith(s, "sh")
             or string.endswith(s, "ss")
             or string.endswith(s, "zz")
             or string.endswith(s, "o") ) then

            -- append "es"
            s = s .. "es"

        -- if table name ends with "y"
        elseif ( string.endswith(s, "y") ) then
            -- replace "y" with "ies" ("country" -&gt; "countries", "hobby" -&gt; "hobbies", ...)
            s = string.sub(s, 1, #s - 1) .. "ies"

        elseif ( string.endswith(s, "f") ) then
            -- replace "f" by an "ves" ("leaf" -&gt; "leaves", "half" -&gt; "halves", ...)
            s = string.sub(s, 1, #s - 1) .. "ves"
        else
            -- append "s" ("games", "referees", "monkeys", ...)
            s = s .. "s"
        end
    end

    return s
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Ordinal</name>
					<packageName></packageName>
					<script>function string.ordinalSuffix (n)
  n = math.mod (n, 100)
  local d = math.mod (n, 10)
  if d == 1 and n ~= 11 then
    return "st"
  elseif d == 2 and n ~= 12 then
    return "nd"
  elseif d == 3 and n ~= 13 then
    return "rd"
  else
    return "th"
  end
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Stats</name>
					<packageName></packageName>
					<script>-- Small stats library                      --
----------------------------------------------
-- Version History --
-- 1.0 First written.

-- Tables supplied as arguments are not changed.


-- Table to hold statistical functions
stats={}

-- Get the mean value of a table
function stats.mean( t )
  local sum = 0
  local count= 0

  for k,v in pairs(t) do
    if type(v) == 'number' then
      sum = sum + v
      count = count + 1
    end
  end

  return (sum / count)
end

-- Get the mode of a table.  Returns a table of values.
-- Works on anything (not just numbers).
function stats.mode( t )
  local counts={}

  for k, v in pairs( t ) do
    if counts[v] == nil then
      counts[v] = 1
    else
      counts[v] = counts[v] + 1
    end
  end

  local biggestCount = 0

  for k, v  in pairs( counts ) do
    if v &gt; biggestCount then
      biggestCount = v
    end
  end

  local temp={}

  for k,v in pairs( counts ) do
    if v == biggestCount then
      table.insert( temp, k )
    end
  end

  return temp
end

-- Get the median of a table.
function stats.median( t )
  local temp={}

  -- deep copy table so that when we sort it, the original is unchanged
  -- also weed out any non numbers
  for k,v in pairs(t) do
    if type(v) == 'number' then
      table.insert( temp, v )
    end
  end

  table.sort( temp )

  -- If we have an even number of table elements or odd.
  if math.fmod(#temp,2) == 0 then
    -- return mean value of middle two elements
    return ( temp[#temp/2] + temp[(#temp/2)+1] ) / 2
  else
    -- return middle element
    return temp[math.ceil(#temp/2)]
  end
end


-- Get the standard deviation of a table
function stats.standardDeviation( t )
  local m
  local vm
  local sum = 0
  local count = 0
  local result

  m = stats.mean( t )

  for k,v in pairs(t) do
    if type(v) == 'number' then
      vm = v - m
      sum = sum + (vm * vm)
      count = count + 1
    end
  end

  result = math.sqrt(sum / (count-1))

  return result
end

-- Get the max and min for a table
function stats.maxmin( t )
  local max = -math.huge
  local min = math.huge

  for k,v in pairs( t ) do
    if type(v) == 'number' then
      max = math.max( max, v )
      min = math.min( min, v )
    end
  end

  return max, min
end</script>
					<eventHandlerList />
				</Script>
				<Script isActive="yes" isFolder="no">
					<name>Seconds to human</name>
					<packageName></packageName>
					<script>-- credit: http://www.gammon.com.au/forum/?id=12494&amp;reply=6#reply6
function seconds2human(input)
  local seconds = input
  local hours = math.floor(seconds/3600) -- only returns whole numbers
  seconds = seconds%3600 -- returns remainder of previous division
  local minutes = math.floor(seconds/60) -- only whole numbers again
  seconds = seconds%60 -- final remainder

  return hours, minutes, seconds
end</script>
					<eventHandlerList />
				</Script>
			</ScriptGroup>
			<Script isActive="yes" isFolder="no">
				<name>ndb main code</name>
				<packageName></packageName>
				<script>-- Svof (c) 2011-2018 by Vadim Peretokin

-- Svof is licensed under a
-- Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.

-- You should have received a copy of the license along with this
-- work. If not, see &lt;http://creativecommons.org/licenses/by-nc-sa/4.0/&gt;.

-- load after Svof has loaded to have svo.pl
tempTimer(0, function()

local me = svo.me
local firstload = not ndb.ismhaldorian

svo.pl.dir.makepath(getMudletHomeDir() .. "/svo/namedb")

-- load the highlightignore list
function ndb.loadhighlightignore()
  local conf_path = getMudletHomeDir() .. "/svo/config/highlightignore"

  if lfs.attributes(conf_path) then
    local t = {}
    local ok, msg = pcall(table.load, conf_path, t)
    if ok then
	    me.highlightignore = me.highlightignore or {} -- make sure it's initialized
	    svo.update(me.highlightignore, t)
	else
		os.remove(conf_path)
		tempTimer(10, function()
		  svo.echof("Your NameDB highlights ignored file got corrupted for some reason - I've deleted it so the system can load other stuff OK. You'll need to re-do all the names to ignore highlighting, though. (%q)", msg)
		end)
	end
  end
end
if firstload then ndb.loadhighlightignore() end
svo.signals.saveconfig:connect(function () me.highlightignore = me.highlightignore or {}; svo.tablesave(getMudletHomeDir() .. "/svo/config/highlightignore", me.highlightignore) end, 'save highlightignore list')

-- save the ndb.conf.citypolitics list
if ndb.conf == nil then ndb.loadsettings() end
svo.signals.saveconfig:connect(function () ndb.conf.citypolitics = ndb.conf.citypolitics or {}; svo.tablesave(getMudletHomeDir() .. "/svo/namedb/citypolitics", ndb.conf.citypolitics) end, 'save citypolitics list')


svo.signals.saveconfig:connect(function ()
	-- this can error out if the connection is closed
  pcall(function() db.__conn['namedb']:execute('VACUUM') end)
end, 'vacuum namedb database')

--ndb.API
function ndb.ismhaldorian(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, 'Mhaldor'), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.iscyrenian(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, 'Cyrene'), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isshallamese(name)
  return #(db:fetch(ndb.db.people, {db:OR(db:eq(ndb.db.people.city, 'Shallam'), db:eq(ndb.db.people.city, 'Targossas')), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.istargossian(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, 'Targossas'), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.iseleusian(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, 'Eleusis'), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isashtani(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, 'Ashtan'), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.ishashani(name)
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.city, 'Hashan'), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.isclass(name, class)
  name, class = name:title(), class:lower()
  return #(db:fetch(ndb.db.people, {db:eq(ndb.db.people.class, class), db:eq(ndb.db.people.name, name)})) ~= 0
end

function ndb.getclass(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].class:lower()
end

function ndb.setclass(name, class)
  class = class:lower()
  svo.assert(ndb.isvalidclass(class), "ndb.setclass: invalid class given")

  ndb.fixed_set(ndb.db.people.class, class, db:eq(ndb.db.people.name, name))
end

function ndb.getcity(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].city
end

function ndb.getnotes(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].notes
end

function ndb.getxprank(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return r[1].xp_rank
end

function ndb.ismark(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  if r[1].mark == "" then return false
  else return r[1].mark end
end

function ndb.setmark(name, type)
  if type == false then type = "" end

  ndb.fixed_set(ndb.db.people.mark, type, db:eq(ndb.db.people.name, name))
end

function ndb.isinfamous(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  if r[1].infamous == "" then return false
  else return r[1].infamous end
end

function ndb.setinfamous(name, infamy)
  ndb.fixed_set(ndb.db.people.infamous, infamy, db:eq(ndb.db.people.name, name))
end

function ndb.isdragon(name)
  svo.assert(name, "ndb.isdragon() requires a name")

  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return (r[1].dragon == 1 and true or false)
end

function ndb.getcityrank(name)
  svo.assert(name, "ndb.getcityrank() requires a name")

  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return ndb.valid.cityranks[r[1].city][r[1].city_rank]
end

function ndb.setdragon(name, status)
  status = svo.toboolean(status) and 1 or 0

  ndb.fixed_set(ndb.db.people.dragon, status, db:eq(ndb.db.people.name, name))
end

function ndb.isimmortal(name)
  name = name:title()
  local r = db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))
  if not next(r) then return nil, "name not known" end

  return (r[1].immortal == 1 and true or false)
end

function ndb.exists(name)
  return #(db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))) ~= 0
end

function ndb.isperson(name)
  return #(db:fetch(ndb.db.people, db:eq(ndb.db.people.name, name))) ~= 0
end

-- returns true only if a certain enemy
function ndb.isenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local city = p.city

  -- -1 autodetected, 1 enemy, 2 ally
  if p.iff == 1 or
       (p.iff ~= 2 and
         ((city and city ~= "" and ndb.conf.citypolitics[city] == 'enemy') or
         (p.cityenemy == 1 or p.orderenemy == 1 or p.houseenemy == 1))) then
    return true else return false
  end
end

-- returns true if they are a soldier of their city
function ndb.issoldier(name)
  local p = ndb.getname(name)
  if not p then return false end

  local soldier = p.soldier

 -- only return true for soldier of their city
  if p.city_soldier == -2 then
    return true else return false
  end
end

-- returns true only if someone is a city enemy. They could be a house enemy, order enemy, or politics enemy and not be considered an enemy by this
function ndb.isonlycityenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local city = p.city

 -- only return true for city enemy
  if p.cityenemy == 1 then
    return true else return false
  end
end

-- returns true only if someone is an enemy via iff or is a city enemy. They could be a house enemy, and not be considered an enemy by this
function ndb.iscityenemy(name)
  local p = ndb.getname(name)
  if not p then return false end

  local city = p.city

  -- -1 autodetected, 1 enemy, 2 ally
  if p.iff == 1 or
       (p.iff ~= 2 and
         ((city and city ~= "" and ndb.conf.citypolitics[city] == 'enemy') or
         (p.cityenemy == 1))) then
    return true else return false
  end
end

-- given a title, returns all info about a person
function ndb.getnamebytitle (title)
  return db:fetch(ndb.db.people, db:in_(ndb.db.people.name, string.split(title, " ")))
end

-- given a line, returns the first name it finds, if any
function ndb.findname(line)
  for w in string.gmatch(line, "(%u%l+)") do
    if #w &gt;= 3 then
      if ndb.isperson(w) then return w end
    end
  end
end

-- given a line, returns all names found on it
function ndb.findnames(line)
  local l = {}
  for w in string.gmatch(line, "(%u%l+)") do
    if #w &gt;= 3 then
      if ndb.isperson(w) then l[#l+1] = w end
    end
  end

  if l[1] then return l end
end

-- given a name, returns all info about a person
function ndb.getname (name)
  return db:fetch(ndb.db.people, db:eq(ndb.db.people.name, string.title(name)))[1]
end

local singular_city = {
  [""] = 'Rogue',
  Mhaldor = 'Mhaldorian',
  Ashtan = 'Ashtani',
  Hashan = 'Hashani',
  Eleusis = 'Eleusian',
  Shallam = 'Shallamese',
  Targossas = 'Targossian',
  Cyrene = 'Cyrenian'
}

local plural_city = {
  [""] = 'Rogues',
  Mhaldor = 'Mhaldorians',
  Ashtan = 'Ashtani',
  Hashan = 'Hashani',
  Eleusis = 'Eleusians',
  Shallam = 'Shallamese',
  Targossas = 'Targossians',
  Cyrene = 'Cyrenians'
}

local plural_class = {
  Apostate    = 'Apostates',
  Bard        = 'Bards',
  Blademaster = 'Blademasters',
  Dragon      = 'Dragons',
  Druid       = 'Druids',
  Infernal    = 'Infernals',
  Jester      = 'Jesters',
  Magi        = 'Magi',
  Monk        = 'Monks',
  Occultist   = 'Occultists',
  Paladin     = 'Paladins',
  Priest      = 'Priests',
  Runewarden  = 'Runewardens',
  Sentinel    = 'Sentinels',
  Serpent     = 'Serpents',
  Shaman      = 'Shamans',
  Sylvan      = 'Sylvans',
}

function ndb.getpluralclass(class, count)
  if count &lt;= 1 then
    return class
  else
    return plural_class[class]
  end
end

function ndb.getpluralcity(city, count)
  if count &lt;= 1 then
    return singular_city[city]
  else
    return plural_city[city]
  end
end

local function getcolor(name)
  local person = ndb.getname(name)

  if not person then return "" end -- in case the person doesn't exist

  local city, order, conf, color = person.city, person.order, svo.conf

  -- order of priority: watchfor &gt; divine &gt; city &gt; order &gt; house &gt; citizens.
  if (city == "" or city == 'rogue') then city = "" else city = city:lower() end -- known rogues are returned as ""

  -- color first
  if conf.highlightwatchfor and svo.me.watchfor[name] then
    color     = conf.watchforcolor or 'a_darkwhite'

  elseif conf.highlightdivine and person.immortal == 1 then
    color     = conf.divinecolor or 'a_darkwhite'

  elseif conf.highlightcity and person.cityenemy == 1 then
    color     = conf.citycolor or 'a_darkwhite'

  elseif conf.highlightorder and person.orderenemy == 1 then
    color     = conf.ordercolor or 'a_darkwhite'

  elseif conf.highlighthouse and person.houseenemy == 1 then
    color     = conf.housecolor or 'a_darkwhite'

  elseif order and conf['highlight'..order] then
    color     = conf[order..'color'] or 'a_darkwhite'

  elseif city == "" and conf.highlightrogues then
    color     = conf.roguescolor or 'a_darkwhite'

  elseif city ~= "" and conf['highlight'..city] then
    color     = conf[city..'color'] or 'a_darkwhite'
  end

  return color
end

function ndb.getcolor(name)
  svo.assert(type(name) == 'string', "ndb.getcolor: name to get a color of is required")

  local color = getcolor(name)

  return ((color and color ~= "") and '&lt;'..color..'&gt;' or "")
end

function ndb.getcolorn(name)
  svo.assert(type(name) == 'string', "ndb.getcolorn: name to get a color of is required")

  local color = getcolor(name)

  return ((color and color ~= "") and ('&lt;'..color..'&gt;'..name..'&lt;reset&gt;') or name)
end

function ndb.getcolorp(name)
  svo.assert(type(name) == 'string', "ndb.getcolorp: name to get a color of is required")

  local color = getcolor(name)

  return color
end

for _, format in ipairs{'bold', 'underline', 'italicize'} do
  ndb['should'..format] = function(name)
    svo.assert(type(name) == 'string', "ndb.should"..format..": name to get a color of is required")

    local person = ndb.getname(name)

    if not person then return false end -- in case the person doesn't exist

    local city, order, conf = person.city, person.order, svo.conf

    return (conf[format..'watchfor'] and svo.me.watchfor[name])    or
           (conf[format..'city'] and person.cityenemy == 1)        or
           (conf[format..'order'] and person.orderenemy == 1)      or
           (conf[format..'house'] and person.houseenemy == 1)      or
           (conf[format..'divine'] and person.immortal == 1)       or
           (order and conf[format..order])                         or
           ((city == "" or city == 'rogue') and conf[format..'rogues']) or
           (city and conf[format..city])                           or false
  end
end

function ndb.addname(name)
  local temp_name_list = {}

  if type(name) == 'table' then
    for i = 1, #name do
      temp_name_list[#temp_name_list+1] = {name = name[i]:title()}
    end
  else
    temp_name_list = {{name = name:title()}}
  end

  db:merge_unique(ndb.db.people, temp_name_list)

  raiseEvent("NameDB got new data")
end

function ndb.setiff(name, status)
  name = name:lower():title()

  local category = 'iff'
  local towhat

  -- -1 autodetected, 1 enemy, 2 ally
  status = status:lower()
  if status == 'enemy' then
    towhat = 1
  elseif status == 'ally' then
    towhat = 2
  else
    towhat = -1
  end

  local temp_name_list = {{
    name = name,
    [category] = towhat
  }}

  db:merge_unique(ndb.db.people, temp_name_list)
end

-- ndb.support

function ndb.tablemerge(t, other)
   for other_key, other_items in pairs(other) do
      if not t[other_key] then
         t[other_key] = other_items
      else
         local group = t[other_key]
         for item_key, item_value in pairs(other_items) do
            group[item_key] = item_value
         end
      end
   end
   return t
end

-- given a string and a table of possible answers, returns the first possible answer, if any
function ndb.findfromtable(input, valid)
  local sfind = string.find

  for i = 1, #valid do
    if sfind(input, valid[i], 1, true) then return valid[i] end
  end
end

function ndb.showinfamous()
  local infamous = {}
  for _, person in pairs(db:fetch(ndb.db.people, db:gte(ndb.db.people.infamous, 1))) do
    local infamy = ndb.isinfamous(person.name)

    if infamy and infamy &gt;= 1 then
      infamous[infamy] = infamous[infamy] or {}
      infamous[infamy][#infamous[infamy]+1] = person.name
    end
  end

  svo.echof("Infamous names known in NameDB:")
  if not next(infamous) then svo.echof("(none found)") end
  for cat, people in pairs(infamous) do
    table.sort(people)
    echo(string.format("  %s: %s\n", ndb.valid.shortinfamous[cat], svo.concatand(people)))
  end
  svo.showprompt()
end

function ndb.showhelp(entry)
  svo.echof("&lt;0,250,0&gt;"..ndb.help[entry].term.."&lt;47,79,79&gt;: "..svo.getDefaultColor()..table.concat(ndb.help[entry].definition, "\n"))
  svo.showprompt() echo'\n'
end

function ndb.honors(name, type)
  if ndb.honorsid then svo.echof("ndb.honors() for %s called, when already honours'ing %s - not going to do this.", name:title(), ndb.honorsname:title()) return end
  name = string.title(name)

  enableTrigger('Honors')

  if ndb.honorsid then killTimer(ndb.honorsid) end
  ndb.honorsid = tempTimer(2+getNetworkLatency(), function()
    disableTrigger('Honors')
    svo.echof("Honors on %s didn't happen - re-checking...", name)
    ndb.honorsid, ndb.gaghonours = nil, nil
    ndb.honors(name, type)
  end)

  ndb.honorsname = name
  send("honorsb " .. name, false) -- needs to full so it sees the clan listing

  if type == 'quiet' then ndb.gaghonours = true end
end

function ndb.cancelhonors(quietly)
  ndb.manualcheck = nil
  ndb.checkingqwi = nil

  if (ndb.honorslist and next(ndb.honorslist)) or ndb.honorsid then
    ndb.honorslist = {}
    if ndb.honorsid then killTimer(ndb.honorsid) disableTrigger('Honors') end; ndb.honorsid = nil
    if not quietly then svo.echof("Cancelled honors-checking people.") end
  else
    if not quietly then svo.echof("Not checking anyone atm already.") end
  end
  if not quietly then svo.showprompt() end

  ndb.hidehonorswindow()
end

function ndb.getrankincity(city, name)
  city, name = city:title(), name:title()

  if ndb.valid.cityranks[city] then return ndb.valid.cityranks[city][name] end
end

-- update all info that we should be able to glean from honors.
-- might: if it's at -1, then it's default known
-- rank: -1 default unknown, -2 unranked
function ndb.updatebyhonors()
  -- took might check off, as the website doesn't show it
  if not svo.conf.usehonors then return end -- Achaea disallowed use of website scraping, can only honors on a 2s eq

  local data = db:fetch(ndb.db.people, db:AND(db:not_eq(ndb.db.people.immortal, 1), db:eq(ndb.db.people.xp_rank, -1)))

  ndb.honorslist = (function ()
    local t = {}
    for _,j in ipairs(data) do
      -- sanity check for weird names
      if j.name:find("^%u%l+$") then t[j.name] = true
      else db:delete(ndb.db.people, db:eq(ndb.db.people.name, j.name)) end
    end return t end)()

    if svo.conf.paused or not next(ndb.honorslist) then return end

    if not svo.conf.autocheck and not ndb.manualcheck then
      if table.size(ndb.honorslist) &gt; 1 then
        echo'\n'
        if table.size(ndb.honorslist) &lt;= 10 then
          svo.echofn("Got new names (%s), use '", svo.oneconcat(ndb.honorslist))
          setFgColor(unpack(svo.getDefaultColorNums))
          setUnderline(true)
          echoLink("ndb honorsnew", 'ndb.manualcheck = true; ndb.updatebyhonors()', 'Click to do ndb honorsnew', true)
          setUnderline(false)
          echo("' to check them.\n")
        else
          svo.echofn("Got %d new names, use '", table.size(ndb.honorslist))
          setFgColor(unpack(svo.getDefaultColorNums))
          setUnderline(true)
          echoLink("ndb honorsnew", 'ndb.manualcheck = true; ndb.updatebyhonors()', 'Click to do ndb honorsnew', true)
          setUnderline(false)
          echo("' to check them.\n")
        end
      end

      return
    end

    -- don't show anymore - checking isn't so intrusive anymore
    -- if table.size(ndb.honorslist) &lt;= 10 then
    --   echo'\n' svo.echof("Have new names (%s) - going to check them.", svo.oneconcat(ndb.honorslist))
    -- else
    --   echo'\n' svo.echof("Have %s new names - going to check them.", table.size(ndb.honorslist))
    -- end

  if not ndb.honorsid then ndb.honors_next() end
end

function ndb.doexport()
  if not ndb.exportdata.location then return nil, "no export location" end

  local alldata = db:fetch(ndb.db.people)

  if not alldata or not next(alldata) then svo.echof("Your NameDB is empty! Check 'qw', 'citizens' to start filling it up. There's nothing to export otherwise...") return end

  for i = 1, #alldata do
    local p = alldata[i]

    -- see if we need to prune the result first
    if not ndb.exportdata.people.all then
      alldata[i] = nil

    else
      -- prune fields we don't need
      for key,value in pairs(ndb.exportdata.fields) do
        if key ~= 'name' and not value then p[key] = nil end
      end

      -- prune internal fields starting with underscores
      local removekeys = {}
      for key, _ in pairs(p) do
        if key:sub(1,1) == '_' then
          removekeys[#removekeys+1] = key
        end
      end
      if not next(removekeys) == nil then
        for _ = 1, #removekeys do p[removekeys[i]] = nil end
      end
    end
  end

  -- build the final table that we'll svo.tablesave()
  local exportable = {
    meta = { author = gmcp.Char.Status.name, date = os.date("%A %d, %b '%y"), fields =  ndb.exportdata.fields },
    data = alldata
  }

  local location = string.format("%s/%s's namedb, %s", ndb.exportdata.location, gmcp.Char.Status.name,os.date("%A %d, %b '%y"))
  svo.tablesave(location, exportable)
  echo'\n' svo.echof("Data exported okay, it's in %s.", location)
end

-- reads selected files for fields available within it to import
function ndb.getimportfields()

  if not ndb.importdata.location or not io.exists(ndb.importdata.location) then ndb.importdata.location = nil; return end

  ndb.importdata.data = {}
  table.load(ndb.importdata.location, ndb.importdata.data)
  if not ndb.importdata.data then svo.echof("Couldn't read the file - maybe it's corrupted? Try another.") return end

  for k,_ in pairs(ndb.importdata.data.meta.fields) do if ndb.schema.people[k] then ndb.importdata.fields[k] = true end end
end

function ndb.doimport()
  if not ndb.importdata.data then return nil, "no data loaded in ndb.importdata.data" end

  -- copy data over for importing with only the fields we need
  local temp_name_list = {}

  -- data.data as the original data is stored in .data of the new field that's imported.
  for i = 1, #ndb.importdata.data.data do
    local p = ndb.importdata.data.data[i]

    temp_name_list[#temp_name_list + 1] = {
      name = p.name,
    }

    for k,v in pairs(p) do
      if ndb.importdata.fields[k] then
        temp_name_list[#temp_name_list][k] = v
      end
    end
  end

  db:merge_unique(ndb.db.people, temp_name_list)
  svo.echof("Imported %d name%s okay.", #temp_name_list, (#temp_name_list == 1 and '' or 's'))

  local c = #(db:fetch(ndb.db.people, db:eq(ndb.db.people.city, 'Shallam')))
  if c ~= 0 then
    ndb.fixed_set(ndb.db.people.city, 'Targossas', db:eq(ndb.db.people.city, 'Shallam'))
    svo.echof("Migrated "..c.." Shallamese to be called Targossians now.")
  end

  raiseEvent("NameDB got new data")
  ndb.importdata.data = nil
end

function ndb.loadhighlights()
  ndb.highlightIDs = ndb.highlightIDs or {}
  collectgarbage('stop')

  ndb.cleartriggers()

  if svo.conf.ndbpaused then return end

  local highlight, watchfor = ndb.singlehighlight, svo.me.watchfor

  local dbnames = db:fetch(ndb.db.people)

  for i = 1, #dbnames do
    highlight(dbnames[i].name,
      dbnames[i].city or "",
      dbnames[i].order or "",
      dbnames[i].cityenemy or 0,
      dbnames[i].orderenemy or 0,
      dbnames[i].houseenemy or 0,
      watchfor[dbnames[i].name],
      dbnames[i].immortal or 0
    )
  end

  collectgarbage()
end

function ndb.singlehighlight(name, city, order, cityenemy, orderenemy, houseenemy, watchfor, immortal)
  if ndb.highlightIDs and ndb.highlightIDs[name] then
    killTrigger(ndb.highlightIDs[name])
  end

  if name == svo.me.name or svo.me.highlightignore[name] or svo.conf.ndbpaused then return end

  local color, bold, underline, italicize
  local conf = svo.conf

  -- order of priority: watchfor &gt; divine &gt; city &gt; order &gt; house &gt; citizens.

  city = city:lower()
  if order == "" then order = false else order = order:lower() end

  -- color first
  if conf.highlightwatchfor and watchfor then
    color     = conf.watchforcolor or 'a_darkwhite'

  elseif conf.highlightdivine and immortal == 1 then
    color     = conf.divinecolor or 'a_darkwhite'

  elseif conf.highlightcity and cityenemy == 1 then
    color     = conf.citycolor or 'a_darkwhite'

  elseif conf.highlightorder and orderenemy == 1 then
    color     = conf.ordercolor or 'a_darkwhite'

  elseif conf.highlighthouse and houseenemy == 1 then
    color     = conf.housecolor or 'a_darkwhite'

  elseif order and conf['highlight'..order] then
    color     = conf[order..'color'] or 'a_darkwhite'

  elseif (city == "" or city == 'rogue') and conf.highlightrogues then
    color     = conf.roguescolor or 'a_darkwhite'

  elseif city and conf['highlight'..city] then
    color     = conf[city..'color'] or 'a_darkwhite'
  end

  -- rest of things
  bold      = (conf.boldwatchfor and watchfor)            or
                (conf.boldcity and cityenemy == 1)        or
                (conf.boldorder and orderenemy == 1)      or
                (conf.boldhouse and houseenemy == 1)      or
                (conf.bolddivine and immortal == 1)       or
                (order and conf['bold'..order])           or
                ((city == "" or city == 'rogue') and conf.boldrogues) or
                (city and conf['bold'..city])

  underline = (conf.underlinewatchfor and watchfor)       or
                (conf.underlinecity and cityenemy == 1)   or
                (conf.underlineorder and orderenemy == 1) or
                (conf.underlinehouse and houseenemy == 1) or
                (conf.underlinedivine and immortal == 1)  or
                (order and conf['underline'..order])      or
                ((city == "" or city == 'rogue') and conf.underlinerogues) or
                (city and conf['underline'..city])

  italicize = (conf.italicizewatchfor and watchfor)       or
                (conf.italicizecity and cityenemy == 1)   or
                (conf.italicizeorder and orderenemy == 1) or
                (conf.italicizehouse and houseenemy == 1) or
                (conf.italicizedivine and immortal == 1)  or
                (order and conf['italicize'..order])      or
                ((city == "" or city == 'rogue') and conf.italicizerogues) or
                (city and conf['italicize'..city])

  if not (color or bold or underline or italicize) then return end

  ndb.highlightIDs = ndb.highlightIDs or {}
  ndb.highlightIDs[name] = tempTrigger(name, ([[ndb.highlight("%s", %s, %s, %s, %s)]]):format(name,
    (color     and '"'..color..'"' or 'false'),
    (bold      and 'true' or 'false'),
    (underline and 'true' or 'false'),
    (italicize and 'true' or 'false')
  ))
end

function ndb.cleartriggers()
  if not ndb.highlightIDs or not next(ndb.highlightIDs) then return end

  local killTrigger = killTrigger
  for _,v in pairs(ndb.highlightIDs) do
    killTrigger(v)
  end

  ndb.highlightIDs = {}
end

function ndb.highlight(who, color, bold, underline, italicize)
  -- c counts the appearance of the substring of the word in the line, k counts the character position
  local c, k = 1, 1
  while k &gt; 0 do
    k = line:find(who, k)
    if k == nil then return; end
    c = c + 1

    if k == line:find("%f[%a]"..who.."%f[%A]", k) then
      if selectString(who, c-1) &gt; -1 then
        if color     then fg(color) end
        if bold      then setBold(true) end
        if underline then setUnderline(true) end
        if italicize then setItalics(true) end
        resetFormat()
      else return end
    end

--    k = k + #who
    k = k + 1 -- this is a quicker optimization
  end
end

function ndb.finished_honors(event, name, type)
  if svo.conf.paused or not ndb.honorslist then return end
  local type = ndb.gaghonours and 'quiet' or 'manual'

  local name = next(ndb.honorslist or {})
  if not name then
    if type ~= 'manual' then
      echo'\n'
      svo.echof("Done checking all new names.")
      svo.showprompt()
      raiseEvent("NameDB finished all honors")
    end

    ndb.manualcheck = nil
    ndb.hidehonorswindow()
    return
  end
end

function ndb.honors_next(argument)
  if not svo.conf.autocheck and not ndb.manualcheck then return end
  if svo.conf.usehonors and not svo.bals.equilibrium then return end
  if not svo.conf.usehonors and argument then return end -- argument is passed if this comes from a balance,
                                                         -- which is for usehonors only - with it off, autohonors will start many honors processes

  local name = next(ndb.honorslist or {})
  if not name then return end

  if svo.conf.usehonors then
    ndb.honors(name, 'quiet')
  else
    --ndb.getinfo(name) -- Achaea disallowed use of website scraping
    return
  end

  ndb.honorslist[name] = nil
  local left = table.size(ndb.honorslist)

  local timeleft = {}
  if svo.conf.usehonors then
    -- honors takes 2s eq
    local leftseconds = left * 2

    local h,m,s = seconds2human(leftseconds)
    if h &gt; 0 then
      timeleft[#timeleft+1] = h..'h'
    end
    if h &gt; 0 and m &gt; 0 then
      timeleft[#timeleft+1] = ", "
    end
    if m &gt; 0 then
      timeleft[#timeleft+1] = m..'m'
    end
    if m &gt; 0 and s &gt; 0 then
      timeleft[#timeleft+1] = ", "
    end
    if s &gt; 0 then
      timeleft[#timeleft+1] = s..'s'
    end
  end

  ndb.showhonorswindow(string.format("Checking %s, %s name%s%s left to check...\n", name, left, (left == 1 and '' or 's'), (next(timeleft) and '('..table.concat(timeleft)..')' or '')))
end
registerAnonymousEventHandler("svo got balance", "ndb.honors_next")
local luanotify = {}
luanotify.signal = require("notify.signal")
svo.signals["namedb finished honors"] = luanotify.signal.new()
svo.signals["namedb finished honors"]:connect(ndb.honors_next, 'run honors_next once finished with one')

-- sk.togglehonors = function()
--   if svo.conf.usehonors then
--     svo.signals["namedb finished honors"]:block(ndb.honors_next)

-- end
-- svo.signals["svo config changed"]:connect(sk.togglehonors)


if firstload then ndb.configs() end
ndb.loadhighlights()

end)
</script>
				<eventHandlerList />
			</Script>
		</ScriptGroup>
	</ScriptPackage>
	<KeyPackage />
	<HelpPackage>
		<helpURL></helpURL>
	</HelpPackage>
</MudletPackage>
